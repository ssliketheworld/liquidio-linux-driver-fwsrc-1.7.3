diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/arch/mips/cpu/octeon/octeon_seapi.c OCTEON-SDK/bootloader/u-boot/arch/mips/cpu/octeon/octeon_seapi.c
--- OCTEON_SDK_CLEAN/bootloader/u-boot/arch/mips/cpu/octeon/octeon_seapi.c	2018-05-15 11:35:34.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/arch/mips/cpu/octeon/octeon_seapi.c	2018-06-28 15:08:31.066008778 -0700
@@ -860,6 +860,36 @@ static int SEAPI_qlm_tune(uint64_t sig_a
 }
 
 /**
+ * Run the software based self healing
+ *
+ * @param sig_addr	Physical address of signature (not used)
+ * @param call		system call number (not used)
+ * @param retval_addr	Physical address to write return data (not used)
+ * @param arg0		board type
+ * @param arg1		interface
+ * @param arg2		mode
+ * @param arg3		falgs
+ * @param arg4		prev_temp
+ *
+ * @return		0 for success, CVMX_SEAPI_EINVAL
+ *
+ */
+static int SEAPI_sw_self_healing(uint64_t sig_addr, int call, uint64_t retval_addr,
+			  uint64_t arg0, uint64_t arg1, uint64_t arg2,
+			  uint64_t arg3, uint64_t arg4)
+{
+	switch (arg0) {
+		case CVMX_BOARD_TYPE_NIC225E:
+#if defined(CONFIG_OCTEON_NIC225E)
+			return octeon_phy_sw_self_healing(arg1, arg2, arg3, arg4);
+#endif
+
+		default:
+			return CVMX_SEAPI_EINVAL;
+	}
+}
+
+/**
  * Initializes support for the Simple Exec API
  *
  * @return 0 for success, error otherwise
@@ -896,6 +926,7 @@ int seapi_init(void)
 	call_table[CVMX_SEAPI_ENV_GET] = SEAPI_getenv;
 	call_table[CVMX_SEAPI_DEV_USB_START] = SEAPI_usb_start;
 	call_table[CVMX_SEAPI_QLM_TUNE] = SEAPI_qlm_tune;
+	call_table[CVMX_SEAPI_SW_HEAL] = SEAPI_sw_self_healing;
 	call_table[CVMX_SEAPI_ENV_SET] = SEAPI_setenv;
 	call_table[CVMX_SEAPI_ENV_SAVE] = SEAPI_saveenv;
 
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/arch/mips/include/asm/arch-octeon/octeon_board_common.h OCTEON-SDK/bootloader/u-boot/arch/mips/include/asm/arch-octeon/octeon_board_common.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/arch/mips/include/asm/arch-octeon/octeon_board_common.h	2018-05-15 11:35:34.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/arch/mips/include/asm/arch-octeon/octeon_board_common.h	2018-06-28 15:08:31.066008778 -0700
@@ -134,6 +134,13 @@ void board_mdio_init(void);
 void octeon_board_poll(void);
 
 /**
+ * User-defined function that is called when the sw self healing is used to
+ * tune the phy
+ *
+ */
+int octeon_phy_self_healing(uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3);
+
+/**
  * Called before USB is initialized
  *
  * @return 0 for success, error otherwise.
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/arch/mips/include/asm/arch-octeon/octeon_qlm.h OCTEON-SDK/bootloader/u-boot/arch/mips/include/asm/arch-octeon/octeon_qlm.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/arch/mips/include/asm/arch-octeon/octeon_qlm.h	2018-05-15 11:35:34.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/arch/mips/include/asm/arch-octeon/octeon_qlm.h	2018-06-28 15:08:31.066008778 -0700
@@ -139,6 +139,27 @@ void octeon_qlm_dfe_disable(int node, in
  * @param qlm      QLM to configure
  * @param pre_ctle pre-ctle settings for low loss channels
  */
+
+/**
+ * Disables DFE, uses fixed CTLE Peak value and AGC settings
+ * for the specified QLM lane(s).
+ * This function should only be called for low-loss channels.
+ * This function prevents Rx equalization from happening on all lanes in a QLM
+ * This function should be called for all lanes being used in the QLM.
+ *
+ * @param  node           Node to configure
+ * @param  qlm            QLM to configure
+ * @param  lane           Lane to configure, or -1 all lanes
+ * @param  baud_mhz       The speed the QLM needs to be configured in Mhz.
+ * @param  mode           The QLM to be configured as SGMII/XAUI/PCIe.
+ * @param  ctle_zero      Equalizer Peaking control
+ * @param  agc_pre_ctle   Pre-CTLE gain
+ * @param  agc_post_ctle  Post-CTLE gain
+ * @return Zero on success, negative on failure
+ */
+
+int octeon_qlm_dfe_disable_ctle_agc(int node, int qlm, int lane, int baud_mhz, int mode, int ctle_zero, int agc_pre_ctle, int agc_post_ctle);
+
 extern void octeon_qlm_set_channel_v3(int node, int qlm, int pre_ctle);
 
 extern void octeon_init_qlm(int node);
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/arch/mips/include/asm/arch-octeon/seapi_public.h OCTEON-SDK/bootloader/u-boot/arch/mips/include/asm/arch-octeon/seapi_public.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/arch/mips/include/asm/arch-octeon/seapi_public.h	2018-05-15 11:35:34.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/arch/mips/include/asm/arch-octeon/seapi_public.h	2018-06-28 15:08:31.067008779 -0700
@@ -52,7 +52,8 @@ typedef int (*cvmx_syscall_t)(int, int *
 
 #define CVMX_SEAPI_SIG_VERSION_MAJ	1	/** Major version */
 /* 1.1: Added setenv and saveenv support */
-#define CVMX_SEAPI_SIG_VERSION_MIN	1	/** Minor version */
+/* 1.2: Added sw based self healing of phy */
+#define CVMX_SEAPI_SIG_VERSION_MIN	2	/** Minor version */
 #define CVMX_SEAPI_SIG_MAGIC		"UBootAPI"
 #define CVMX_SEAPI_SIG_MAGLEN		8
 /** Stack size for U-Boot context (normally it's 192K) */
@@ -142,6 +143,7 @@ enum {
 	CVMX_SEAPI_QLM_TUNE,		/** Tune QLM tx parameters */
 	CVMX_SEAPI_ENV_SET,		/** Set a U-Boot environment variable */
 	CVMX_SEAPI_ENV_SAVE,		/** Save all environment variables */
+	CVMX_SEAPI_SW_HEAL,		/** Run sw self healing */
 	CVMX_SEAPI_MAXCALL,
 };
 
@@ -238,6 +240,26 @@ struct cvmx_seapi_device_info {
 };
 
 /**
+ * Flags used by Sw Self Healing
+ */
+enum cvmx_seapi_sw_selfheal_flags {
+	CVMX_SW_SELFHEAL_UNKNOWN	= 0x0000,	
+	CVMX_SW_SELFHEAL_INIT		= 0x0001,
+	CVMX_SW_SELFHEAL_REINIT		= 0x0002,
+	CVMX_SW_SELFHEAL_HOST_TUNE	= 0x0004,
+	CVMX_SW_SELFHEAL_MOD_TUNE	= 0x0008,
+	CVMX_SW_SELFHEAL_TEMP_CHECK	= 0x0010,
+	CVMX_SW_SELFHEAL_MOD_ABSENT	= 0x0020,
+	CVMX_SW_SELFHEAL_10G_MODE	= 0x0040,
+	CVMX_SW_SELFHEAL_EN_FEC		= 0x0080,
+	CVMX_SW_SELFHEAL_ACTIVE_CABLE	= 0x0100,
+	CVMX_SW_SELFHEAL_INIT_OK	= 0x0200,
+	CVMX_SW_SELFHEAL_EI_DEBOUNCE	= 0x0400,
+	CVMX_SW_SELFHEAL_FORCE_HEAL_MOD = 0x0800,
+	CVMX_SW_SELFHEAL_MOD_CONFIG	= 0x1000,
+};
+
+/**
  * Syscall function prototype
  *
  * @param	sig_paddr	Physical signature address
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/Makefile OCTEON-SDK/bootloader/u-boot/board/octeon/common/Makefile
--- OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/Makefile	2018-05-15 11:35:34.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/board/octeon/common/Makefile	2018-06-28 15:08:31.067008779 -0700
@@ -46,9 +46,9 @@ COBJS-$(CONFIG_PHY_AVAGO)	+= phy/avago.o
 				   phy/avago_logging.o \
 				   phy/avago_sbus.o \
 				   phy/avago_serdes.o phy/avago_serdes_dfe.o \
-				   phy/avago_spico.o phy/avago_5410.o \
+				   phy/avago_spico.o phy/avago_5410.o phy/avago_sensor.o \
 				   phy/avago_avsp.o phy/avago_uboot.o \
-				   phy/avago_str_conv.o
+				   phy/avago_str_conv.o phy/avago_avsp_5410_sw_sh.o
 endif
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c) $(COBJS-y:.o=.c)
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago.h OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago.h	2018-05-15 11:35:35.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago.h	2018-06-28 15:08:31.068008780 -0700
@@ -1011,6 +1011,8 @@ enum avago_srdev {
 	AVAGO_SDREV_OM4		= 5,
 	AVAGO_SDREV_CM4		= 6,
 	AVAGO_SDREV_CM4_16	= 7,
+	AVAGO_SDREV_PON		= 9,
+	AVAGO_SDREV_D6_07	=10,
 	AVAGO_SDREV_XXX
 };
 
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_5410.c OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_5410.c
--- OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_5410.c	2018-05-15 11:35:34.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_5410.c	2018-06-28 15:08:31.068008780 -0700
@@ -33,6 +33,76 @@
 #include "avago_spico.h"
 
 /**
+ ** @brief        Writes a AVSP5410 MTIP Core PCS register.
+ ** @param ah   Pointer to avago_hdl structure.
+ ** @param reg    MTIP Core PCS register offset
+ ** @param data   Data to write
+ ** @return       Returns the result of the last avago_sbus_wr function, which should generally be ignored.
+ **/
+uint avsp5410_mtip_pcs_wr(struct avago_hdl *ah, uint reg, uint data)
+{
+    /* The MTIP Core PCS is mapped to SBUS addr 0xb */
+    uint sbus_addr = 0xb;
+
+    avago_sbus_wr(ah, sbus_addr, 10, reg);
+    avago_sbus_wr(ah, sbus_addr, 12, data);
+    avago_sbus_wr(ah, sbus_addr, 6, 2);
+    return avago_sbus_wr(ah, sbus_addr, 6, 0);
+}
+
+/**
+ ** @brief        Reads a AVSP5410 MTIP Core PCS register.
+ ** @param ah   Pointer to avago_hdl structure.
+ ** @param reg    MTIP Core PCS register offset
+ ** @return       Returns the result of the read operation.
+ **/
+uint avsp5410_mtip_pcs_rd(struct avago_hdl *ah, int reg)
+{
+    /* The MTIP Core PCS is mapped to SBUS addr 0xb */
+    uint sbus_addr = 0xb;
+
+    avago_sbus_wr(ah, sbus_addr, 10, reg);
+    avago_sbus_wr(ah, sbus_addr, 6, 1);
+    avago_sbus_wr(ah, sbus_addr, 6, 0);
+    return avago_sbus_rd(ah, sbus_addr, 20); 
+}
+
+/**
+ ** @brief        Reads a AVSP5410 MTIP Core RS-FEC register.
+ ** @param ah   Pointer to avago_hdl structure.
+ ** @param reg    MTIP Core RS-FEC register offset
+ ** @param data   Data to write
+ ** @return       Returns the result of the last avago_sbus_wr function, which should generally be ignored.
+ **/
+uint avsp5410_mtip_rsfec_wr(struct avago_hdl *ah, uint reg, uint data)
+{
+    /* The MTIP Core RS-FEC is mapped to SBUS addr 0xb */
+    uint sbus_addr = 0xb;
+
+    avago_sbus_wr(ah, sbus_addr, 11, reg);
+    avago_sbus_wr(ah, sbus_addr, 13, data);
+    avago_sbus_wr(ah, sbus_addr, 6, 8);
+    return avago_sbus_wr(ah, sbus_addr, 6, 0);
+}
+
+/**
+ ** @brief        Reads a AVSP5410 MTIP Core RS-FEC register.
+ ** @param ah   Pointer to avago_hdl structure.
+ ** @param reg    MTIP Core RS-FEC register offset
+ ** @return       Returns the result of the read operation.
+ **/
+uint avsp5410_mtip_rsfec_rd(struct avago_hdl *ah, int reg)
+{
+    /* The MTIP Core RS-FEC is mapped to SBUS addr 0xb */
+    uint sbus_addr = 0xb;
+
+    avago_sbus_wr(ah, sbus_addr, 11, reg);
+    avago_sbus_wr(ah, sbus_addr, 6, 4);
+    avago_sbus_wr(ah, sbus_addr, 6, 0);
+    return avago_sbus_rd(ah, sbus_addr, 21); 
+}
+
+/**
  * @brief	Configure internal logic for the given mode.
  * @details	Assumes that the crosspoint configured externally.
  *
@@ -169,12 +239,21 @@ int avsp_5410_set_mode(struct avago_hdl
 /** @brief  Retrieves the mode into which the core logic is configured. */
 /** @return Returns the core logic configuration mode. */
 enum avsp_mode avsp_5410_get_mode(struct avago_hdl * ah,
-				/**< [in] Pointer to Aapl_t structure. */
+				/**< [in] Pointer to avago_hdl structure. */
 			       uint32_t prtad)
 {
 /**< [in] Port address of the target device. */
 	uint32_t addr = avago_make_addr3(prtad, 0, 0xfd);
 	int val = avago_spico_int(ah, addr, 0x26, 0x3800) & 0x0f;
+	/* Bug in SBUS firmware 0x041F_0704. Both gearbox_4_1 & RS_FEC set val == 2*/
+	/* Using MTIP RS-FEC Vendor Control Reg to determine if FEC is enabled.  */
+	/* bit 15 == 1 (FEC enabled) */
+	if (val == 2) {
+		if ((avsp5410_mtip_rsfec_rd(ah, 0x80) >> 15) & 0x1) {
+			val = 3;
+		}  
+	}
+
 	enum avsp_mode mode = val == 0x001 ?
 			AVSP_REPEATER_DUPLEX : val == 0x002 ?
 				AVSP_GEARBOX_4_1 : val == 0x003 ?
@@ -185,9 +264,9 @@ enum avsp_mode avsp_5410_get_mode(struct
 
 /** @brief   Directly resets the core logic. */
 /** @return  On success, returns 0. */
-/** @return  On failure, decrements aapl->return_code and returns -1. */
+/** @return  On failure, decrements ah->return_code and returns -1. */
 bool avsp_5410_control_logic_reset_direct(struct avago_hdl * ah,
-					/**< [in] Pointer to Aapl_t structure. */
+					/**< [in] Pointer to avago_hdl structure. */
 					  uint32_t prtad,
 			   /**< [in] Port address of the targeted device. */
 					  const char *direction)
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_avsp_5410_sw_sh.c OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_avsp_5410_sw_sh.c
--- OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_avsp_5410_sw_sh.c	1969-12-31 16:00:00.000000000 -0800
+++ OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_avsp_5410_sw_sh.c	2018-06-28 15:08:31.070008782 -0700
@@ -0,0 +1,1388 @@
+/* Suport for software self-healing on AVSP-5410/5820 */
+
+/** Doxygen File Header
+ ** @file avago_avsp_5410_sw_sh.c
+ ** @brief Functions for software-based self-healing on the AVSP-5410/5820 ASSPs
+ **/
+
+#include <common.h>
+#include <malloc.h>
+#include "avago.h"
+#include "avago_serdes.h"
+#include "avago_serdes_pmd.h"
+#include "avago_spico.h"
+#include "avago_logging.h"
+#include "avago_sbus.h"
+#include "avago_avsp.h"
+#include "avago_sensor.h"
+#include "avago_str_conv.h"
+#include "avago_avsp_5410_sw_sh.h"
+
+/* some universal variables: */
+#define SH_MOD_SERDES_NUM 1
+#define SH_MOD_SERDES_ADDR 0x5
+#define SH_HOST_SERDES_NUM 4
+#define SH_HOST_SERDES_NUM_10G 1
+#define SH_HOST_SERDES_ADDRS 0x9,0x8,0x7,0x6
+#define SH_HOST_SERDES_ADDR_10G 0x9
+#define SH_ALL_SERDES_NUM 5
+#define SH_ALL_SERDES_NUM_10G 2
+#define SH_ALL_SERDES_ADDRS 0x5,0x6,0x7,0x8,0x9
+#define SH_ALL_SERDES_ADDRS_10G 0x5,0x9
+
+/* MTIP Registers */
+#define MTIP_PCS_STATUS1_REG          0x1
+#define MTIP_PCS_CONTROL1_REG         0x0
+#define MTIP_PCS_BASER_STATUS2        0x21
+#define MTIP_RS_FEC_VENDOR_CONTROL    0x80
+#define MTIP_BER_HIGH_ORDER_CNT       0x2c
+#define MTIP_ERRBLK_HIGH_ORDER_CNT    0x2d
+
+#define Aapl_t struct avago_hdl
+#define TRUE  1
+#define FALSE 0
+#define Avago_serdes_rx_term_t enum avago_serdes_rx_term
+#define Avago_serdes_tx_eq_t struct avago_serdes_tx_eq
+
+const char *avago_addr_to_string(uint32_t addr)
+{
+
+#   define NUM_BUFS (5)
+    static uint32_t which = 0;
+    static char num_bufs[NUM_BUFS][20];
+
+    char *buf = num_bufs[which = (which + 1) % NUM_BUFS];
+    char *ptr = buf;
+
+    /* [[[chip]:][ring]:]sbus[.lane] */
+    struct avago_addr addr_struct;
+
+    avago_addr_to_struct(addr,&addr_struct);
+
+    if( addr_struct.chip > 0 )
+    {
+        if( addr_struct.chip == AVAGO_ADDR_BROADCAST )
+            ptr += snprintf(ptr,end-ptr,"*:");
+        else
+            ptr += snprintf(ptr,end-ptr,"%x:",addr_struct.chip);
+    }
+
+    if( addr_struct.ring > 0 )
+    {
+        if( addr_struct.ring == AVAGO_ADDR_BROADCAST )
+            ptr += snprintf(ptr,end-ptr,"*");
+        else
+            ptr += snprintf(ptr,end-ptr,"%x",addr_struct.ring);
+    }
+
+    ptr += snprintf(ptr,end-ptr,":%x", addr_struct.sbus);
+
+    if( addr_struct.lane < 8 )
+        ptr += snprintf(ptr,end-ptr,".%x", addr_struct.lane);
+    else if( addr_struct.lane == AVAGO_ADDR_QUAD_ALL )
+        ptr += snprintf(ptr,end-ptr,".*");
+    else if( addr_struct.lane == AVAGO_ADDR_QUAD_LOW )
+        ptr += snprintf(ptr,end-ptr,".L");
+    else if( addr_struct.lane == AVAGO_ADDR_QUAD_HIGH )
+        ptr += snprintf(ptr,end-ptr,".H");
+
+    return buf;
+
+}
+
+int avago_serdes_dfe_wait_timeout(
+    Aapl_t *ah,       /**< [in] Pointer to Aapl_t structure. */
+    uint32_t addr,          /**< [in] Device address number. */
+    int ms_timeout)     /**< [in] Maximum milliseconds to wait for dfe to complete. */
+{
+    // Wait for tuning to stop:
+    int dfe_status = avago_serdes_dfe_running(ah, addr);
+    // dfe_status > 0 == running, 0 == complete, -1 = Loss of Signal
+    int ret_status;
+    int loop_delay = 40; // milliseconds
+    int loop_time = 0;
+
+    while( dfe_status > 0 && loop_time < ms_timeout )
+    {
+        loop_time += loop_delay;
+        mdelay(loop_delay);
+        dfe_status = avago_serdes_dfe_running(ah, addr);
+    }
+    ret_status = dfe_status == 0 ? 1 : dfe_status > 0 ? 0 : -1; // Convert to return value
+    if( ret_status < 0 ) ah->return_code--;   // Decrement return_code on LOS return.
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    	"SBus %s, DFE tuning %s, loop_time=%d ms.\n", avago_addr_to_string(addr),
+	ret_status == 0 ? "stop timed out" : ret_status == 1 ? "stopped" : "no signal", loop_time);
+    return ret_status;
+}
+
+uint avago_serdes_eye_get_simple_metric(
+    Aapl_t *ah,                       /**< [in] Pointer to Aapl_t structure. */
+    uint addr)                          /**< [in] Device address number. */
+{
+    int i, results = 1000;
+    for( i = 0; i < 8; i += 2 )
+    {
+        short val1 = avago_spico_int(ah,addr, 0x126, (4 << 12) | ((i+0) << 8));
+        short val2 = avago_spico_int(ah,addr, 0x126, (4 << 12) | ((i+1) << 8));
+        int height = val2 - val1;
+        if( height < results )
+            results = height;
+    }
+    results = results * 1000 / 255;
+    return results;
+}
+
+static uint ones_count(uint data)
+{
+    uint i;
+    uint cf=0;
+    for( i = 0; i < 15; i++ )
+    {
+        if ((data >> i) & 0x1)  /* Count the number of ones set */
+            cf += 1;
+    }
+    return cf;
+}
+
+#define AVSP_GEARBOX_HOST_CF_NOM 80
+#define AVSP_GEARBOX_MOD_CF_NOM 100
+#define AVSP_REPEATER_HOST_CF_NOM 25
+#define AVSP_REPEATER_MOD_CF_NOM 50
+#define AVSP_CF_MARGIN 10
+
+/**
+ ** @brief   Checks that CF is within the allowable range
+ ** @brief   for AVSP 5410 SERDES
+ ** @return  TRUE if AVSP_5410 SERDES is correctly initialized 
+ **/
+bool avsp_5410_cf_ok(
+    Aapl_t *ah,           /**< [in] Pointer to Aapl_t structure.*/
+    enum avsp_mode chip_mode,  /**< [in] Device chip mode. */
+    uint addr)              /**< [in] Device address number. */
+{
+    int reg_thrm_cal, reg_bin_cal, my_cf_value;
+    int cf_min, cf_max;
+
+    int sdrev = avago_get_sdrev(ah, addr);
+
+    switch( sdrev ) {
+    case AVAGO_SDREV_D6:   reg_thrm_cal = 0x202; reg_bin_cal = 0x203; break;
+    default:
+    case AVAGO_SDREV_D6_07:  reg_thrm_cal = 0x42d; reg_bin_cal = 0x42e; break;
+    }
+    
+    my_cf_value = 8 * ones_count( avago_serdes_mem_rd(ah, addr, AVAGO_ESB,reg_thrm_cal) & 0x7fff );
+    my_cf_value +=  avago_serdes_mem_rd(ah, addr, AVAGO_ESB, reg_bin_cal) & 0x007;
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"SBus %-3s: CF = %d\n", avago_addr_to_str(addr), my_cf_value);
+
+    switch( chip_mode )
+    {
+    case AVSP_RS_FEC:
+    case AVSP_GEARBOX_4_1:             
+        if (addr == SH_MOD_SERDES_ADDR) {
+            cf_min =  AVSP_GEARBOX_MOD_CF_NOM - AVSP_CF_MARGIN;
+            cf_max =  AVSP_GEARBOX_MOD_CF_NOM + AVSP_CF_MARGIN;
+        } else {
+            cf_min =  AVSP_GEARBOX_HOST_CF_NOM - AVSP_CF_MARGIN;
+            cf_max =  AVSP_GEARBOX_HOST_CF_NOM + AVSP_CF_MARGIN;
+        }
+        break;
+    case AVSP_REPEATER_DUPLEX:             
+        if (addr == SH_MOD_SERDES_ADDR) {
+            cf_min =  AVSP_REPEATER_MOD_CF_NOM - AVSP_CF_MARGIN;
+            cf_max =  AVSP_REPEATER_MOD_CF_NOM + AVSP_CF_MARGIN;
+        } else {
+            cf_min =  AVSP_REPEATER_HOST_CF_NOM - AVSP_CF_MARGIN;
+            cf_max =  AVSP_REPEATER_HOST_CF_NOM + AVSP_CF_MARGIN;
+        }
+        break;
+    default:
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"Unknown chip configuration 0x%u\n", chip_mode);
+        return 0; /*Error*/  
+        break;
+    }
+
+    if ((my_cf_value < cf_min) || (my_cf_value > cf_max)) {
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"SBus %-3s: CF(%d) is outside the allowable range\n", avago_addr_to_str(addr), my_cf_value); 
+        return 0; /* Fail */
+    } 
+   
+    return 1;
+} /* end function avsp_5410_cf_ok */
+
+/**
+ ** @brief   Verifies if AVSP_5410 is correctly initialized
+ ** @details Checks that CF is within the allowable range
+ ** @return  TRUE if AVSP_5410 is correctly initialized 
+ **/
+bool avsp_5410_init_ok(
+    Aapl_t *ah,           /**< [in] Pointer to Aapl_t structure.*/
+    enum avsp_mode chip_mode,  /**< [in] Device chip mode. */
+    uint chip,              /**< [in] Device chip number. */
+    uint ring)              /**< [in] Device target ring number. */
+{
+    /* 25G Mode = All 4 Host SERDES used, 10G Mode = Only first Host SERDES used */
+    uint host_serdes_addrs[] = { SH_HOST_SERDES_ADDRS };
+    uint host_serdes_num = (chip_mode == AVSP_REPEATER_DUPLEX) ? SH_HOST_SERDES_NUM_10G : SH_HOST_SERDES_NUM ;      
+    uint index = 0;
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Checking that the Host SERDES initialized correctly.\n");
+
+    for( index=0; index < host_serdes_num; index++ )
+    {
+        if (!avsp_5410_cf_ok(ah, chip_mode, avago_make_addr3(chip, ring, host_serdes_addrs[index]))) {
+    	    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+            		"SBus %-3s: CF is outside the allowable range..\n",
+                            avago_addr_to_str(avago_make_addr3(chip, ring, host_serdes_addrs[index])));
+            return FALSE;
+        }
+    }            
+
+    /* Check CF for MOD SERDES */
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Checking that the MOD SERDES initialized correctly.\n");
+
+    if (!avsp_5410_cf_ok(ah, chip_mode, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR))) {
+    	    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+            		"SBus %-3s: is outside the allowable range..\n",
+                        avago_addr_to_str(avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR)));
+        return FALSE;
+    }
+        
+    return TRUE;
+} /* end function avsp_5410_init_ok */
+
+/**
+ ** @brief   Debounces the presence of signal energy
+ ** @details Reads the live electrical idle and returns whether passing in majority 
+ ** @return  TRUE if signal present in majority of threshold out of cycles 
+ ** @see     avago_serdes_get_electrical_idle()
+ **/
+bool sw_self_healing_ei_debounce(
+    Aapl_t *ah,       /**< [in] Pointer to Aapl_t structure.*/
+    uint32_t addr,          /**< [in] Device address number. */
+    uint32_t threshold,     /**< [in] Majority of cycles that need to be passing. */
+    uint32_t cycles)        /**< [in] Number of cycles to debounce */
+{
+    uint32_t index, debounce = 0;
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Debouncing electrical idle for Sbus addr %-3s ...\n", avago_addr_to_string(addr));
+
+    /* check for signal presence and account times it was for n cycles */
+    for( index=0; index < cycles; index++ )
+    {
+        /* @return  Returns TRUE if electrical idle is detected, FALSE if a signal */
+        if( !avago_serdes_get_electrical_idle(ah, addr) ){ debounce++; }
+    }
+    if ( debounce >= threshold )
+    {
+        return 1;
+    }
+    else
+    {
+        return 0;
+    }
+} /* end function sw_self_healing_ei_debounce */
+
+/**
+ ** @brief   Debounces the presence of signal energy
+ ** @details Reads the live frequency lock and returns whether passing in majority
+ ** @return  TRUE if frequency locked in majority of threshold out of cycles 
+ ** @see     avago_serdes_get_frequency_lock()
+ **/
+bool sw_self_healing_flock_debounce(
+    Aapl_t *ah,       /**< [in] Pointer to Aapl_t structure. */
+    uint32_t addr,          /**< [in] Device address number. */
+    uint32_t threshold,     /**< [in] Majority of cycles that need to be passing. */
+    uint32_t cycles)        /**< [in] Number of cycles to debounce */
+{
+    uint32_t index, debounce = 0;
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Debouncing frequency lock for Sbus addr %-3s ...\n", avago_addr_to_string(addr));
+
+    /* check for signal presence and account times it was for n cycles */
+    for( index=0; index < cycles; index++ )
+    {
+        /*  @return  Returns TRUE if the PLL is locked
+            @return  Returns FALSE if the PLL is not locked */
+      
+        if( avago_serdes_get_frequency_lock(ah, addr) ){ debounce++; }
+    }
+    if ( debounce >= threshold )
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+} /* end function sw_self_healing_flock_debounce */
+
+/**
+ ** @brief   Debounces the presence of frequency lock AND signal presence 
+ ** @details Reads the sticky signal_ok which is !EI && flock and returns whether in majority
+ ** @return  TRUE if signal_ok in majority of threshold out of cycles 
+ ** @see     avago_serdes_get_signal_ok()
+ **/
+bool sw_self_healing_signal_ok_debounce(
+    Aapl_t *ah,       /**< [in] Pointer to Aapl_t structure. */
+    uint32_t addr,          /**< [in] Device address number. */
+    uint32_t threshold,     /**< [in] Majority of cycles that need to be passing. */
+    uint32_t cycles)        /**< [in] Number of cycles to debounce */
+{
+    uint32_t index, debounce = 0;
+    bool was_signal_ok;
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Debouncing signal_ok for Sbus addr %-3s ...\n", avago_addr_to_string(addr));
+
+    /* check for signal presence and account times it was not for n cycles */
+    for( index=0; index < cycles; index++ )
+    {
+        /* @details Reads a sticky signal lost detector and returns whether any
+                    loss was detected since the last call to this function.
+                    Resets the detector if reset is enabled and signal loss was
+                    detected so can tell if a signal is once again present.
+           @return  Returns TRUE if no signal loss has been detected.
+           @return  Returns FALSE if signal loss was detected since last check. */
+
+        /* clear any stale bad signal_ok indication */
+        avago_serdes_get_signal_ok(ah, addr, TRUE);
+        /* now perform actual check */
+        was_signal_ok=avago_serdes_get_signal_ok(ah, addr, FALSE);
+        if( was_signal_ok ){ debounce++; }
+	/* AES debug Dec 2, 2017 */
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"Index %u, cycles %u, threshold %u, signal_ok %d, debounce %u \n", index, threshold, cycles, was_signal_ok, debounce );
+    }
+    if ( debounce >= threshold )
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+} /* end function sw_self_healing_signal_ok_debounce */
+
+/**
+ ** @brief   Tracks port vilification
+ ** @details Compares counter passed in with specified max.  Issues user and default messages and returns TRUE
+ ** @return  TRUE if port has been vilified, FALSE else
+ **/
+
+bool sw_self_healing_vilify_port(
+    Aapl_t *ah,       /**< [in] Pointer to Aapl_t structure. */
+    uint32_t addr,          /**< [in] Device address number. */
+    uint32_t *count,        /**< [in] Pointer to current count of violations. */
+    uint32_t limit,         /**< [in] Max violations allowed. */
+    const char *fmt,    /**< [in] printf format string for user message. */
+    ...)                /**< [in] printf arguments for user message. */
+
+{
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Checking if port vilified for Sbus addr %-3s ...\n", avago_addr_to_string(addr));
+
+    /* as this function has been called, increment number of times port has been in violation */
+    (*count)++;
+    /* compare to the user-specified limit */
+    if ( *count >= limit )
+    {
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"SerDes at SBus address %-3s has been vilified.\n", avago_addr_to_string(addr));
+        
+        /* print user-specified failure message */
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, fmt);
+        /* return that the port ha sbeen vilified so user knows to take a final action */
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+} /* end function sw_self_healing_vilify_port */
+
+/**
+ ** @brief   Customizes the AVSP-5410 gearbox after part initialization
+ ** @details Configures rx-termination, per-serdes EI threshold, TX atten, DFE customizations 
+ ** @return  On error, returns -1 and ah->return_code is set to negative value.
+ ** @see     avago_serdes_set_rx_term(),avago_serdes_set_tx_eq(),avago_serdes_initialize_signal_ok()
+ **/
+int avsp_5410_bootstrap(
+    Aapl_t *ah,       /**< [in] Pointer to Aapl_t structure. */
+    enum avsp_mode chip_mode,  /**< [in] Device chip mode. */
+    uint32_t chip,          /**< [in] Device chip number. */
+    uint32_t ring,          /**< [in] Device target ring number. */
+    uint32_t host_tx_atten)          /**< [in] host serdes tx atten. */
+{
+    int ret = 0;
+    int mC;
+    uint32_t index = 0;
+    uint32_t data;
+    uint32_t frequency = 161132813; /* Refclk frequency in Hz */
+    uint32_t sbus_addr = 1;
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Customizing gearbox after state-ing part...\n");
+
+    /* Configuring SERDES for 25G mode (FEC and NON-FEC). */
+    if (chip_mode == AVSP_GEARBOX_4_1 || chip_mode == AVSP_RS_FEC) {
+        Avago_serdes_rx_term_t  rx_term = AVAGO_SERDES_RX_TERM_AGND;
+        static uint32_t  all_serdes_addrs[] = { SH_ALL_SERDES_ADDRS };
+	static uint32_t host_serdes_addrs[] = { SH_HOST_SERDES_ADDRS };
+        int ei_threshold;
+
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Setting RX termination...\n");
+        /* (assumes serdes and supervisor firmware has been loaded and part has been stated via 0xfd int 0x24) */
+        /* configure RX-termination to GND for additional noise rejection */
+        for( index=0; index < SH_ALL_SERDES_NUM; index++ )
+        {
+		if (avago_serdes_set_rx_term(ah, avago_make_addr3(chip, ring, all_serdes_addrs[index]), rx_term)) {
+    			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"Failed to set rx termination on SERDES %d\n", all_serdes_addrs[index]);
+			return -1;
+		}
+        }
+    
+        /* host TX attentuation toward Octeon RX*/
+        /*  -atten from 0..31, with 0.2 dB per step, (-post and -pre  (cursor) de-emphasis also available) */
+    
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"Setting attenuation toward Octeon...\n");
+
+	/* Write tx attenuation only */
+	data = 0x4000 | host_tx_atten;
+
+	for( index=0; index < SH_HOST_SERDES_NUM; index++ ) {
+		avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x15, data);
+	}
+     
+        /* turn on and configure the signal-presence detection (envelope detect, aka Electrical Idle): */
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"Configuring signal-presence detection...\n");
+        
+        /* MOD side set to most forgiving setting in case of small signals on high loss cables */
+        ei_threshold=1;
+	if (avago_serdes_initialize_signal_ok(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR), ei_threshold)) {
+    		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+				"Failed to set ei threshold on MOD SERDES\n");
+		return -1;
+	}
+    
+        /* HOST side set to a high level for noise rejection when Octeon is not sending traffic */
+        ei_threshold=11;
+        for( index=0; index < SH_HOST_SERDES_NUM; index++ )
+        {
+		if (avago_serdes_initialize_signal_ok(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), ei_threshold)) {
+    			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"Failed to set ei threshold on HOST SERDES %d\n", host_serdes_addrs[index]);
+			return -1;
+		}
+        }
+    
+        /* the threshold currently set can be read out at any time: 
+           avago_serdes_get_signal_ok_threshold(ah, avago_make_addr3(chip, ring, addr)); */
+        
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"Customizing serdes RX tuning...\n");
+        
+        /* for the host-side, fix CTLE settings for very-short-channel case: */
+        /* AES modify for HOST all fixed settings */
+        for( index=0; index < SH_HOST_SERDES_NUM; index++ ) 
+        {
+            /* CTLE and DCR */
+            /* low-frequency-regime (LF) gain, default 0x00, range 0x00..0x0f  */
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]),0x26,0x210f);
+        
+            /* high-frequency-regime (HF) gain, default 0x00, range 0x00..0x0f */
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]),0x26,0x2000);
+            
+            /* CTLE bandwidth (BW, freq. at which HF peaks), default 0x0d, range 0x00..0x0f */
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]),0x26,0x2300);
+        
+            /* tuning is much faster if fixing DC (value 0x48 based on emprical results): */
+            /* baseline wander correction coeff. (DC), default 0x38, range 0x00..0xff     */
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]),0x26,0x2248);
+
+            /* VOS 0x7f default, new values based on empirical results--implictly forms Tap 1 */
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x26, 0x107f);
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x26, 0x1181);
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x26, 0x1280);
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x26, 0x1380);
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x26, 0x147a);
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x26, 0x1583);
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x26, 0x167e);
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x26, 0x1783);
+            
+            /* Taps 2 - 4, new balues based on empricial results -- other taps auto-tune to 0 */
+            /* bit [15] = 1 if negative magnitude tap.  Global gain already default 0 so not included */
+            /* DFE taps 5-12 are set to 0 by auto-tune */
+
+            /* DFE Tap 2 */
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x26, 0xB104);
+            /* DFE Tap 3 */
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x26, 0xB202);
+            /* DFE Tap 4 */
+            avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0x26, 0x3302);
+        }
+
+        /* Configuring 10G repeater mode. Only 1 MOD and 1 HOST SERDES */
+    } else if (chip_mode == AVSP_REPEATER_DUPLEX) {
+        Avago_serdes_rx_term_t  rx_term = AVAGO_SERDES_RX_TERM_AGND;
+        static uint32_t  all_serdes_addrs[] = { SH_ALL_SERDES_ADDRS_10G };
+        int ei_threshold;
+
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Setting RX termination...\n");
+        /* (assumes serdes and supervisor firmware has been loaded and part has been stated via 0xfd int 0x24) */
+        /* configure RX-termination to GND for additional noise rejection */
+        for( index=0; index < SH_ALL_SERDES_NUM_10G; index++ )
+        {
+		if (avago_serdes_set_rx_term(ah, avago_make_addr3(chip, ring, all_serdes_addrs[index]), rx_term)) {
+    			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"Failed to set rx termination on SERDES %d\n", all_serdes_addrs[index]);
+			return -1;
+		}
+        }
+
+        /* host TX attentuation toward Octeon RX*/
+        /*  -atten from 0..31, with 0.2 dB per step, (-post and -pre  (cursor) de-emphasis also available) */
+    
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"Setting attenuation toward Octeon...\n");
+
+	/* Write tx attenuation only */
+	data = 0x4000 | host_tx_atten;
+
+        /* write combined result */
+	avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x15, data);
+
+        /* turn on and configure the signal-presence detection (envelope detect, aka Electrical Idle): */
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"Configuring signal-presence detection...\n");
+        
+        /* MOD side set to most forgiving setting in case of small signals on high loss cables */
+        ei_threshold=1;
+	if (avago_serdes_initialize_signal_ok(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR), ei_threshold)) {
+    		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+				"Failed to set ei threshold on MOD SERDES\n");
+		return -1;
+	}
+    
+        /* HOST side set to a high level for noise rejection when Octeon is not sending traffic */
+        ei_threshold=11;
+	if (avago_serdes_initialize_signal_ok(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), ei_threshold)) {
+    		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+				"Failed to set ei threshold on HOST SERDES\n");
+		return -1;
+	}
+
+        /* the threshold currently set can be read out at any time: 
+           avago_serdes_get_signal_ok_threshold(ah, avago_make_addr3(chip, ring, addr)); */
+        
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Customizing serdes RX tuning...\n");
+        
+        /* for the host-side, fix CTLE settings for very-short-channel case: */
+        /* AES modify for HOST all fixed settings */
+
+        /* CTLE and DCR */
+        /* low-frequency-regime (LF) gain, default 0x00, range 0x00..0x0f  */
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G),0x26,0x210f);
+        
+        /* high-frequency-regime (HF) gain, default 0x00, range 0x00..0x0f */
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G),0x26,0x2000);
+        
+        /* CTLE bandwidth (BW, freq. at which HF peaks), default 0x0d, range 0x00..0x0f */
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G),0x26,0x2300);
+        
+        /* tuning is much faster if fixing DC (value 0x48 based on emprical results): */
+        /* baseline wander correction coeff. (DC), default 0x38, range 0x00..0xff     */
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G),0x26,0x2248);
+        
+        /* VOS 0x7f default, new values based on empirical results--implictly forms Tap 1 */
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x26, 0x107f);
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x26, 0x1181);
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x26, 0x1280);
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x26, 0x1380);
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x26, 0x147a);
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x26, 0x1583);
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x26, 0x167e);
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x26, 0x1783);
+        
+        /* Taps 2 - 4, new balues based on empricial results -- other taps auto-tune to 0 */
+        /* bit [15] = 1 if negative magnitude tap.  Global gain already default 0 so not included */
+        /* DFE taps 5-12 are set to 0 by auto-tune */
+
+        /* DFE Tap 2 */
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x26, 0xB104);
+        /* DFE Tap 3 */
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x26, 0xB202);
+        /* DFE Tap 4 */
+        avago_spico_int(ah, avago_make_addr3(chip, ring, SH_HOST_SERDES_ADDR_10G), 0x26, 0x3302);
+
+        /* Print warning if Gearbox is configured in an Unknown state */
+    } else {
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"Unknown chip configuration 0x%u\n", chip_mode);
+        return -1; /*Error*/
+    }
+
+    /* Initialize temperature sensor */
+    avago_sensor_get_temperature(ah, sbus_addr, 0, frequency);
+    
+    /* avago_sensor_get_temperature() returns -1000000 on failure */
+    /* The temperature is in milli-degress Celsius */
+    mC = avago_sensor_get_temperature(ah, sbus_addr, 0, 0);
+    if( mC > -40000 ) /* non-failure */ {
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+       			"temp: %d.%d \n",mC/1000,(mC > 0 ? 1 : -1) * mC%1000/100);
+    }
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Finished customizing serdes RX tuning...\n");
+
+    return ret;
+} /* end avsp_5410_bootstrap */
+
+/**
+ ** @brief   Checks whether the AVSP-5410 gearbox MTIP core is linked up and stable
+ ** @details Checks various PCS status registers and verifies low error counts
+ ** @return  1 = up and stable, 0 = not up or stable
+ **/
+int avsp_5410_mtip_lnk_up_and_stable(
+    Aapl_t *ah,            /**< [in] Pointer to Aapl_t structure. */
+    enum avsp_mode chip_mode)   /**< [in] Gearbox chip mode (25G, 25G-RSFEC, 10G). */
+{
+
+#define MTIP_LNK_TIMEOUT_US 400000
+#define MTIP_LNK_DEBOUNCE_US 50000
+#define MTIP_LNK_INC_US 50000
+
+    int lnk_up = 0; /* Used to track if MTIP reports link is up. */
+    int lnk_debounce, i;
+    uint mtip_pcs_rcv_lnk;
+    uint mtip_pcs_hi_ber;
+    uint64_t mtip_pcs_ber_cnt = 0;
+    uint64_t mtip_pcs_errblk_cnt = 0;
+    uint val_hi=0;
+    uint val_lo=0;
+
+    /* When in repeater mode the cores are bypassed so we can't check MTIP PCS status */
+    if (chip_mode == AVSP_REPEATER_DUPLEX) {                
+        return 1;
+    }
+
+    /* Clear the Latched high BER bit and BER/ERR_BLK counters (clear on read) */
+    avsp5410_mtip_pcs_rd(ah, MTIP_PCS_BASER_STATUS2);
+
+    /* Clear the MTIP PCS STATUS 1 RCV_LNK bit (clear on read) */
+    avsp5410_mtip_pcs_rd(ah, MTIP_PCS_STATUS1_REG);
+
+    for (i = 0; i < MTIP_LNK_TIMEOUT_US; i = i + MTIP_LNK_INC_US) {
+        /* Checking for MTIP PCS STATUS 1 RCV_LNK(bit 2) = 1 (Link up) */
+        mtip_pcs_rcv_lnk = (avsp5410_mtip_pcs_rd(ah, MTIP_PCS_STATUS1_REG) >> 2) & 0x1;
+        /* Checking for a MTIP PCS HI-BER (bit 14) = 1 (high BER) */
+        mtip_pcs_hi_ber = (avsp5410_mtip_pcs_rd(ah, MTIP_PCS_BASER_STATUS2) >> 14) & 0x1;    
+
+        /* Only doing error count checking in 25G NON-FEC mode (not sure if these regs are accurate for FEC mode) */
+        if (lnk_up && chip_mode == AVSP_GEARBOX_4_1) {
+            /* Checking MTIP PCS BER counter */
+            /* STATUS2 Bits 13:8 map to bits 5:0 of BER counter */
+            val_lo = (avsp5410_mtip_pcs_rd(ah, MTIP_PCS_BASER_STATUS2) >> 8) & 0x3f;
+            /* BER HIGH ORDER bits 15:0 map to bits 21:6 of BER counter */
+            val_hi = avsp5410_mtip_pcs_rd(ah, MTIP_BER_HIGH_ORDER_CNT) & 0xffff;
+            mtip_pcs_ber_cnt += (val_hi << 6) + val_lo;
+
+            /* Checking MTIP PCS ERR_BLK counter */
+            /* STATUS2 Bits 7:0 map to bits 7:0 of ERR_BLK counter */                      
+            val_lo = avsp5410_mtip_pcs_rd(ah, MTIP_PCS_BASER_STATUS2) & 0xff;
+            /* ERRBLK HIGH ORDER bits 13:0 map to bits 21:8 of ERR_BLK counter */
+            val_hi = avsp5410_mtip_pcs_rd(ah, MTIP_ERRBLK_HIGH_ORDER_CNT) & 0x3fff;            
+            mtip_pcs_errblk_cnt += (val_hi << 8) + val_lo;
+        }
+
+        if (!mtip_pcs_hi_ber && mtip_pcs_rcv_lnk) {
+            if (lnk_up) {
+                if (i >= lnk_debounce) {
+                    /* Check error counters. Must be less than 2 (this error rate is much higher than 1E-12) */
+                    if (mtip_pcs_ber_cnt < 2 && mtip_pcs_errblk_cnt < 2) {   
+    			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+                        		"MTIP PCS stable.  Took=%d ms\n", i/1000);
+                        return 1;
+                    } else {
+                        /* Try again to see if we can get an error-free link */
+    			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+                        		"MTIP PCS errors detected, retrying. ber_cnt = %llu, errblk_cnt = %llu\n", mtip_pcs_ber_cnt, mtip_pcs_errblk_cnt);
+                        mtip_pcs_ber_cnt = 0;
+                        mtip_pcs_errblk_cnt = 0;
+                        lnk_debounce = i + MTIP_LNK_DEBOUNCE_US;
+                    }
+                } 
+            } else {
+                    lnk_debounce = i + MTIP_LNK_DEBOUNCE_US;
+                    lnk_up = 1;
+            }
+        }  else if (lnk_up) {
+            lnk_up = 0;
+            mtip_pcs_ber_cnt = 0;
+            mtip_pcs_errblk_cnt = 0;            
+        }
+       	udelay(MTIP_LNK_INC_US);
+    }
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Timeout! MTIP PCS is not stable.\n");
+    if (!mtip_pcs_rcv_lnk)
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "MTIP PCS RCV_LNK is not stable.\n");
+    if (mtip_pcs_hi_ber)
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "MTIP PCS reporting high BER.\n");
+    if (mtip_pcs_ber_cnt > 1 || mtip_pcs_errblk_cnt > 1) {  
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"MTIP PCS reporting errors. ber_cnt = %llu, errblk_cnt = %llu\n", mtip_pcs_ber_cnt, mtip_pcs_errblk_cnt);
+    }
+
+    return 0;
+}
+
+/**
+ ** @brief   DFE tuning for the HOST serdes 
+ ** @details Tunes, calibrates with error checking and retry
+ ** @return  On error, ah->return_code is set to negative value
+ ** @see     avago_serdes_dfe_wait_timeout();,sw_self_healing_vilify_port(); 
+ **/
+int sw_self_healing_host_dfe_tuning_cal(
+    Aapl_t *ah,       /**< [in] Pointer to Aapl_t structure. */
+    uint32_t chip,          /**< [in] Device chip number. */
+    uint32_t ring)          /**< [in] Device target ring number. */
+{
+    int ret;
+    uint32_t index;
+    int dfe_timeout; /* 3 second timeout */
+    uint32_t bad_host_first_time_dfe_tune;
+    int reset_gearbox;
+    int ddm;
+    static uint32_t host_serdes_addrs[] = { SH_HOST_SERDES_ADDRS };
+
+    ret = 0;
+    index = 0;
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Tuning receivers and aligning data path for HOST->MOD direction...\n");
+
+    /* perform the customized dfe tuning for the host interface */
+    for( index=0; index < SH_HOST_SERDES_NUM; index++ )
+    {
+        /* force the PLL to re-calibrate while preserving all other serdes settings, 
+           just in case the serdes was previously locked to garbage before this point */
+        /* need to read-write-modify to preserve any existing squelch from the other side of the gearbox */
+        bool tx_output_state=avago_serdes_get_tx_output_enable(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]));
+        /* following sequence will toggle RX_EN with function that safelt waits for RX to become ready again */ 
+        avago_serdes_set_tx_rx_enable(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]),
+                                      TRUE, FALSE, tx_output_state);
+        avago_serdes_set_tx_rx_enable(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]),
+                                      TRUE, TRUE, tx_output_state);
+         
+        /* perform the dfe tuning */
+             avago_spico_int(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), 0xa, 0x781); /* fixed CTLE DFE tune */
+    }
+    
+    /* wait for DFE tuning to complete */
+    dfe_timeout=3000; /* 3 second timeout */
+    bad_host_first_time_dfe_tune = 0;
+    reset_gearbox = 0;
+    ddm=0;
+    
+    /* ddm means DFE done mask.  Each of the rightmost 4 bits indicates DFE done/not done for its corresponding serdes */
+    ddm |= avago_serdes_dfe_wait_timeout(ah, avago_make_addr3(chip, ring, 0x6), dfe_timeout) << 0;
+    ddm |= avago_serdes_dfe_wait_timeout(ah, avago_make_addr3(chip, ring, 0x7), dfe_timeout) << 1;
+    ddm |= avago_serdes_dfe_wait_timeout(ah, avago_make_addr3(chip, ring, 0x8), dfe_timeout) << 2;
+    ddm |= avago_serdes_dfe_wait_timeout(ah, avago_make_addr3(chip, ring, 0x9), dfe_timeout) << 3;
+
+    while (ddm != 0xf) /* while at least one serdes has not finished DFE tuning */
+    {
+        bad_host_first_time_dfe_tune++;
+        /* track and vilify the port if the signal can not DFE tune in 3 attempts
+           this is a virgin power-up case where not able to tune is a fatal flaw.
+           Use first addr as proxy for others; This could be tracked/executed per serdes,
+           but retuning other serdes unecessarily is not really any harm */
+        if ( sw_self_healing_vilify_port(ah, avago_make_addr3(chip, ring, 0x6), &bad_host_first_time_dfe_tune, 3,
+                                     "can not complete DFE tuning on HOST serdes of chip %s at first power up\n",chip))
+        {
+            /* reset chip?  reset adapter? */
+            reset_gearbox = 1;
+            break;
+        }
+        /* else try again and drop out once full DFE tuning is acheived */
+        ddm=0;
+        ddm |= avago_serdes_dfe_wait_timeout(ah, avago_make_addr3(chip, ring, 0x6), dfe_timeout) << 0;
+        ddm |= avago_serdes_dfe_wait_timeout(ah, avago_make_addr3(chip, ring, 0x7), dfe_timeout) << 1;
+        ddm |= avago_serdes_dfe_wait_timeout(ah, avago_make_addr3(chip, ring, 0x8), dfe_timeout) << 2;
+        ddm |= avago_serdes_dfe_wait_timeout(ah, avago_make_addr3(chip, ring, 0x9), dfe_timeout) << 3;
+    }
+    
+    if (reset_gearbox)
+    {
+       /* system_routine_to_reset_gearbox(); */
+    }
+    else
+    {
+        /* healthcheck the results from the DFE tuning and procede on to phase calibration and unsquelch */
+        /* (DFE state/status successfully complete (0xf 0x80) is already checked by avago_serdes_dfe_wait_timeout) */
+        int redo_host_dfe_tuning = 0;
+        uint32_t bad_host_first_time_flock = 0;
+        int flm=0;
+
+        flm |= sw_self_healing_signal_ok_debounce(ah, avago_make_addr3(chip, ring, 0x6), 4, 5) << 0;
+        flm |= sw_self_healing_signal_ok_debounce(ah, avago_make_addr3(chip, ring, 0x7), 4, 5) << 1;
+        flm |= sw_self_healing_signal_ok_debounce(ah, avago_make_addr3(chip, ring, 0x8), 4, 5) << 2;
+        flm |= sw_self_healing_signal_ok_debounce(ah, avago_make_addr3(chip, ring, 0x9), 4, 5) << 3;
+        
+        /* check for frequency lock (EI may not be reliable on MOD side, so only check live flock) */
+        /* require a majority of the reads to show frequency lock, and then phase-calibrate and unsquelch if so */
+        while (flm != 0xf)
+        {
+            /* increment count of times debounce didn't return at least 4 of 5 flock in a row */
+            bad_host_first_time_flock++;
+    
+            /* track and vilify the port if the signal is not frequency locked in 5 debounces
+               this can simply redo tuning as an attempted recovery mechanism */
+            if ( sw_self_healing_vilify_port(ah, avago_make_addr3(chip, ring, 0x6), &bad_host_first_time_flock, 100,
+                  "after DFE tuning, there is no frequency lock on HOST serdes of chip %s at first power up\n",chip))
+            {
+                /* dfe tune again */
+                redo_host_dfe_tuning = 1;
+                break;
+            }
+            /* else try again and drop out once stable signal is acheived */
+            flm = 0;
+	    flm |= sw_self_healing_signal_ok_debounce(ah, avago_make_addr3(chip, ring, 0x6), 4, 5) << 0;
+	    flm |= sw_self_healing_signal_ok_debounce(ah, avago_make_addr3(chip, ring, 0x7), 4, 5) << 1;
+	    flm |= sw_self_healing_signal_ok_debounce(ah, avago_make_addr3(chip, ring, 0x8), 4, 5) << 2;
+	    flm |= sw_self_healing_signal_ok_debounce(ah, avago_make_addr3(chip, ring, 0x9), 4, 5) << 3;
+    	    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+	    		"%s: Failed to detect signal on Host SERDES, retrying, retry count = %d.\n", bad_host_first_time_flock);
+        }
+        if (redo_host_dfe_tuning)
+        {
+            /* call this function from the beginning */
+            sw_self_healing_host_dfe_tuning_cal(ah, chip, ring); 
+        }
+        /* check quick eye metric -- 50mVppd is the minimum eye height. */
+        /* this is a one-time quick snapshot at time of DFE tuning--debouncing is N/A */
+        /* this can simply redo tuning as an attempted recovery mechanism */
+        for( index=0; index < SH_HOST_SERDES_NUM; index++ )
+        {
+            int metric = avago_serdes_eye_get_simple_metric(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]));
+    	    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+            		"SBus %-3s Simple eye metric = %u\n",
+			avago_addr_to_string(avago_make_addr3(chip, ring, host_serdes_addrs[index])), metric);
+            if ( metric < 50 )
+            {
+    		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+                		"after DFE tuning, there is no frequency lock on HOST serdes of chip %d at first power up\n", chip);
+                redo_host_dfe_tuning = 1;
+            }
+         }
+         /* in FEC mode, you can also test very strictly: block lock, FEC lock, etc */
+         /* [in FEC mode, also reset the FEC dataflow as appropriate] */
+      
+         /* waiting for clean data before completing phase cal */
+         mdelay(1000);
+
+         /* align/calibrate the phase of the clock transfering data from the core to the serdes TX accelerator */
+         avago_spico_int(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR ),0xb,0x1);
+      
+         /* unsquelch TX */
+         avago_serdes_set_tx_rx_enable(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR), TRUE, TRUE, TRUE);
+    
+    } /* end else DFE tuning completed successfully */
+    return ret;
+} /* end sw_self_healing_host_dfe_tuning_cal */
+
+/**
+ ** @brief   DFE tuning for the MOD serdes
+ ** @details Tunes, calibrates with error checking and retry
+ ** @return  On error, ah->return_code is set to negative value
+ ** @see     avago_serdes_dfe_wait_timeout();,sw_self_healing_vilify_port();
+ **/
+int sw_self_healing_mod_dfe_tuning_cal(
+    Aapl_t *ah,             /**< [in] Pointer to Aapl_t structure. */ 
+    enum avsp_mode chip_mode,  /**< [in] Device chip mode. */
+    uint32_t chip,          /**< [in] Device chip number. */
+    uint32_t ring)          /**< [in] Device target ring number. */
+{
+    int rc;
+    int signal_present;
+    uint32_t bad_mod_ei_chk;
+    bool tx_output_state;
+    int dfe_timeout = 4000; /* 4 second timeout */
+    uint32_t bad_mod_first_time_flock = 0;
+    uint32_t host_serdes_addrs[] = { SH_HOST_SERDES_ADDRS };
+    uint32_t host_serdes_num;
+    uint32_t index = 0, metric;
+    uint32_t sbus_addr = 0xa;
+
+    bad_mod_ei_chk = 0;
+
+    /* check for signal present and debounce */
+    /* require a majority of the reads to show signal present and launch DFE tuning if so */
+    signal_present = sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR), 4, 5);
+    if(signal_present)
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "MOD signal present...\n");
+
+    while (!signal_present)
+    {
+        /* increment count of times debounce didn't return at least 4 of 5 signal-not-idle in a row */
+        bad_mod_ei_chk++;
+    
+        /* track and vilify the port if the signal is never found in 100 debounces. */
+        if ( sw_self_healing_vilify_port(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR), 
+                                         &bad_mod_ei_chk, 100,
+                                      "no stable signal is present on MOD serdes\n"))
+        {
+            /* Signal couldn't be detected */
+    	    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "No signal detected on MOD SERDES.\n");
+	    return 2;
+        }
+        /* else try again and drop out once stable signal is acheived */
+        signal_present = sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR), 4, 5);
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"MOD signal not present, retrying, retry count=%d\n", bad_mod_ei_chk);
+    }
+
+
+    /* perform the DFE tuning */
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Tuning receiver and aligning data path for MOD->HOST direction...\n");
+
+    /* force the PLL to re-calibrate while preserving all other serdes settings,
+       just in case the serdes was previously locked to garbage before this point */
+    /* need to read-write-modify to preserve any existing squelch from the other side of the gearbox */
+    tx_output_state=avago_serdes_get_tx_output_enable(ah, avago_make_addr3(chip, ring,SH_MOD_SERDES_ADDR ));
+    /* following sequence will toggle RX_EN with function that safely waits for RX to become ready again */
+    if(avago_serdes_set_tx_rx_enable(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR),
+                                     TRUE, FALSE, tx_output_state)) {
+        avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Failed MOD SERDES Rx disable.\n");
+        return 3;
+    }
+         
+    if (avago_serdes_set_tx_rx_enable(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR),
+                                      TRUE, TRUE, tx_output_state)) {
+        avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Failed MOD SERDES Rx enable.\n");
+        return 3;
+    }
+
+    /* execute an unrestricted DFE tune */
+    avago_spico_int(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR), 0xa, 0x1); 
+
+    rc = avago_serdes_dfe_wait_timeout(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR), dfe_timeout);
+    if (rc == 0) {
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"DFE tuning timed out on mod serdes.\n");
+	return 1;
+    } else if (rc == -1) {
+        avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        	"DFE tuning didn't run because there's no signal on mod.\n");
+        return 2;
+    }
+
+    if (ah->return_code != 0) {ah->return_code = 0;}
+
+    /* healthcheck the results from the DFE tuning and procede on to phase calibration and unsquelch */
+    /* (DFE state/status successfully complete (0xf 0x80) is already checked by avago_serdes_dfe_wait_timeout) */
+    bad_mod_first_time_flock = 0;
+
+    /* check for frequency lock (EI may not be reliable on MOD side, so only check live flock) */
+    /* require a majority of the reads to show frequency lock, and then phase-calibrate and unsquelch if so */
+    while ( !sw_self_healing_flock_debounce(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR), 4, 5) )
+    {
+        /* increment count of times debounce didn't return at least 4 of 5 flock in a row */
+        bad_mod_first_time_flock++;
+
+        /* track and vilify the port if the signal is not frequency locked in 5 debounces
+           this can simply redo tuning as an attempted recovery mechanism */
+        if ( sw_self_healing_vilify_port(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR),
+                                         &bad_mod_first_time_flock, 100,
+             "after DFE tuning, there is no frequency lock on MOD serdes of chip %s at first power up\n",chip))
+        {
+             /* dfe tune again */
+            return 3;
+        }
+        /* else try again and drop out once stable signal is acheived */
+    }
+    /* check quick eye metric -- 50mVppd is the minimum eye height. */
+    /* this is a one-time quick snapshot at time of DFE tuning--debouncing is N/A */
+    /* this can simply redo tuning as an attempted recovery mechanism */
+    metric = avago_serdes_eye_get_simple_metric(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR));
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"SBus %-3s Simple eye metric = %u\n",
+          	avago_addr_to_string(avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR)), metric);
+
+    /* Completing the following checks to see if something went wrong with DFE tuning */
+    /* Checking if eye height is at the extremes */
+    if ( metric < 50 || metric >= 990 )
+    {
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"after DFE tuning, the eye height indicated a bad dfe tune on chip %d.  Redoing DFE tuning.\n", chip);
+        return 3;
+    }
+
+    /* 25G Mode = All 4 Host SERDES used, 10G Mode = Only first Host SERDES used */
+    host_serdes_num = (chip_mode == AVSP_REPEATER_DUPLEX) ? SH_HOST_SERDES_NUM_10G : SH_HOST_SERDES_NUM ;      
+
+    /* Checking if MTIP PCS is linked and error free */
+    if (!avsp_5410_mtip_lnk_up_and_stable(ah, chip_mode)) {
+	return 3;
+    }
+        
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Performing Tx Phase Cal on host slices.\n");
+        
+    for( index=0; index < host_serdes_num; index++ )
+    {
+	/* align/calibrate the phase of the clock transfering data from the core to the serdes TX accelerator */
+	if (!avago_spico_int_check(ah, __func__, __LINE__, avago_make_addr3(chip, ring, host_serdes_addrs[index]),0xb,0x1)) {
+    	   avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Host-side phase cal error\n");
+	   return 3;
+	}
+    }
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"PCS reset for deskew.\n");
+
+    /* Core reset sequence from self-healing firmware */
+    sbus_addr = 0xa;
+    avago_sbus_wr(ah, sbus_addr, 0, 7);  /* Assert PCS LANE0 Reset */
+    avago_sbus_wr(ah, sbus_addr, 0, 0);
+
+    /* Checking if MTIP PCS is linked and error free */
+    if (!avsp_5410_mtip_lnk_up_and_stable(ah, chip_mode)) {
+        return 3;
+    }
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Enabling Host SERDES transmitters.\n");
+
+    for( index=0; index < host_serdes_num; index++ ) {         
+        /* unsquelch TX */
+        if (avago_serdes_set_tx_rx_enable(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), TRUE, TRUE, TRUE)) {
+            avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Failed to enable Host SERDES %d.\n", host_serdes_addrs[index]);
+            return 3;
+        }
+    }        
+
+    return 0;
+} /* end sw_self_healing_mod_dfe_tuning_cal() */
+
+/**
+ ** @brief   Virgin/first-time/forced self-healing of HOST->MOD direction
+ ** @details Checks for signal, tunes, calibrates with error checking and retry
+ ** @return  On error, ah->return_code is set to negative value
+ ** @see     sw_self_healing_ei_debounce(),sw_self_healing_signal_ok_debounce()
+ **/
+int sw_self_healing_force_heal_host(
+    Aapl_t *ah,       /**< [in] Pointer to Aapl_t structure. */
+    uint32_t chip,          /**< [in] Device chip number. */
+    uint32_t ring)          /**< [in] Device target ring number. */
+{
+    int ret = 0;
+    uint32_t bad_host_first_time_boot = 0;
+    int reset_gearbox = 0;
+    int sm=0;
+
+    /* HOST->MOD */
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Virgin healing: HOST->MOD direction...\n");
+    
+    /* start with squelching the MOD serdes until we know the inbound HOST path is clean */
+    avago_serdes_set_tx_rx_enable(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR), TRUE, TRUE, FALSE);
+
+    /* check for signal present and debounce -- treat all four as a bank, as all need to work for full pipe */
+    /* require a majority of the reads to show signal present and launch DFE tuning if so */
+
+    /* sm means signal mask.  Each of the 4 rightmost bits indicates presence/absence of a signal of a serdes */
+    sm |= sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, 0x6), 4, 5) << 0;
+    sm |= sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, 0x7), 4, 5) << 1;
+    sm |= sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, 0x8), 4, 5) << 2;
+    sm |= sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, 0x9), 4, 5) << 3;
+
+    while (sm != 0xf) /* while at least one serdes has no signal */
+    {
+        /* increment count of times debounce didn't return at least 4 of 5 signal-not-idle in a row */
+        bad_host_first_time_boot++;
+
+        /* track and vilify the port if the signal is never found in 100 debounces.
+           this is a virgin power-up case where no signal ever coming is a fatal flaw
+           the run-time version instead has infinite tolerance. Use first addr as proxy for others */
+        if ( sw_self_healing_vilify_port(ah, avago_make_addr3(chip, ring, 0x6), &bad_host_first_time_boot, 100,
+                                     "no stable signal is present on HOST serdes of chip %s at first power up\n",chip))
+        {
+            /* reset chip?  reset adapter? */
+            reset_gearbox = 1;
+            break;
+        }
+        /* else try again and drop out once stable signal is acheived */
+        sm = 0;
+        sm |= sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, 0x6), 4, 5) << 0;
+        sm |= sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, 0x7), 4, 5) << 1;
+        sm |= sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, 0x8), 4, 5) << 2;
+        sm |= sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, 0x9), 4, 5) << 3;
+    }
+    if (reset_gearbox)
+    {
+       /* system_routine_to_reset_gearbox(); */
+    }
+
+    /* perform the DFE tuning and datapath calibration/alignment */
+    sw_self_healing_host_dfe_tuning_cal(ah, chip, ring);
+
+    return ret;
+} /* end sw_self_healing_force_heal_host */
+
+/**
+ ** @brief   Virgin/first-time/forced self-healing of MOD->HOST direction
+ ** @details Checks for signal, tunes, calibrates with error checking and retry
+ ** @return  On error, ah->return_code is set to negative value
+ ** @see     sw_self_healing_ei_debounce(),sw_self_healing_signal_ok_debounce()
+ **/
+int sw_self_healing_force_heal_mod(
+    Aapl_t *ah,             /**< [in] Pointer to Aapl_t structure. */
+    enum avsp_mode chip_mode,  /**< [in] Device chip mode. */
+    uint32_t chip,          /**< [in] Device chip number. */
+    uint32_t ring)          /**< [in] Device target ring number. */
+{
+    int ret = 0;
+    uint32_t index=0;
+    uint32_t host_serdes_num;
+    uint32_t host_serdes_addrs[] = { SH_HOST_SERDES_ADDRS };
+
+    /* MOD->HOST */
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Virgin healing: MOD->HOST direction...\n");
+
+    /* start with squelching the HOST serdes until we know the inbound MOD path is clean */
+
+    host_serdes_num = (chip_mode == AVSP_REPEATER_DUPLEX) ? SH_HOST_SERDES_NUM_10G : SH_HOST_SERDES_NUM ;      
+
+    /* 25G Mode = All 4 Host SERDES used, 10G Mode = Only first Host SERDES used */
+
+    for( index=0; index < host_serdes_num; index++ )
+    {
+        if (avago_serdes_set_tx_rx_enable(ah, avago_make_addr3(chip, ring, host_serdes_addrs[index]), TRUE, TRUE, FALSE)) {
+            avago_log_printf(ah, AVAGO_DEBUG1, __func__,__LINE__, "Failed to disable Host SERDES %d.\n", host_serdes_addrs[index]);
+            return 3;
+        }
+    } 
+
+    /* perform the DFE tuning and datapath calibration/alignment */
+    ret = sw_self_healing_mod_dfe_tuning_cal(ah, chip_mode, chip, ring);
+
+    return ret;
+} /* end sw_self_healing_force_heal_mod() */
+
+#define INT_0X24_TIMEOUT_US 1000000
+#define INT_0X24_INC_US 50000
+
+/**
+ * @brief   Completes a AVSP-5410 int0x24 reset and waits for it to complete
+ * @return  Returns 0 on success, 1 on failure and -1 on error.
+ * @see     myInt0x24()
+ */
+int __int0x24(
+    Aapl_t *ah,           /**< [in] Pointer to Aapl_t structure. */
+    enum avsp_mode chip_mode,  /**< [in] Device chip mode. */
+    uint chip,              /**< [in] Device chip number. */
+    uint ring)              /**< [in] Device target ring number. */
+{
+    int rc, i;
+
+    if (chip_mode == AVSP_REPEATER_DUPLEX) {
+        rc = avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd), 0x24, 0x0040);
+    } else if ( chip_mode == AVSP_GEARBOX_4_1 ){
+        rc = avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd), 0x24, 0x80a0);            
+    } else if ( chip_mode == AVSP_RS_FEC ){
+        rc = avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd), 0x24, 0x40a0);                
+    } else {
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        	"Unknown chip configuration 0x%u\n", chip_mode);
+        return -1; /*Error*/
+    }
+    
+    for (i = 0; i < INT_0X24_TIMEOUT_US; i += INT_0X24_INC_US) {
+        rc = avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd), 0x26, 0x3400);
+        if (rc & 0x200)
+            break;
+	udelay(INT_0X24_INC_US);
+    }
+
+    return ((i >= INT_0X24_TIMEOUT_US) ? 1 : 0);
+}
+
+/**
+ * @brief   Completes a AVSP-5410 int0x24 reset and squelches SERDES transmitters.
+ * @return  Returns 0 on success, 1 on failure.
+ * @see     __int0x24()
+ */
+int myInt0x24(
+    Aapl_t *ah,             /**< [in] Pointer to Aapl_t structure. */
+    enum avsp_mode chip_mode,  /**< [in] Device chip mode. */
+    uint chip,              /**< [in] Device chip number. */
+    uint ring)              /**< [in] Device target ring number. */
+{
+    int index;
+    static uint  all_serdes_addrs[] = { SH_ALL_SERDES_ADDRS };
+#define INT0X24_DEBOUNCE_US 50000
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Completing Int 0x24 reset\n");
+
+    if (__int0x24(ah, chip_mode, chip, ring) == 0) {
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Squelching all the SERDES transmitters\n");
+	udelay(INT0X24_DEBOUNCE_US);
+	for( index=0; index < SH_ALL_SERDES_NUM; index++ ) {
+		if (avago_serdes_set_tx_rx_enable(ah, avago_make_addr3(chip, ring, all_serdes_addrs[index]), TRUE, TRUE, FALSE)) {
+    			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"Failed to disable SERDES %d transmitter.\n", all_serdes_addrs[index]);
+			return 1;
+		}
+	}
+
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Int 0x24 succeeded\n");
+	return 0;
+    }
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Int 0x24 reset completion timed out\n");
+    return 1;
+}
+
+#define HOST_FREQ_CHK_MAX 2
+#define HOST_ALGN_CHK_MAX 3
+#define HOST_ALGN_DEBOUNCE_US 10000
+
+/**
+ * @brief   Checks for HOST freq lock and completes MOD Tx phase calibration
+ * @details Should only be used if the fixed HOST SERDES settings are used
+ * @return  Returns 0 on success
+ */
+int sw_self_healing_host_freq_lock_cal(
+    Aapl_t *ah,         /**< [in] Pointer to Aapl_t structure. */
+    enum avsp_mode chip_mode,  /**< [in] Device chip mode. */
+    uint chip,          /**< [in] Device chip number. */
+    uint ring)          /**< [in] Device target ring number. */
+{
+    int i, j;
+    uint32_t flm;
+    uint32_t host_serdes_addrs[] = { SH_HOST_SERDES_ADDRS };
+    uint32_t host_serdes_num;
+    uint32_t mask;
+
+    /* start with squelching the MOD serdes until we know the inbound HOST path is clean */
+    if (avago_serdes_set_tx_output_enable(ah, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR), 0)) {
+        avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Failed to disable MOD SERDES.\n");
+        return 1;
+    }
+
+    /* 25G Mode = All 4 Host SERDES used, 10G Mode = Only first Host SERDES used */
+    host_serdes_num = (chip_mode == AVSP_REPEATER_DUPLEX) ? SH_HOST_SERDES_NUM_10G : SH_HOST_SERDES_NUM ; 
+    /* Creating mask based on number of host serdes */
+    mask = (1 << host_serdes_num) - 1;
+
+    for (i = 0; i < HOST_FREQ_CHK_MAX; i++) {
+        flm = 0;
+        for (j = 0; j < host_serdes_num; j++)
+        {
+            flm |= sw_self_healing_signal_ok_debounce(ah, avago_make_addr3(chip, ring, host_serdes_addrs[j]), 4, 5) << j;
+        }
+
+        if (flm == mask) {
+            /* Yes, we have host-side frequency lock */
+    	    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+	    		"Yes, we have host-side frequency lock, num_inter=%d\n", i);
+            break;
+        }
+    }
+
+    if (flm != mask)
+    {    
+       avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+       		"No, we didn't get host-side frequency lock\n");
+       return 1;
+    }
+
+    if (chip_mode != AVSP_REPEATER_DUPLEX) {
+        /* Check for Host side SERDES alignment */
+        for (i = 0; i < HOST_ALGN_CHK_MAX; i++) {
+            if (avago_sbus_rd(ah, 0xa, 0xb1) & 0x10000) {
+    		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+                		"Host side data is aligned.  i=%d\n", i);
+                break;
+            } else {
+    		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+                		"Host side data is NOT aligned.  i=%d\n", i);
+            }
+            udelay(HOST_ALGN_DEBOUNCE_US);
+        }
+
+        if (i >= HOST_ALGN_CHK_MAX) {
+    	    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+            		"Unable to get Host side data aligned, resetting.\n");
+            return 2;
+        }
+    }     
+
+    /* Wait for data to be clean before executing phase calibration */
+    /* DO WE NEED TO DO THIS SLEEP?  WE HAVE ALREADY CONFIRMED HOST ALIGNMENT */
+    udelay(1000);
+
+    avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+    		"Performing Tx Phase Cal on mod slice.\n");
+
+    /* align/calibrate the phase of the clock transfering data from the core to the serdes TX accelerator */
+    if (!avago_spico_int_check(ah, __func__, __LINE__, avago_make_addr3(chip, ring, SH_MOD_SERDES_ADDR ),0xb,0x1)) {
+        avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+        		"Module-side phase cal error\n");
+	return 3;
+    }
+
+    return 0;
+}
+ 
+/**
+ ** @brief              Completes a pCAL DFE tune and waits for completion
+ ** @param ah         Pointer to Aapl_t structure.
+ ** @param chip         Device chip number.
+ ** @param ring         Device target ring number.
+ ** @param sbus_addr    Device address number.
+ ** @param ms_timeout   Maximum milliseconds to wait for dfe to complete.
+ ** @return 0 = success, 1 = pCAL tune timed out, -1 = signal lost            
+ **/
+int avago_serdes_pcal_tune(Aapl_t *ah, int chip, int ring, int sbus_addr, int ms_timeout)
+{
+    int i;
+    uint32_t addr = avago_make_addr3(chip, ring, sbus_addr);
+
+    /* execute a pCAL DFE tune */
+    avago_spico_int(ah, addr, 0xa, 0x2); 
+
+    /*  avago_serdes_dfe_wait_timeout() returns
+        @return  Returns 1 if dfe has stopped.
+        @return  Returns 0 if dfe is still running (timeout).
+        @return  Returns -1 and decrements ah->return_code if dfe won't run because of no signal. 
+        wait specified in milliseconds */
+    i = avago_serdes_dfe_wait_timeout(ah, addr, ms_timeout);
+
+    if (i == 0) {
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "pCAL DFE tune timed out\n");
+	return 1;
+    } else if (i == -1) {
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"pCAL DFE tune didn't run because there's no signal detected.\n");
+        return -1;
+    } else {
+    	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "pCAL DFE tune completed successfully.\n");
+        return 0; 
+    }
+}
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_avsp_5410_sw_sh.h OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_avsp_5410_sw_sh.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_avsp_5410_sw_sh.h	1969-12-31 16:00:00.000000000 -0800
+++ OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_avsp_5410_sw_sh.h	2018-06-28 15:08:31.071008783 -0700
@@ -0,0 +1,58 @@
+/* AAPL CORE Revision: 2.3.1-beta */
+
+/* Copyright 2014-2015 Avago Technologies. All rights reserved.
+ *
+ * This file is part of the AAPL CORE library.
+ *
+ * AAPL CORE is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * AAPL CORE is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with AAPL CORE.  If not, see http://www.gnu.org/licenses.
+ */
+
+/** Doxygen File Header
+ ** @file avago_avsp_5410_sw_sh.c
+ ** @brief Declarations for software-based self-healing on the AVSP-5410/5820 ASSPs
+ **/
+
+bool sw_self_healing_ei_debounce(struct avago_hdl *ah, uint32_t addr, uint32_t threshold, uint32_t cycles);  
+	
+bool sw_self_healing_flock_debounce(struct avago_hdl *ah, uint32_t addr, uint32_t threshold, uint32_t cycles); 
+
+bool sw_self_healing_signal_ok_debounce(struct avago_hdl *ah, uint32_t addr, uint32_t threshold, uint32_t cycles); 
+
+bool sw_self_healing_vilify_port(struct avago_hdl *ah, uint32_t addr, uint32_t *count, uint32_t limit, const char *fmt, ...); 
+
+int avsp_5410_bootstrap(struct avago_hdl *ah, enum avsp_mode chip_mode, uint32_t chip, uint32_t ring, uint32_t host_tx_atten);
+
+int sw_self_healing_host_dfe_tuning_cal(struct avago_hdl *ah, uint32_t chip, uint32_t ring);
+
+int sw_self_healing_mod_dfe_tuning_cal(struct avago_hdl *ah, enum avsp_mode chip_mode, uint32_t chip, uint32_t ring);
+
+int sw_self_healing_force_heal_host(struct avago_hdl *ah, uint32_t chip, uint32_t ring);  
+
+int sw_self_healing_force_heal_mod(struct avago_hdl *ah, enum avsp_mode chip_mode, uint32_t chip, uint32_t ring);
+
+int __int0x24(struct avago_hdl *ah, enum avsp_mode chip_mode, uint32_t chip, uint32_t ring);
+
+int myInt0x24(struct avago_hdl *ah, enum avsp_mode chip_mode, uint32_t chip, uint32_t ring);
+
+int sw_self_healing_host_freq_lock_cal(struct avago_hdl *ah, enum avsp_mode chip_mode, uint32_t chip, uint32_t ring);
+
+uint32_t avsp5410_mtip_pcs_wr(struct avago_hdl *ah, uint32_t reg, uint32_t data);
+
+uint32_t avsp5410_mtip_pcs_rd(struct avago_hdl *ah, uint32_t reg);
+
+uint32_t avsp5410_mtip_rsfec_wr(struct avago_hdl *ah, uint32_t reg, uint32_t data);
+
+uint32_t avsp5410_mtip_rsfec_rd(struct avago_hdl *ah, uint32_t reg);
+
+int avago_serdes_pcal_tune(struct avago_hdl *ah, int chip, int ring, int sbus_addr, int ms_timeout);
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_sbus_master_041f_0704_heal.h OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_sbus_master_041f_0704_heal.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_sbus_master_041f_0704_heal.h	1969-12-31 16:00:00.000000000 -0800
+++ OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_sbus_master_041f_0704_heal.h	2018-06-28 15:08:31.073008785 -0700
@@ -0,0 +1,1088 @@
+static const uint32_t avago_sbus_master_041f_0704_heal_rom[] = {
+	0xc0604883, 0xc12ba400, 0xc0128844, 0xdc691c80, 0xe4707e47, 0xc2e91c20,
+	0xe470be47, 0xc4091c3f, 0xe4710a47, 0xc3d91c43, 0xe470b4c0, 0xc3291c31,
+	0xe4762c81, 0xc3a92039, 0xc3491d81, 0xe090da48, 0xe480ce47, 0xc34c1435,
+	0xe480de47, 0xe4764038, 0xc3c9203b, 0xc0c7ffd4, 0xc0c403d5, 0xc0cbffd4,
+	0xc183fbc7, 0xc44064c2, 0xd5200242, 0xc1bd1c1b, 0xd8721430, 0xfc70fa47,
+	0xc8010500, 0xfc46ea47, 0xfd4043fc, 0xf4703a2f, 0xe4702033, 0xd8920408,
+	0xc44b1e27, 0xc45b1e20, 0xc46b1e20, 0xc47b1e20, 0xc48b1e20, 0xc49b1e20,
+	0xc4ab1e20, 0xc4bb1e20, 0xda716fa7, 0xec7237a5, 0xc4d3004c, 0xc02aa044,
+	0xc44138c0, 0xcdf010b2, 0xc090002c, 0xc090b322, 0xc2dd1c05, 0xfdff502c,
+	0xc2cc1c0e, 0xe2907f84, 0xcb2ec220, 0xf9066687, 0xc4010400, 0xd3b08045,
+	0xd7208000, 0xd8408000, 0xe8e08000, 0xfe508000, 0xd1208000, 0xd1208000,
+	0xde608000, 0xd7808011, 0xcb508003, 0xcf708003, 0xce908003, 0xd8008003,
+	0xcca08003, 0xd0108003, 0xcf008003, 0xd1208003, 0xf3008000, 0xfc908002,
+	0xe1f08002, 0xe0d08002, 0xdf20800c, 0xe6b0800c, 0xe9b0800c, 0xea10800c,
+	0xe130800c, 0xe570800c, 0xe650800c, 0xff00800c, 0xff008009, 0xe5c08009,
+	0xd1208007, 0xd4f11000, 0xf6215000, 0xc010003d, 0xc3dd90b7, 0xccd00401,
+	0xc0140d40, 0xd6e11005, 0xc2ec1c02, 0xc0065844, 0xc2e50455, 0xf020c307,
+	0xf6d02c2e, 0xf270b8c0, 0xf600002d, 0xc0053c44, 0xc0ef7fd4, 0xc0a02607,
+	0xc551384f, 0xc14803d5, 0xc54d5800, 0xc55fe000, 0xc10d9081, 0xc0d00401,
+	0xc0204764, 0xfc402409, 0xfd4043fe, 0xc8003bbf, 0xc10d9101, 0xc0a00402,
+	0xc0104764, 0xfc401801, 0xd11043fd, 0xc26d1c45, 0xc27d1c18, 0xc28d1c19,
+	0xc29d1c1b, 0xe311101c, 0xc0028400, 0xc26d1f17, 0xc27d1c18, 0xe4211019,
+	0xc1bd1c00, 0xc1cd1c28, 0xc0028829, 0xdc811305, 0xc1bd8800, 0xc1600400,
+	0xc0106f62, 0xf6204c01, 0xc010081b, 0xc1bd880d, 0xc1300403, 0xc0406f62,
+	0xc4e04c01, 0xc3dd9045, 0xc0500402, 0xc0291444, 0xf48fdc00, 0xc000681b,
+	0xc1bd23f2, 0xfed0001a, 0xc1891d01, 0xc193ffd7, 0xfc71d000, 0xf6405100,
+	0xc0940004, 0xeb81100f, 0xc42b1c02, 0xc0302444, 0xc4401401, 0xc5500c7e,
+	0xcbf0f4c1, 0xc00ac000, 0xffff1eb5, 0xcb621c28, 0xc44398c1, 0xf47003fe,
+	0xec70a5bc, 0xce6c882a, 0xfc203009, 0xc096f016, 0xc283040c, 0xe91000a7,
+	0xc280cf47, 0xf47fe800, 0xc000a034, 0xc09447f5, 0xf97117ff, 0xf9562413,
+	0xc4041448, 0xc4214503, 0xc0c006a7, 0xc51a0040, 0xc50405a7, 0xe8010a25,
+	0xc45a1c45, 0xc0801764, 0xf47ff409, 0xf470281b, 0xfc702c1c, 0xc2003041,
+	0xf640026f, 0xc0902005, 0xd00f57fd, 0xc42f1c0c, 0xe6f1100c, 0xc05d9000,
+	0xffd00410, 0xf8401707, 0xc0498807, 0xf4702409, 0xf4706c02, 0xc4507003,
+	0xc0901a62, 0xc20507ef, 0xcc006cc0, 0xf471141c, 0xdc703419, 0xc18d140d,
+	0xe00f540d, 0xc05d900c, 0xffd00408, 0xc0c7ffd4, 0xc05d9045, 0xffd02408,
+	0xc0c103c7, 0xc009bc20, 0xc32d1c54, 0xc31c1c31, 0xc00af444, 0xf070c541,
+	0xc31c0830, 0xcc00100b, 0xc01a9c31, 0xc31d1c0a, 0xc31d1c32, 0xc0b001c5,
+	0xf020cb07, 0xfe202431, 0xdc5fffc7, 0xefff5055, 0xc2028c0e, 0xc4400099,
+	0xf62001c8, 0xc010041b, 0xc1bd8809, 0xc0400416, 0xccf02c00, 0xe4211019,
+	0xc1bc1c00, 0xca001003, 0xc35c1045, 0xee26f227, 0xd0600403, 0xc0100ae2,
+	0xc01b8846, 0xe2735801, 0xee40f401, 0xc1002401, 0xc0900ae4, 0xc04b9019,
+	0xee40a409, 0xc2902408, 0xc410ac00, 0xfb569ca2, 0xfdc1103a, 0xfa410c02,
+	0xfe1003fe, 0xc18c9c41, 0xeb811041, 0xc1e91c02, 0xc18b1c43, 0xc02c9844,
+	0xffde9043, 0xfa4f3400, 0xfc9003fb, 0xc00fdfa4, 0xc45287c5, 0xcffe9227,
+	0xc1fe1197, 0xe6205001, 0xc2d00401, 0xc0100a62, 0xc039882e, 0xe620b001,
+	0xc2a00404, 0xcc2f9800, 0xc1b30019, 0xc1c0cf47, 0xc1c153c5, 0xc008c444,
+	0xcd1064c7, 0xc1c3001b, 0xc008c444, 0xc4406cc2, 0xc0000231, 0xfca113c9,
+	0xfc400011, 0xc00f0800, 0xc18c1fc0, 0xd01a0040, 0xcc206247, 0xc1c30019,
+	0xc1b083c7, 0xc008c444, 0xc4406cc0, 0xfc700231, 0xc4406c20, 0xcc000231,
+	0xe311101b, 0xe4710800, 0xc1930418, 0xcc106cc0, 0xc1c7301c, 0xc008c444,
+	0xfc7064c2, 0xf4507068, 0xcc107033, 0xe311101b, 0xc1933c00, 0xc0090844,
+	0xc0306f07, 0xc1930bf9, 0xc1c1a3c7, 0xc1c0cf45, 0xc4406cc0, 0xc0000231,
+	0xdaa2ff6c, 0xd9a892a8, 0xc0100f84, 0xc019880c, 0xe6205c01, 0xc1500402,
+	0xcc505400, 0xc1b91c19, 0xfb569ca2, 0xc1cb1c3a, 0xc008c444, 0xc00d2800,
+	0xf4600348, 0xc00d1000, 0xf0715342, 0xf84645bb, 0xc091107f, 0xe0a60003,
+	0xe0a82a0a, 0xca76e647, 0xc12ffc44, 0xc2029055, 0xd8600099, 0xca760685,
+	0xc04c91ab, 0xf6415685, 0xc0900810, 0xc11d9026, 0xc2902401, 0xc446e647,
+	0xfc404c0d, 0xc4f6eaff, 0xf641544e, 0xc01401ba, 0xdbac9ffa, 0xf6401fa4,
+	0xc01101ba, 0xf02a1c07, 0xfec024e6, 0xc11d9045, 0xc0500401, 0xc10ff7c4,
+	0xc0013854, 0xcead1fcc, 0xcebc9c18, 0xc443b307, 0xd0000bef, 0xf0701401,
+	0xf071141b, 0xce9544e9, 0xc0b03d10, 0xc02fd044, 0xff500500, 0xc4506f07,
+	0xf4711480, 0xf47060ed, 0xc44064ee, 0xf0700242, 0xf471141b, 0xf47060ef,
+	0xf47064f0, 0xf47070f2, 0xc4406cf1, 0xc4500231, 0xf0562490, 0xcec91cf4,
+	0xf473acd8, 0xc443a8f3, 0xcc00043c, 0xceb368ec, 0xcea3cf47, 0xc010f044,
+	0xcec30045, 0xf0562490, 0xceb91cf6, 0xcea3d747, 0xc010f044, 0xd0330045,
+	0xcc03ecc0, 0xcff300fe, 0xcc0400c0, 0xd0430101, 0xfc73f0c1, 0xc453f440,
+	0xf9562481, 0xc23c13ff, 0xf074be47, 0xf8466c23, 0xd2e91c0f, 0xc090bfc7,
+	0xc094b940, 0xd2f500f1, 0xcc101809, 0xd8400009, 0xc014bf62, 0xf4701c09,
+	0xc00024fb, 0xd2fd897a, 0xc0702402, 0xc093fb47, 0xf625c000, 0xc0900d2f,
+	0xcfdd1c07, 0xd6600009, 0xc044bf62, 0xf4701c09, 0xc00024fc, 0xd2fd895c,
+	0xc0702405, 0xc093ff47, 0xf6254800, 0xc090192f, 0xd00c1c09, 0xc0991d94,
+	0xf6251800, 0xc0901d2f, 0xd01d1c07, 0xd3c00009, 0xc074bf62, 0xf4701c09,
+	0xc0002502, 0xd2fd8932, 0xc0702408, 0xc0941347, 0xf624a000, 0xc090412f,
+	0xcf7d1c07, 0xd1e00009, 0xc114bf62, 0xf4701c09, 0xc00024f8, 0xd2fd8914,
+	0xc0702412, 0xc093e747, 0xf6242800, 0xc0904d2f, 0xcfad1c07, 0xd0000009,
+	0xc204bf62, 0xf4701c09, 0xc0002503, 0xd2fd88f6, 0xc0702421, 0xc0941b47,
+	0xf623b000, 0xc090892f, 0xd07d1c07, 0xce200009, 0xc234bf62, 0xf4701c09,
+	0xc000250c, 0xd2fd88d8, 0xc0702424, 0xc0943747, 0xf6233800, 0xc090992f,
+	0xd05d1c07, 0xcc400009, 0xc274bf62, 0xf4701c09, 0xc000250a, 0xd2fd88ba,
+	0xc0702428, 0xc0942f47, 0xf622c000, 0xc063fd2f, 0xf0427c0c, 0xd0ee412f,
+	0xc09b1c4c, 0xcc028400, 0xc9d00009, 0xc0b4bb62, 0xf6203001, 0xc010292e,
+	0xd2ed8807, 0xc1b0240c, 0xf0462481, 0xc070052f, 0xd890fb97, 0xf474be45,
+	0xf474092f, 0xcc140d2e, 0xd0c30106, 0xc00434c0, 0xd0330075, 0xc014bb62,
+	0xf0703809, 0xcffe112f, 0xcc13ee47, 0xd0030107, 0xf6218800, 0xc090092e,
+	0xd8920412, 0xc014bf04, 0xc3ee5c07, 0xd2f91589, 0xcfe4bf47, 0xf6213400,
+	0xc0900d2e, 0xd2fd1c07, 0xc43000fd, 0xc044bb62, 0xf6204409, 0xc060012f,
+	0xd2fd880c, 0xc0703c20, 0xcfc4bf47, 0xf620bc00, 0xc090152e, 0xd8920412,
+	0xc014bf04, 0xc3ee5c07, 0xd2f91589, 0xcff4bf47, 0xf6206800, 0xc090192e,
+	0xd2fc1c09, 0xd0091d84, 0xf6203800, 0xc0901d2e, 0xd2fd1c07, 0xc0400101,
+	0xc45024c0, 0xf4742cc0, 0xcc04290b, 0xcf7c1cf7, 0xc2d00914, 0xf2762492,
+	0xe8569cf7, 0xfc73b247, 0xf473ad26, 0xc443a8fb, 0xe400043c, 0xd892490a,
+	0xd243df27, 0xe47a15a7, 0xd26f1cec, 0xcfbd1ceb, 0xc3c110ea, 0xd0b90001,
+	0xc003dd41, 0xd0a507d2, 0xc0042b62, 0xd4101006, 0xd0ad290a, 0xd0ad290a,
+	0xd0b5050a, 0xc0042f62, 0xd4101006, 0xd0bd290b, 0xd0bd290b, 0xf071150b,
+	0xd0dc9d0c, 0xc0aa0924, 0xcee34483, 0xced3fbc7, 0xc0117844, 0xcf791d81,
+	0xf0243707, 0xc72008f7, 0xf0243307, 0xc6c028f7, 0xd133df07, 0xf9007f84,
+	0xec71310e, 0xcf7c1cf1, 0xc1fe1114, 0xc4c43b90, 0xcd33cac7, 0xcfef1cf0,
+	0xc6a110ef, 0xcf7c1c01, 0xc1fe1111, 0xc4c43b90, 0xf073c6c7, 0xf84448f7,
+	0xd0ee401f, 0xcf2b1c4c, 0xfc73c0d6, 0xc443bcfe, 0xf070046a, 0xd0cc08f7,
+	0xf0706402, 0xf84450f7, 0xd0ee401f, 0xc9f1044c, 0xf903df04, 0xc421310e,
+	0xc0602682, 0xc003dd41, 0xffcf13e5, 0xcf7c1cf7, 0xcf191d91, 0xcd23c8c0,
+	0xcfef1cf0, 0xc6a110ef, 0xcf7d1c01, 0xd0dc1d0d, 0xc0a3f702, 0xc4020406,
+	0xc8001000, 0xc4510840, 0xd890fb97, 0xc0142704, 0xffff1c07, 0xc3500108,
+	0xc833e0c0, 0xfffe5589, 0xf0239cc0, 0xd09d0d08, 0xc1b008e7, 0xf9562487,
+	0xce7303ff, 0xf4342302, 0xc0239d09, 0xd09d380c, 0xd08d3109, 0xcf850508,
+	0xd41fac00, 0xd8920cf8, 0xe44fff95, 0xcf8c1d08, 0xd089158b, 0xd01d9045,
+	0xc1b00410, 0xd890b397, 0xfb56a4a3, 0xd30c93ff, 0xcec91e85, 0xceb097c7,
+	0xcea3ef47, 0xc010f044, 0xc0042247, 0xc7fe1cd7, 0xe474c302, 0xd01c1d30,
+	0xd1200f84, 0xfc729c02, 0xcc03a4ff, 0xd01c1cf7, 0xd1100f84, 0xfc701409,
+	0xc883dc20, 0xd03e5589, 0xe473df05, 0xceb30cec, 0xcea3ef47, 0xc010f044,
+	0xf004c307, 0xcf891d0a, 0xc003e362, 0xcc00180f, 0xc0a000f8, 0xcff3e362,
+	0xfc701406, 0xf973e0ff, 0xf0562430, 0xcec91cf8, 0xceb097c7, 0xcea3ef47,
+	0xc010f044, 0xfc742247, 0xfc73b100, 0xf473ac25, 0xc443a8fb, 0xe470043c,
+	0xd8922909, 0xf0540f95, 0xcec91cf7, 0xf473acc3, 0xc443a8fb, 0xf070043c,
+	0xd0bc0130, 0xf623e247, 0xc0f000f8, 0xcf830006, 0xf6202800, 0xc063fcf8,
+	0xcfff1c05, 0xc30e5cf8, 0xcf8c1589, 0xfc73b247, 0xf473ac25, 0xc443a8fb,
+	0xe070043c, 0xe4039cc0, 0xce7d0508, 0xd00f1d09, 0xc25f1cec, 0xcfbd1ceb,
+	0xc3c110ea, 0xd0990001, 0xf9708800, 0xf0562430, 0xcec91d30, 0xceb097c7,
+	0xcea3ef47, 0xc010f044, 0xfc742247, 0xfc73b100, 0xf473ac25, 0xc443a8fb,
+	0xe470043c, 0xf4411109, 0xfd711401, 0xfc73b200, 0xf473ac25, 0xc443a8fb,
+	0xe470043c, 0xf4011505, 0xf074c504, 0xd31c0905, 0xc8101806, 0xc1100040,
+	0xf0241707, 0xc0703d31, 0xc40fff87, 0xc8001000, 0xc4010840, 0xcf891c42,
+	0xf0241707, 0xc1900531, 0xd053e340, 0xf2762488, 0xcffe9105, 0xcec91e85,
+	0xceb097c7, 0xcea3ef47, 0xc010f044, 0xc45f9400, 0xf0d43307, 0xcfec80fc,
+	0xc444c6c7, 0xf4700887, 0xc444c102, 0xc4500784, 0xcec0d3c7, 0xf473accf,
+	0xc443a8fb, 0xf470043c, 0xd403e500, 0xc30004f9, 0xd00c0880, 0xc444c647,
+	0xcc000887, 0xf8411130, 0xd08d1c01, 0xd00d1d0e, 0xc8711131, 0xd3030002,
+	0xc01e1044, 0xf0242307, 0xc070090e, 0xd043e740, 0xf4201400, 0xf4e410f9,
+	0xc003e4f9, 0xffff1fd0, 0xd04d1d0f, 0xffef1d10, 0xcfad88fa, 0xc4503802,
+	0xf023eb07, 0xd3191d00, 0xc0221c44, 0xc444c0c0, 0xf4700784, 0xf0743908,
+	0xd00c00fa, 0xc444c647, 0xcc000887, 0xf8411130, 0xd08c1c01, 0xc0243b02,
+	0xd08d0807, 0xc080010e, 0xf0242307, 0xd0e91d0e, 0xf0243b07, 0xc0b0090f,
+	0xd0f43b47, 0xf0041307, 0xd1091cfa, 0xc003e941, 0xd10c1fba, 0xe473ff00,
+	0xf0711504, 0xcfdc090c, 0xd4020402, 0xc4800506, 0xcc0418c0, 0xcf2300f1,
+	0xfc73c0d2, 0xc443bcfe, 0xd400046a, 0xc1400507, 0xf0741cc0, 0xc03e1101,
+	0xc0500912, 0xc0195c44, 0xc021e044, 0xc0235844, 0xc0c40f62, 0xc9401809,
+	0xc0500040, 0xc400d387, 0xcec91c42, 0xf473accf, 0xc443a8fb, 0xf620043c,
+	0xc0902d03, 0xd02d1c08, 0xc8711131, 0xd0cc1c02, 0xfa043727, 0xc02a0820,
+	0xd03d883d, 0xc070040b, 0xc0c40f62, 0xf0703c09, 0xcfcc350c, 0xec73fb20,
+	0xf8411130, 0xc0a00001, 0xc0a40f62, 0xc4401409, 0xf07008c4, 0xd0c5050c,
+	0xf9007f84, 0xd08c9d0e, 0xc110004d, 0xc0343364, 0xf0703001, 0xd0c5050c,
+	0xf9007f84, 0xc4d2810e, 0xc01ab444, 0xc0400510, 0xc4540cc0, 0xc4e08f47,
+	0xc0113b64, 0xc1257021, 0xc0288c44, 0xc20024c0, 0xc200495c, 0xcb304966,
+	0xc0026420, 0xc0e043d5, 0xd872cb87, 0xe4720385, 0xd8723817, 0xe4739b85,
+	0xc1530016, 0xc14007c5, 0xc14013c5, 0xc14ffbc4, 0xc1400bc5, 0xc0efbfd4,
+	0xc18c1c45, 0xc444d3a7, 0xec700a8c, 0xf2413144, 0xc2000544, 0xd26edc40,
+	0xc4461c8b, 0xc0900bef, 0xc22f1c05, 0xf641081b, 0xc090881b, 0xf4813027,
+	0xf2451144, 0xd5113544, 0xc1c00133, 0xfa44cb27, 0xd33c88ff, 0xc400500f,
+	0xc44210aa, 0xc4200bef, 0xc0a06f62, 0xc4c02009, 0xc4d51325, 0xc454cd41,
+	0xc403ff84, 0xc4288193, 0xc4103f84, 0xc03444a1, 0xc00aa405, 0xc4510bfc,
+	0xd44340a0, 0xd514044d, 0xffc02544, 0xd3230045, 0xf874ccc0, 0xe9e11134,
+	0xe1811002, 0xd0114400, 0xf0711451, 0xc060043f, 0xc0006247, 0xe872801f,
+	0xc0072044, 0xc1206f62, 0xf6204801, 0xc090441b, 0xc18d1c05, 0xf0748440,
+	0xc0ba0830, 0xc45283eb, 0xc3f06347, 0xfc7064c0, 0xfc506c70, 0xc4406c01,
+	0xfd400231, 0xc4406ffe, 0xf0700231, 0xe141103e, 0xc02f1400, 0xe311101b,
+	0xc3ec1c00, 0xe1411194, 0xc1930400, 0xc0090844, 0xcc006f27, 0xc01f1419,
+	0xe311101b, 0xe00ed400, 0xc1eb1c45, 0xc44a1ca0, 0xc0100d48, 0xc4410407,
+	0xc4300b26, 0xc30c1d21, 0xff102e82, 0xc3bedc45, 0xc0007b07, 0xc20244b2,
+	0xc5404ab3, 0xc0971327, 0xeb811009, 0xc8000402, 0xc4403400, 0xf6200d40,
+	0xc090481b, 0xedd11076, 0xc42b1c02, 0xc0302444, 0xc6b00687, 0xf27076c7,
+	0xcffe9040, 0xcc9062c7, 0xd1f1101a, 0xc4b11003, 0xc35c9003, 0xc87068c0,
+	0xc6ce1587, 0xc1502e82, 0xc87068c1, 0xcbce1587, 0xc0c02e82, 0xc88068c2,
+	0xe8223187, 0xcc30100b, 0xe872801a, 0xc0352044, 0xc4104001, 0xd8b06b07,
+	0xf8510b05, 0xf3bedce0, 0xc02f7044, 0xf0748443, 0xc0ba0830, 0xc3ec1fe8,
+	0xc0085044, 0xc44a1ca0, 0xc0100d48, 0xf071040b, 0xc3bedc1d, 0xc02f7044,
+	0xf0748443, 0xc0ba0830, 0xc08307ed, 0xc0700081, 0xfc7fff87, 0xc55020ff,
+	0xcde080b1, 0xc23d1c03, 0xc2024843, 0xc5404ab6, 0xc0302444, 0xc4401401,
+	0xf8700c7e, 0xcfff1fff, 0xcb115408, 0xc0337820, 0xff411040, 0xc0c00402,
+	0xc1931442, 0xe47072c7, 0xe310801b, 0xc8010800, 0xfdc11045, 0xffb00402,
+	0xcffe9c41, 0xd31064c6, 0xc4403001, 0xf0a00242, 0xff80081c, 0xc0300081,
+	0xc4510c80, 0xf8410307, 0xc17024ff, 0xc44a1ca0, 0xf62001c8, 0xc010441b,
+	0xf074840a, 0xc0ba0830, 0xc45283f3, 0xc4006347, 0xf27068c0, 0xd0b11040,
+	0xc34c9003, 0xe27fc809, 0xc0911045, 0xc4a0a403, 0xcc120c03, 0xffe110e6,
+	0xdbcc1c00, 0xc216ee42, 0xd8200c49, 0xe856b8a1, 0xc4581845, 0xec707247,
+	0xc01a001b, 0xc1930fcf, 0xc008c444, 0xcc1064c0, 0xe311101b, 0xc1b30800,
+	0xc008c444, 0xc1907b47, 0xc19107d0, 0xc4410707, 0xc4400214, 0xf2700242,
+	0xff602c1b, 0xcc1064c0, 0xe311101b, 0xc45a1c00, 0xca007ac7, 0xd4811287,
+	0xc0700403, 0xc9311041, 0xd2110c03, 0xe820c307, 0xc45fc40b, 0xca16289f,
+	0xc1ec91aa, 0xf0501801, 0xc050001e, 0xc1ec1208, 0xc0b10f00, 0xc0020005,
+	0xfe89c808, 0xf970100b, 0xc33c17e8, 0xc004efb7, 0xdc3c9f29, 0xc44068c0,
+	0xca900d0b, 0xe470cf05, 0xc35d1007, 0xf7ff5007, 0xc990800e, 0xdc4c9c00,
+	0xc44068c0, 0xf2400d0b, 0xc0802434, 0xc4071347, 0xc030c444, 0xc08304ad,
+	0xf4502647, 0xf4402033, 0xc2002035, 0xf2700099, 0xc55151c3, 0xfcf000ab,
+	0xc5471327, 0xc002bc55, 0xdc3c9fe7, 0xc44068c9, 0xcaa00d0b, 0xf27ef800,
+	0xc1a325c4, 0xc0342c44, 0xfd3000ae, 0xc0350044, 0xc1106f62, 0xc4402809,
+	0xc4400d1f, 0xc5500c4b, 0xc34c1c45, 0xc80ff000, 0xc08b89bb, 0xca10340b,
+	0xf40078c0, 0xc010781a, 0xc006a014, 0xc1ac8011, 0xec707ac7, 0xd512841a,
+	0xc0600c1a, 0xc0082ea9, 0xc54117fa, 0xcffe1287, 0xdc808111, 0xdc811000,
+	0xc1bd8800, 0xc0700416, 0xc0106f62, 0xfd708c09, 0xc44064fe, 0xf8700242,
+	0xf8561cbb, 0xc1bc0831, 0xf8705001, 0xf8561cb9, 0xc1bc0831, 0xf8702c01,
+	0xf8561cb6, 0xc1bc0831, 0xc8000c09, 0xdc3c9c45, 0xc0362044, 0xf3f000a8,
+	0xc4471327, 0xcac00d88, 0xc44d5800, 0xf6200d40, 0xc0902c1b, 0xc1c3038d,
+	0xfa46ec41, 0xc4700407, 0xc2f00531, 0xc1700531, 0xfffe9c83, 0xc038f844,
+	0xc4428084, 0xc8200e3e, 0xc038f844, 0xe3e11081, 0xc3e00003, 0xfffe9c82,
+	0xc038f844, 0xc4428084, 0xc8300e3e, 0xc038f844, 0xe3e11081, 0xc2900003,
+	0xfffe9c81, 0xc038f844, 0xc4428084, 0xc8300e3e, 0xc038f844, 0xe3e11082,
+	0xc1400003, 0xfffe9c81, 0xc038f844, 0xe3e11084, 0xc4420c03, 0xc8200e3e,
+	0xc038f844, 0xcc0064c6, 0xe311101b, 0xc1931400, 0xfa73ff87, 0xc4cc8bff,
+	0xec713703, 0xc1c91c1b, 0xc008c444, 0xcc1064c0, 0xe311101b, 0xfffe5c00,
+	0xc0085044, 0xc0090844, 0xc1b007c4, 0xcc6fd409, 0xe4211019, 0xc1bc1c00,
+	0xc03a9c43, 0xc1a30016, 0xc4c11397, 0xc0b06f22, 0xc4b9c80b, 0xd0101c01,
+	0xc0006941, 0xc1ac1ff4, 0xc550cf05, 0xc1991c45, 0xc2006ec7, 0xc2000231,
+	0xc20027e4, 0xc2002801, 0xc2002816, 0xc20028ee, 0xc200290c, 0xc2002942,
+	0xc2002984, 0xc20029a4, 0xc2002a18, 0xc2002a35, 0xc2002a62, 0xc2002b36,
+	0xc2002b4b, 0xc2002b6e, 0xc20013fd, 0xc2004547, 0xc2002b9b, 0xc2002c16,
+	0xc2002c3a, 0xc2002c5e, 0xc2002c6b, 0xc2002c8d, 0xc2003936, 0xc2002cd5,
+	0xc2002d6a, 0xc2002b6b, 0xc2002dc7, 0xc20028a9, 0xc20043cc, 0xc200449a,
+	0xc20044ae, 0xc2004174, 0xc2002165, 0xc2002a27, 0xc2001d2c, 0xc2002b6b,
+	0xc2002d6a, 0xc20022f0, 0xc2002301, 0xc2001495, 0xc2002b6b, 0xc2002b6b,
+	0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b,
+	0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b,
+	0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b,
+	0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc200320d, 0xc20031f2,
+	0xc200326b, 0xc200329b, 0xc20032a1, 0xc2003213, 0xc2003257, 0xc2003265,
+	0xc2001efc, 0xc2001e03, 0xc2001e5c, 0xc2002398, 0xc200241a, 0xc2002586,
+	0xc20019c8, 0xc2002312, 0xc2002312, 0xc2002391, 0xc2002f57, 0xc200318e,
+	0xc2002f47, 0xc20013d8, 0xc2004564, 0xc2004536, 0xc2002b6b, 0xc200110c,
+	0xc20031b1, 0xc2004144, 0xc2004154, 0xc2004164, 0xc20020db, 0xc2002123,
+	0xc2001d2b, 0xc2001d2f, 0xc2001d2e, 0xc200229d, 0xc2002b6b, 0xc2002b6b,
+	0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b,
+	0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xc2002b6b, 0xcd402b6b,
+	0xcd4350d4, 0xccd338cf, 0xcca32ccc, 0xc0502402, 0xc0102001, 0xc0600407,
+	0xc0101401, 0xc0901004, 0xc0601c08, 0xc0101401, 0xc0500404, 0xc0802405,
+	0xc0501807, 0xc0702009, 0xc0401406, 0xc0300c03, 0xc0300c03, 0xc2c01000,
+	0xc2c01000, 0xc0000409, 0xc0800400, 0xc0000002, 0xc0401c02, 0xc0400000,
+	0xc0002006, 0xc0502000, 0xc0000010, 0xc2001010, 0xc2000000, 0xc3d00001,
+	0xc3d00001, 0xc0000409, 0xc0800400, 0xc0000002, 0xc0401c02, 0xc0400000,
+	0xc0002006, 0xc0502000, 0xc0000010, 0xc2001010, 0xc2000000, 0xc1b03830,
+	0xc1b03830, 0xc0000409, 0xc0800400, 0xc0000002, 0xc0401c02, 0xc0400000,
+	0xc0002006, 0xc0502000, 0xc0000010, 0xc2001010, 0xc2000000, 0xc2e00030,
+	0xc2600030, 0xc0000409, 0xc0800400, 0xc0000002, 0xc0401c02, 0xc0400000,
+	0xc0002006, 0xc0502000, 0xc0000010, 0xc2001010, 0xc2000000, 0xc0802009,
+	0xc0601c09, 0xc0501c06, 0xc0501004, 0xc2709825, 0xc1003c28, 0xc1004010,
+	0xc0f02c10, 0xc0e0380e, 0xc080200e, 0xc1004010, 0xc1405010, 0xc1304411,
+	0xc1203c12, 0xc0c0300c, 0xc100400c, 0xc183e7c7, 0xcc060cc0, 0xd8130182,
+	0xc0cae044, 0xcc0654c0, 0xffdf116a, 0xd543008f, 0xc45528c0, 0xc1251b47,
+	0xcc07ff87, 0xc0b44413, 0xcc0117fd, 0xc9830096, 0xcc05a8c0, 0xd5c30197,
+	0xc4459cc0, 0xc4402e4d, 0xc4402eab, 0xc4402f1c, 0xc44046a3, 0xcc10108f,
+	0xc8e30092, 0xcc023cc0, 0xc9130090, 0xccf24cc0, 0xc8b30c8c, 0xfc7228c7,
+	0xcc123429, 0xd4637c94, 0xfd4519c9, 0xfc503bf8, 0xc4403807, 0xfd4010a7,
+	0xc4403bfc, 0xfd4010a7, 0xc4503bfc, 0xc4004b07, 0xdc9048df, 0xe13f5412,
+	0xe4720412, 0xe4710813, 0xf0711412, 0xcdf10012, 0xc1272412, 0xc1284fd5,
+	0xc1391c80, 0xc1291c42, 0xc9430045, 0xc0f23362, 0xc4500c01, 0xc2823762,
+	0xcc101409, 0xf6211494, 0xc090b88d, 0xc9430805, 0xc8dd8845, 0xc050243e,
+	0xc45250c3, 0xc94d8845, 0xc0f00401, 0xc0225362, 0xfc501c01, 0xc0024100,
+	0xc40f1405, 0xf0711490, 0xd9189db7, 0xdb200f84, 0xe85033a4, 0xc4423247,
+	0xc200111d, 0xc4504b12, 0xc8d6df47, 0xc8d0ffc4, 0xc0447444, 0xc12c4820,
+	0xc9c14845, 0xc9d14901, 0xd01275c7, 0xc9db1451, 0xc9e14901, 0xc9f14901,
+	0xd0127dc7, 0xc9fb1451, 0xf62150c0, 0xc0f01454, 0xc5450406, 0xc45fe400,
+	0xd8901397, 0xc4405f95, 0xcce01171, 0xc5330052, 0xc09db844, 0xc1831445,
+	0xcc05fcc0, 0xc70f1d80, 0xc30f1d7e, 0xea71117d, 0xc183100c, 0xc0906362,
+	0xcc004c0e, 0xd803017f, 0xd7e1c3c7, 0xd7d0c3c7, 0xc0ca9c44, 0xc0006141,
+	0xc1832bec, 0xcc060cc0, 0xcfef1d82, 0xeb811181, 0xd8333c0c, 0xfc7608c0,
+	0xc44604f9, 0xcc0032b8, 0xd8230183, 0xd813e7c7, 0xc0cae044, 0xdc960cc2,
+	0xe05f5583, 0xd8230183, 0xd81267c7, 0xc0cae044, 0xccf060cb, 0xd8230183,
+	0xc44604c4, 0xccc032b8, 0xd8333c18, 0xcc4608c0, 0xeb811181, 0xc183280c,
+	0xcc060cc3, 0xc97f1d82, 0xeb811181, 0xd8331c0c, 0xcc0608c0, 0xeb811181,
+	0xd8331c0c, 0xfc7608c0, 0xc4460420, 0xcc7032b8, 0xd8230183, 0xd81103c7,
+	0xc0cae044, 0xcc060cc7, 0xc60f1d82, 0xeb811181, 0xc24f5c0c, 0xd8372583,
+	0xd83183d5, 0xfc7608c9, 0xc4460496, 0xccb032b8, 0xce8f1c18, 0xd8230183,
+	0xc44604c5, 0xcc0032b8, 0xd8230183, 0xc44604c4, 0xccc032b8, 0xce8f1c18,
+	0xd8230183, 0xc44604c5, 0xcc0032b8, 0xd8230183, 0xc44604c4, 0xcca032b8,
+	0xd8330018, 0xfc7608c0, 0xc4460497, 0xccb032b8, 0xc18d8818, 0xc590380c,
+	0xd83083d7, 0xfd560dc9, 0xcc060c02, 0xd8132982, 0xc0cae044, 0xdc960cd3,
+	0xffff5583, 0xd8230183, 0xc44604cc, 0xcc2032b8, 0xd8230183, 0xc44604c6,
+	0xcc0032b8, 0xd8230183, 0xc44604c6, 0xcc7032b8, 0xd8230183, 0xc44604ca,
+	0xcc4032b8, 0xd8230183, 0xc44604cc, 0xcc2032b8, 0xd8230183, 0xc44604c6,
+	0xcc0032b8, 0xd8230183, 0xc44604c6, 0xd41032b8, 0xfa600018, 0xcc5060ca,
+	0xd8230183, 0xc44604c0, 0xcc5032b8, 0xd8230183, 0xd81083c7, 0xc0cae044,
+	0xcc060cc5, 0xc40f1d82, 0xeb811181, 0xd833140c, 0xfc7608c0, 0xc4460460,
+	0xcc3032b8, 0xd8230183, 0xd8125fc7, 0xc0cae044, 0xcc060cc1, 0xd8130182,
+	0xc0cae044, 0xcc060cc1, 0xc20f1d82, 0xeb811181, 0xd833040c, 0xfc7608c0,
+	0xc4460440, 0xcc1032b8, 0xd8230183, 0xd81183c7, 0xc0cae044, 0xcc0060cb,
+	0xd8230183, 0xc44604c4, 0xccc032b8, 0xd8330018, 0xcc4608c0, 0xeb811181,
+	0xfc71140c, 0xfc70602c, 0xcc006496, 0xca0f1c1c, 0xe311101b, 0xc03e5c00,
+	0xfc3e5589, 0xc8a03fc4, 0xc5122b00, 0xc180b3c7, 0xf47064ca, 0xfc40708b,
+	0xf4707003, 0xdc106c1c, 0xc1cd141b, 0xc1b70c1b, 0xcc006ec5, 0xe311101c,
+	0xc03e5c00, 0xff3e5589, 0xc045c444, 0xd8900f97, 0xd01ef795, 0xc5222b00,
+	0xc2df1c18, 0xc5e33c5d, 0xc0adb844, 0xc5d0c3c7, 0xc44178c0, 0xf9702b6e,
+	0xf9562403, 0xf2742fbd, 0xc03e908b, 0xc1814a80, 0xc5d0bbc7, 0xc44178c1,
+	0xfc702b6e, 0xccf1742f, 0xf6e1105e, 0xc523380a, 0xc09db844, 0xc96d9045,
+	0xc0202480, 0xc96d9045, 0xc0202480, 0xc0125362, 0xc4401c09, 0xc00011a4,
+	0xc94d8814, 0xc0702402, 0xc04d6044, 0xf6202800, 0xc0900c94, 0xf5811005,
+	0xc90d1c04, 0xcc01145f, 0xc2df1c5c, 0xf871105d, 0xc13d1c0a, 0xc2ef1c58,
+	0xf871105d, 0xc13d1c0a, 0xc2ff1c59, 0xf871105d, 0xc13d1c0a, 0xc30f1c5a,
+	0xf871105d, 0xc13d1c0a, 0xc2cf1c5b, 0xc1c30018, 0xc1b27747, 0xf62064d4,
+	0xc0600058, 0xc58d9010, 0xc0500401, 0xc008c444, 0xd42161d0, 0xfef00019,
+	0xc190a3c7, 0xc1b27f47, 0xc0016762, 0xf6404006, 0xc0100459, 0xe3111005,
+	0xc5974000, 0xc0006542, 0xc19357ef, 0xc1b27347, 0xc0016b62, 0xf6404006,
+	0xc010045a, 0xe3111005, 0xc5a74000, 0xc0006542, 0xc29f1fef, 0xc9ed1c19,
+	0xc5bd881b, 0xc1001800, 0xc0116f64, 0xc4401401, 0xdd000231, 0xc195085b,
+	0xc45fbc00, 0xc5e5af47, 0xc5d5b347, 0xc09db844, 0xc5e34045, 0xcd85fcc1,
+	0xd7e34180, 0xfd55f9c9, 0xcd85fa11, 0xea71117d, 0xc442e80c, 0xf6400bef,
+	0xc010201b, 0xc01f1405, 0xd7f3045e, 0xcd0600d8, 0xd7e7257e, 0xd7e183d5,
+	0xc445f4d8, 0xcba032a7, 0xc02fbc44, 0xc0806f64, 0xfc501401, 0xcc417802,
+	0xf6e1105d, 0xccd1140a, 0xd6c30052, 0xc445acc0, 0xcc10148b, 0xd6b3296c,
+	0xc0522c44, 0xcc05b0c2, 0xc8b1116b, 0xd6c30c05, 0xc445acca, 0xcc50148b,
+	0xd6b3016c, 0xc0522c44, 0xcc05b0c6, 0xc8b1116b, 0xd6c31c05, 0xc445acc0,
+	0xcc80148b, 0xd6b3056c, 0xc0522c44, 0xcc35b0c9, 0xc8b1116b, 0xd6c32805,
+	0xc445acc0, 0xccb0148b, 0xc38f1d6c, 0xc8b1116b, 0xd6c33005, 0xc445acc0,
+	0xccd0148b, 0xd6b33d6c, 0xc0522c44, 0xcc05b0ce, 0xc8b1116b, 0xd6c33c05,
+	0xc445acc0, 0xcd00148b, 0xc40f1d6c, 0xc8b1116b, 0xd6c34405, 0xc445acc0,
+	0xcd20148b, 0xd6b3016c, 0xc0522c44, 0xcc05b0d3, 0xc8b1116b, 0xd6c35005,
+	0xc445acc0, 0xcd50148b, 0xd6b3016c, 0xc0522c44, 0xcc05b0d6, 0xc8b1116b,
+	0xd6c35c05, 0xc445acc0, 0xcd80148b, 0xd6b3016c, 0xc0522c44, 0xcc05b0d9,
+	0xc8b1116b, 0xd6c36805, 0xc445acc0, 0xcdb0148b, 0xc41f1d6c, 0xc8b1116b,
+	0xd6c37005, 0xc445acc0, 0xcdd0148b, 0xc41f1d6c, 0xc8b1116b, 0xd6c37805,
+	0xc445acc0, 0xcdf0148b, 0xc41f1d6c, 0xc8b1116b, 0xc20f1c05, 0xd6b3016c,
+	0xc0522c44, 0xd6c087c7, 0xd6b107c7, 0xc0522c44, 0xd6c08bc7, 0xc445acc0,
+	0xfc70148b, 0xcc05b023, 0xc8b1116b, 0xc24f1c05, 0xd6b33d6c, 0xc0522c44,
+	0xd6c097c7, 0xc445acc0, 0xfc70148b, 0xcc05b026, 0xc8b1116b, 0xc27f1c05,
+	0xd6b3216c, 0xc0522c44, 0xd6c0a3c7, 0xc445acc7, 0xfc70148b, 0xcd15b029,
+	0xc8b1116b, 0xc2af1c05, 0xd6b3016c, 0xc0522c44, 0xd6c0afc7, 0xc445acd0,
+	0xfc70148b, 0xcc05b02c, 0xc8b1116b, 0xc2df1c05, 0xd6b3016c, 0xc0522c44,
+	0xd6c0bbc7, 0xc445acc0, 0xfc70148b, 0xcc05b02f, 0xc8b1116b, 0xc30f1c05,
+	0xd6b3016c, 0xc0522c44, 0xd6c0c7c7, 0xc445acc0, 0xfc70148b, 0xcc05b034,
+	0xc8b1116b, 0xc35f1c05, 0xd6b3016c, 0xc0522c44, 0xd6c0cbc7, 0xc445acc0,
+	0xc450148b, 0xc5d0afc7, 0xf62558c0, 0xc0f01556, 0xc04e1c1e, 0xc77e5589,
+	0xc5155b00, 0xf8717ac7, 0xf9562403, 0xf00407bd, 0xec714556, 0xf6e11018,
+	0xd565040a, 0xc45f8400, 0xc5d0afc7, 0xf62558c0, 0xc0f01556, 0xc04e1c1e,
+	0xc7de5589, 0xc5155b00, 0xf8717ac7, 0xf9562403, 0xf00407bd, 0xec714556,
+	0xf6e11018, 0xd565040a, 0xc45f8400, 0xc5d0afc7, 0xf62558c0, 0xc0f01556,
+	0xc04e1c1e, 0xc83e5589, 0xc5155b00, 0xf8717ac7, 0xf9562403, 0xf00407bd,
+	0xec714556, 0xf6e11018, 0xd565040a, 0xc45f8400, 0xc183fbc7, 0xcd060cc0,
+	0xc80f1d82, 0xeb811181, 0xd833080c, 0xcca608c0, 0xeb811181, 0xc943080c,
+	0xc510bfc7, 0xc0b76044, 0xc5209fc7, 0xc4414cc0, 0xc440276e, 0xfc7014d5,
+	0xc441442a, 0xfc402dd8, 0xf07360ff, 0xc7fe10d8, 0xcc117a47, 0xc523345d,
+	0xc09db844, 0xc5e36347, 0xcc0179d6, 0xf6e1105d, 0xc5e30009, 0xc44174c2,
+	0xcd40276e, 0xc5d30c5e, 0xc09db844, 0xc5e183c7, 0xc5d0c7c7, 0xc09db844,
+	0xfc7178c0, 0xc4417434, 0xcc00276e, 0xc35f1c5e, 0xf6e1105d, 0xc22f1c09,
+	0xc29f1c5e, 0xf6e1105d, 0xc5e34009, 0xc5d0bfc7, 0xc09db844, 0xc510b7c7,
+	0xc0b76044, 0xc5e36347, 0xc5e1ffc4, 0xc44174c1, 0xf470276e, 0xdd6178d8,
+	0xc5d3005e, 0xc09db844, 0xcc2178c0, 0xf6e1105d, 0xc32f1c09, 0xc5d30c5e,
+	0xc09db844, 0xc5e183c7, 0xc5d0c7c7, 0xc09db844, 0xfc7178c0, 0xc4417434,
+	0xcc00276e, 0xc35f1c5e, 0xf6e1105d, 0xc33f1c09, 0xc29f1c5e, 0xf6e1105d,
+	0xc5e33c09, 0xc5d0bfc7, 0xc09db844, 0xc510bfc7, 0xc0b76044, 0xc0c32844,
+	0xc90c1cbd, 0xcc0060c5, 0xc30f1d7f, 0xc70f1d80, 0xc30f1d7e, 0xea71117d,
+	0xd7f3000c, 0xfc7600c0, 0xcc55f850, 0xea71117d, 0xc183180c, 0xc0a06362,
+	0xcc004c0f, 0xd803017f, 0xd7e1c3c7, 0xd7d0c3c7, 0xc0ca9c44, 0xc0006141,
+	0xc1831bec, 0xc0a06362, 0xcc00440f, 0xd803017f, 0xcc55f8ca, 0xea71117d,
+	0xc185040c, 0xcc4fb800, 0xc18d8818, 0xc2b03c06, 0xcd85fcc1, 0xd7e34180,
+	0xfd55f9c9, 0xcd85f873, 0xea71117d, 0xc442e80c, 0xc8300bef, 0xe01e5589,
+	0xcc106f05, 0xd803657f, 0xcd95fa47, 0xea71117d, 0xc185040c, 0xcc4f5000,
+	0xc18d8818, 0xc2103c06, 0xcd85fcc1, 0xd7e34180, 0xfd55f9c9, 0xcd85fa23,
+	0xea71117d, 0xd7f3040c, 0xccb600d9, 0xd7d3657e, 0xc0ca9c44, 0xc0006141,
+	0xc1832bde, 0xcc060ccf, 0xcf9f1d82, 0xeb811181, 0xd833000c, 0xfc7608c0,
+	0xc44604f9, 0xcc2032b8, 0xd8372583, 0xd83817d5, 0xfc7608c0, 0xc4460499,
+	0xccb032b8, 0xd8333c18, 0xcc4608c0, 0xeb811181, 0xc183300c, 0xcc060ccf,
+	0xd8131182, 0xc0cae044, 0xcc3060ca, 0xd8230183, 0xd8125fc7, 0xc0cae044,
+	0xcc7060ca, 0xd8230183, 0xc44604c0, 0xcc7032b8, 0xd8230183, 0xd81083c7,
+	0xc0cae044, 0xcc060cc7, 0xc40f1d82, 0xeb811181, 0xd8331c0c, 0xfc7608c0,
+	0xc4460460, 0xccb032b8, 0xc28f1c18, 0xd8230183, 0xc44604c5, 0xccc032b8,
+	0xc28f1c18, 0xd8230183, 0xc44604c5, 0xcca032b8, 0xc24f5c18, 0xd8372583,
+	0xd8303fd5, 0xdc9608c4, 0xc09f5582, 0xc96f1d82, 0xeb811181, 0xc1832c0c,
+	0xcc060cce, 0xd8131182, 0xc0cae044, 0xcc060ccc, 0xd8131182, 0xc0cae044,
+	0xfd7060cb, 0xdc960c20, 0xc02f5583, 0xd8230183, 0xc44604ca, 0xcd3032b8,
+	0xd8372583, 0xd83fffd5, 0xccc608c0, 0xeb811181, 0xd833080c, 0xcc6608c0,
+	0xeb811181, 0xd833000c, 0xcc6608c0, 0xeb811181, 0xd8331c0c, 0xcca608c0,
+	0xeb811181, 0xd833100c, 0xccc608c0, 0xeb811181, 0xd833080c, 0xcc6608c0,
+	0xeb811181, 0xd833000c, 0xcc6608c0, 0xeb811181, 0xc183280c, 0xcc060cc2,
+	0xc97f1d82, 0xeb811181, 0xc1832c0c, 0xcc060cc0, 0xd8131182, 0xc0cae044,
+	0xcc5060ca, 0xd8230183, 0xc44604c0, 0xcc5032b8, 0xd8230183, 0xd81083c7,
+	0xc0cae044, 0xcc060cc5, 0xc40f1d82, 0xeb811181, 0xd833140c, 0xfc7608c0,
+	0xc4460460, 0xcca032b8, 0xd8330418, 0xcc0608c0, 0xeb811181, 0xd833040c,
+	0xfc7608c0, 0xc4460420, 0xcc1032b8, 0xd8230183, 0xd81103c7, 0xc0cae044,
+	0xcc060cc1, 0xc60f1d82, 0xeb811181, 0xc451140c, 0xcfef1c45, 0xd8330018,
+	0xfc7608d0, 0xc4460480, 0xcc2032b8, 0xd8230183, 0xc44604ca, 0xcc2032b8,
+	0xc2ff1c94, 0xdd811051, 0xc27f1c0b, 0xc5330052, 0xc09db844, 0xc0535444,
+	0xc510abc7, 0xc0b76044, 0xcd83ffc4, 0xf8436307, 0xc5e91c7f, 0xccd174c1,
+	0xf6e11052, 0xcd8d1c09, 0xc5e7585e, 0xc44174c0, 0xcc00276e, 0xc5d3085e,
+	0xc09db844, 0xcc3178d4, 0xf6e1105d, 0xc60f1c09, 0xc31f1c5e, 0xf6e1105d,
+	0xc5e30009, 0xc5d0d3c7, 0xc09db844, 0xfc7178c0, 0xc4417435, 0xfc70276e,
+	0xfc717822, 0xc4417429, 0xcd00276e, 0xc2ff1c5e, 0xf6e1105d, 0xc39f1c09,
+	0xc5d3205e, 0xc09db844, 0xc5e0efc7, 0xc44174c9, 0xcc00276e, 0xc5d3285e,
+	0xc09db844, 0xc5e143c7, 0xc44174cb, 0xcc00276e, 0xc5d3305e, 0xc09db844,
+	0xccd178cf, 0xf6e1105d, 0xc2df1c09, 0xdd811051, 0xcd8d1c0b, 0xc7ff105e,
+	0xc5d3045e, 0xc09db844, 0xc5e36347, 0xcc0179d6, 0xf6e1105d, 0xc5e30009,
+	0xc44174c2, 0xfc70276e, 0xcc317832, 0xf6e1105d, 0xc60f1c09, 0xc31f1c5e,
+	0xf6e1105d, 0xc5e30009, 0xc5d0d3c7, 0xc09db844, 0xfc7178c0, 0xc4417435,
+	0xfc70276e, 0xfc717833, 0xc4417429, 0xccf0276e, 0xc2ff1c5e, 0xf6e1105d,
+	0xc2ff1c09, 0xdd811051, 0xcca1100b, 0xf072f40c, 0xc1831490, 0xfc75fcc0,
+	0xfc760030, 0xfc75f870, 0xc445f430, 0xcc0032a7, 0xd803017f, 0xd7e143c7,
+	0xc445f4c5, 0xcc6032a7, 0xc18d8818, 0xc1303c0a, 0xcc05fcc0, 0xc70f1d80,
+	0xc30f1d7e, 0xea71117d, 0xc185040c, 0xcc6fb000, 0xc18d8818, 0xc1103c0a,
+	0xcc05fcc0, 0xd7e32980, 0xc445f4c5, 0xd41032a7, 0xfee00018, 0xf62060c4,
+	0xc0f01818, 0xd7f3042b, 0xcd0600d8, 0xd7e7257e, 0xd7e1cfd5, 0xc445f4d8,
+	0xcba032a7, 0xc02fbc44, 0xf9562483, 0xc1bc1601, 0xcd95fcc1, 0xd7e91d80,
+	0xc445f4d9, 0xd41032a7, 0xfd400018, 0xf62060c4, 0xc0f01818, 0xd7f30421,
+	0xcd0600d8, 0xd7e7257e, 0xd7e88fd5, 0xc445f4d8, 0xcc1032a7, 0xd803657f,
+	0xcd95f8cb, 0xea71117d, 0xc185040c, 0xccaf7800, 0xd8333c18, 0xfc7608c0,
+	0xc44604f9, 0xcc0032b8, 0xd8230183, 0xd813e7c7, 0xc0cae044, 0xdc960cc2,
+	0xe05f5583, 0xd8230183, 0xd81267c7, 0xc0cae044, 0xccf060cb, 0xd8230183,
+	0xc44604c4, 0xccc032b8, 0xd8333c18, 0xcc4608c0, 0xeb811181, 0xc183280c,
+	0xcc060cc3, 0xc97f1d82, 0xeb811181, 0xc183280c, 0xcc060cc7, 0xd8130182,
+	0xc0cae044, 0xcc060cc7, 0xc20f1d82, 0xeb811181, 0xd8331c0c, 0xfc7608c0,
+	0xc4460440, 0xcc7032b8, 0xd8230183, 0xd81183c7, 0xc0cae044, 0xfd7060ca,
+	0xdc960c24, 0xc0ff5583, 0xd8231183, 0xfd5609c9, 0xfc760809, 0xc4460496,
+	0xccb032b8, 0xd8333818, 0xcc4608c0, 0xeb811181, 0xd833300c, 0xcc4608c0,
+	0xeb811181, 0xc1832c0c, 0xd83083d7, 0xfd560dc9, 0xcc060c02, 0xd8132982,
+	0xc0cae044, 0xdc960cd3, 0xffff5583, 0xd8230183, 0xc44604cc, 0xcc2032b8,
+	0xd8230183, 0xc44604c6, 0xcc0032b8, 0xd8230183, 0xc44604c6, 0xfd7032b8,
+	0xdc960c20, 0xc08f5583, 0xd8230183, 0xc44604ca, 0xcda032b8, 0xd8372583,
+	0xd83307d5, 0xccc608c0, 0xeb811181, 0xd833080c, 0xcc6608c0, 0xeb811181,
+	0xd833000c, 0xcc6608c0, 0xeb811181, 0xc20f5c0c, 0xd8372583, 0xd83027d5,
+	0xcca608c0, 0xeb811181, 0xc21f1c0c, 0xd8230183, 0xc44604cc, 0xcc2032b8,
+	0xd8230183, 0xc44604c6, 0xcc0032b8, 0xd8230183, 0xc44604c6, 0xcc7032b8,
+	0xd8230183, 0xc44604ca, 0xcc4032b8, 0xd8230183, 0xc44604cc, 0xcc2032b8,
+	0xd8230183, 0xc44604c6, 0xcc0032b8, 0xd8230183, 0xc44604c6, 0xcca032b8,
+	0xd8330818, 0xfc7608c0, 0xc4460497, 0xccb032b8, 0xd8330018, 0xcc4608c0,
+	0xeb811181, 0xc183280c, 0xcc060cc5, 0xd8130182, 0xc0cae044, 0xcc060cc5,
+	0xc20f1d82, 0xeb811181, 0xd833140c, 0xfc7608c0, 0xc4460440, 0xcc5032b8,
+	0xd8230183, 0xd81183c7, 0xc0cae044, 0xcc1060ca, 0xd8230183, 0xc44604c0,
+	0xcc1032b8, 0xd8230183, 0xd81083c7, 0xc0cae044, 0xcc060cc1, 0xc40f1d82,
+	0xeb811181, 0xd833040c, 0xfc7608c0, 0xc4460460, 0xc45032b8, 0xc4511445,
+	0xc4511445, 0xc4511445, 0xc2bf1c45, 0xd563005d, 0xc0555b62, 0xf870780f,
+	0xf9562404, 0xd56c0071, 0xc5eb1c51, 0xd8900f87, 0xd01ef795, 0xc5155b00,
+	0xc44062c7, 0xd4102b6e, 0xfe100156, 0xc2bf1c45, 0xc0ff105d, 0xc04e1d6d,
+	0xc71e5589, 0xc515b700, 0xd0a17ac7, 0xc55b1c51, 0xd8902797, 0xf00f5395,
+	0xc4c1416d, 0xc54b1d21, 0xec714687, 0xf6e11018, 0xc54c1c0a, 0xec714501,
+	0xc55d1c18, 0xf6e1105e, 0xcc11140a, 0xc2ff1c94, 0xdd811051, 0xc27f1c0b,
+	0xc5330052, 0xc09db844, 0xc0535444, 0xc510bfc7, 0xc0b76044, 0xcd83ffc4,
+	0xf8436307, 0xc5e91c7f, 0xccd174c1, 0xf6e11052, 0xcd8d1c09, 0xc5e7585e,
+	0xc44174c0, 0xcc00276e, 0xc5d3085e, 0xc09db844, 0xcc3178d4, 0xf6e1105d,
+	0xc5e30009, 0xc5d0d3c7, 0xc09db844, 0xfc7178c0, 0xc4417435, 0xfc70276e,
+	0xfc717860, 0xc4417431, 0xfc70276e, 0xfc717822, 0xc4417429, 0xfc70276e,
+	0xc441442f, 0xc4402dd8, 0xcbd030ca, 0xc4424307, 0xc45011a4, 0xc015e762,
+	0xf0709009, 0xf84654d7, 0xc094001f, 0xcc527c03, 0xd5a91d74, 0xcc05e4c0,
+	0xd5b37597, 0xcdf564c1, 0xc2dd1d7b, 0xc2d3757a, 0xdd8080bd, 0xc330000c,
+	0xc2d5eb47, 0xfc4550c0, 0xcc023ffd, 0xc5330090, 0xe4736307, 0xc33c115d,
+	0xf0457707, 0xc0700433, 0xc05b5044, 0xf0704000, 0xc34c115d, 0xc4401c01,
+	0xc00019c9, 0xd9011005, 0xf072f407, 0xdd808090, 0xc441140c, 0xcbc03b15,
+	0xc0c76020, 0xfdc11045, 0xc202f00e, 0xc45031d8, 0xc0154140, 0xd4c50006,
+	0xf640c809, 0xc0100554, 0xd5a33c21, 0xcc165cc0, 0xd6ad9159, 0xc0702408,
+	0xd7b093c7, 0xfc701400, 0xfc45ec22, 0xfc525b7f, 0xcbc25900, 0xc0c76020,
+	0xfc402800, 0xfc525b7f, 0xcc025900, 0xd453042d, 0xcc116400, 0xd96d8858,
+	0xc3802401, 0xf62628c0, 0xc0f0098a, 0xd50c1c31, 0xc0116304, 0xd55d8825,
+	0xc1302401, 0xd5a16347, 0xcc0554c0, 0xd5b37197, 0xcdf564c1, 0xc202f17b,
+	0xc44031d8, 0xcc503475, 0xc2d3718a, 0xcc05ecdc, 0xd5250596, 0xd41161c0,
+	0xfce0018a, 0xcc0160c1, 0xd8ad898a, 0xc1303c02, 0xf0454307, 0xc0700458,
+	0xc0dba444, 0xdc0628c5, 0xd8a50458, 0xc45fb000, 0xc079b044, 0xdd8080bc,
+	0xc901140c, 0xd6ac1189, 0xf0702801, 0xfffe516a, 0xc0053e47, 0xd6ac1c08,
+	0xe47fff94, 0xc8c1154e, 0xd6ac1189, 0xfc702c09, 0xcc151cbe, 0xd4930148,
+	0xc8c05800, 0xd6ac1189, 0xe826a4a4, 0xc0001009, 0xd892300b, 0xca85ab04,
+	0xc09a09a9, 0xcbef1002, 0xd5f30547, 0xf07580c0, 0xf8461147, 0xd6191ce0,
+	0xd9251f07, 0xda452327, 0xcffe1285, 0xf0758a47, 0xf2764948, 0xe8569149,
+	0xe473ff84, 0xd49c1d63, 0xc1fe1192, 0xe4701b85, 0xcc011564, 0xd7730009,
+	0xf47654c0, 0xf4715023, 0xf475a823, 0xf975496a, 0xe446243c, 0xefff1152,
+	0xc80f1496, 0xc20e5c96, 0xd52c1189, 0xcc002401, 0xf0411152, 0xc4e00007,
+	0xf026248c, 0xc1502552, 0xf07548c0, 0xcffe116a, 0xf0751e47, 0xf8465d6a,
+	0xd4891c0f, 0xc00524c0, 0xd5230035, 0xcc1658c1, 0xd9530155, 0xf0462490,
+	0xc090056a, 0xd5053f47, 0xc005d0d4, 0xd4ed1c07, 0xd7430150, 0xf845ab07,
+	0xd4b91c06, 0xf9562483, 0xd6ac1300, 0xc4453247, 0xdd701f19, 0xd7b3714c,
+	0xcdc0b4dc, 0xc441142c, 0xc2001f6a, 0xc450495c, 0xc183fbc7, 0xd84203c7,
+	0xc0cb1444, 0xc1b013c5, 0xd8306f47, 0xd8207347, 0xd81203c7, 0xc0cae044,
+	0xc2cf1c45, 0xd8330818, 0xfc7608c0, 0xc4460497, 0xcc0032b8, 0xc55d8855,
+	0xc0703cff, 0xc555044e, 0xcc1fe000, 0xd8230183, 0xd813f7c7, 0xc0cae044,
+	0xf62154c0, 0xc0f3fc55, 0xd4113807, 0xff800055, 0xcc060cc0, 0xcfdf1d82,
+	0xeb811181, 0xc553000c, 0xcff15762, 0xc4e01c0f, 0xc0015541, 0xd83303f8,
+	0xfc7608c0, 0xc4460497, 0xc45032b8, 0xc180b3c7, 0xd8438fc7, 0xc0cb1444,
+	0xd9406f47, 0xc0f65364, 0xcc501809, 0xc0b0016f, 0xf8465307, 0xc094500f,
+	0xd6f31004, 0xcf065364, 0xcc501809, 0xc0c00170, 0xf8465307, 0xc40e08f0,
+	0xcc401009, 0xd8920d70, 0xf04c0395, 0xc0602594, 0xc005c4c5, 0xd8920c0f,
+	0xf04c0395, 0xda928594, 0xc0402682, 0xf975c4c4, 0xf046243c, 0xc0602594,
+	0xc005c8c5, 0xc3ce5c0e, 0xd94c1189, 0xe826a4b0, 0xcc401009, 0xcc011572,
+	0xc23d1c09, 0xc54c1c54, 0xe47fff94, 0xd8924173, 0xc0115304, 0xd7435006,
+	0xcc001000, 0xd7b37974, 0xc200b0dc, 0xc450495c, 0xf47024c0, 0xcdc15023,
+	0xd5c0802c, 0xc8811412, 0xe478a189, 0xc55b1c54, 0xf62060c6, 0xc0e02418,
+	0xd7f30438, 0xcd0600d8, 0xd7e7257e, 0xd7e1c7d5, 0xc445f4d8, 0xcba032a7,
+	0xc02fbc44, 0xcd95fcc1, 0xc1bc1d80, 0xe4715704, 0xd7d3657e, 0xc0ca9c44,
+	0xcd95fcc1, 0xc1bc1d80, 0xe4715305, 0xd7d3657e, 0xc0ca9c44, 0xc0006141,
+	0xc90d1fc7, 0xfc71145f, 0xcc00602c, 0xd6630165, 0xf62158c0, 0xc0f05056,
+	0xc56c1c32, 0xd8391d80, 0xfc7608c0, 0xc44604e1, 0xfc7032b8, 0xc44610e1,
+	0xf07032c5, 0xf846701b, 0xc1cc9c07, 0xe40a15a2, 0xd65c1d65, 0xc0a59b02,
+	0xd65d1c07, 0xc0500166, 0xd66fffc7, 0xc0015941, 0xd66d1fcd, 0xcc11145f,
+	0xd803617f, 0xdc95f8d0, 0xc73f557e, 0xd7d3617e, 0xc0ca9c44, 0xfef110ba,
+	0xd8723802, 0xf0500785, 0xd7f3041b, 0xe47600d9, 0xd7d3657e, 0xc0ca9c44,
+	0xccc5fcc1, 0xf00f5d80, 0xd7d3317e, 0xc0ca9c44, 0xc34f1c45, 0xc183245d,
+	0xc0ae1c44, 0xee404f27, 0xc0502408, 0xc99007c5, 0xc09012e4, 0xc01f1405,
+	0xc183209a, 0xc0ae1c44, 0xee404f27, 0xc0502408, 0xc9900bc5, 0xc09012e4,
+	0xc02f1405, 0xc1831c9a, 0xc0ae1c44, 0xee404f27, 0xc0502408, 0xc99013c5,
+	0xc09012e4, 0xc04f1405, 0xc183189a, 0xc0ae1c44, 0xee404f27, 0xc0502408,
+	0xc99023c5, 0xc09012e4, 0xc08f1405, 0xc183149a, 0xc0ae1c44, 0xee404f27,
+	0xc0502408, 0xc9b043c5, 0xc09012e4, 0xc01f1405, 0xc183109b, 0xc0ae1c44,
+	0xee404f27, 0xc0502408, 0xc9b083c5, 0xc09012e4, 0xc02f1405, 0xcc11149b,
+	0xc183605c, 0xc2106362, 0xfc70540e, 0xc4417434, 0xf2702b87, 0xc01e9013,
+	0xc0402520, 0xd41170c0, 0xfea00018, 0xc5c30445, 0xf62060c5, 0xc0e02018,
+	0xc34f1c15, 0xf871105d, 0xc13c9c0a, 0xd20007a4, 0xcc001009, 0xc185045c,
+	0xc45fa800, 0xc180b3c7, 0xfc7170c0, 0xc44610a5, 0xf87032c5, 0xc5c91fff,
+	0xf0206f07, 0xc0f0245c, 0xc0f07362, 0xcc101809, 0xc080005c, 0xc00170c0,
+	0xc5c30004, 0xc2cf1c45, 0xc5c30018, 0xd84293c7, 0xc0cb1444, 0xe47fff87,
+	0xc1bc1c5c, 0xc0917302, 0xc1cd880f, 0xc060240f, 0xc00170c1, 0xc5c30008,
+	0xcc001000, 0xfc71145c, 0xcc30602c, 0xca3f1c5c, 0xec511184, 0xd892040c,
+	0xc0106f04, 0xffdf1005, 0xc1cdd05c, 0xc0500600, 0xc5cffbc4, 0xc5f17347,
+	0xc2cf1c45, 0xc5c30418, 0xd8428fc7, 0xc0cb1444, 0xc1c783c4, 0xde007362,
+	0xcc001001, 0xfc71145c, 0xcc30602c, 0xca3f1c5c, 0xec511184, 0xd892040c,
+	0xc0106f04, 0xffdf1005, 0xc1cdd05c, 0xc0500600, 0xc5cffbc4, 0xc5c31845,
+	0xd8428fc7, 0xc0cb1444, 0xe0007374, 0xfc401401, 0xc45173fd, 0xfc7170c4,
+	0xc44610a3, 0xf74032c5, 0xc018001c, 0xc02f1405, 0xcc11145c, 0xd73d1d9e,
+	0xd68301a1, 0xc055a362, 0xf641440f, 0xc0100573, 0xc04e1c3e, 0xc5fe5589,
+	0xf0916a47, 0xd74c0168, 0xf0707a47, 0xc1ec005a, 0xc5ab1c51, 0xe8714501,
+	0xc5bb1c4c, 0xc1816b47, 0xfc760cc0, 0xcc26084d, 0xeb811181, 0xc40f1c0c,
+	0xec511184, 0xc20e5c0c, 0xc1bc1189, 0xf0802001, 0xd6e9119e, 0xcc301000,
+	0xd737402c, 0xc095cd40, 0xc0800004, 0xd41679c0, 0xfae00168, 0xf9468707,
+	0xd7391fff, 0xc095b940, 0xd73d1c17, 0xd973015a, 0xc0155364, 0xfc701c01,
+	0xc0056c22, 0xd5b37004, 0xcdf564c1, 0xc202f17b, 0xc45031d8, 0xcbc5ecdc,
+	0xc0c76020, 0xd5ad9045, 0xc6d00401, 0xd8901387, 0xe4717f95, 0xd97c245a,
+	0xe475d300, 0xc5ac1c1e, 0xc5107b00, 0xf4716ac7, 0xf620605a, 0xc0900559,
+	0xd8330034, 0xd8209bc7, 0xc44604c2, 0xfc7032b8, 0xc4461040, 0xf64032c5,
+	0xc0900c1b, 0xd593040a, 0xd41569d0, 0xc4100197, 0xfc760cc0, 0xcc260824,
+	0xeb811181, 0xf972a00c, 0xc4415301, 0xcc000bdc, 0xc2c00159, 0xd84103c7,
+	0xc0cb1444, 0xc0206f64, 0xca804001, 0xc44c0397, 0xcc100bef, 0xd5a74159,
+	0xc0065d41, 0xc2c30c13, 0xd4003c00, 0xc070255a, 0xd7b56f47, 0xdd001800,
+	0xd975055a, 0xdd8080bc, 0xf641140c, 0xc010055a, 0xc04e1c34, 0xc5fe5589,
+	0xf0916a47, 0xd74c0197, 0xf0707a47, 0xc1ec005a, 0xc5ab1c51, 0xe8714501,
+	0xc5bb1c4c, 0xc1816b47, 0xc4420ca4, 0xf4700bdc, 0xfc755d7b, 0xcdc5ec20,
+	0xd593002d, 0xd41569d0, 0xc0d00197, 0xd41569d0, 0xd5a50197, 0xf4701409,
+	0xcdc5ed5b, 0xc202f02c, 0xc45031d8, 0xc44174c4, 0xf4702b87, 0xfc406413,
+	0xfc506401, 0xcc006500, 0xd8034d7f, 0xd7e06747, 0xc445f4d3, 0xc45032a7,
+	0xc44174c4, 0xf4702b87, 0xfc406413, 0xdc206402, 0xe00f5419, 0xd7f30019,
+	0xf47600d3, 0xcd35f819, 0xea71117d, 0xcc41140c, 0xf871105d, 0xc13d1c0a,
+	0xc01f1019, 0xc01f1819, 0xd00f1419, 0xd7f30019, 0xf47600d3, 0xcd35f819,
+	0xea71117d, 0xcc41140c, 0xf871105d, 0xc13d1c0a, 0xc02f1019, 0xc02f1819,
+	0xc1970819, 0xc19803d5, 0xcd35fcc0, 0xc19d1d80, 0xd7d34d7e, 0xc0ca9c44,
+	0xc5d31045, 0xc0ae1c44, 0xc1904f47, 0xc19007c4, 0xfd5065c3, 0xcc006600,
+	0xd8034d7f, 0xd7e06747, 0xc445f4d3, 0xc45032a7, 0xc44174c4, 0xf4702b87,
+	0xfc406413, 0xfc606401, 0xdc306401, 0xe00f5419, 0xd7f30019, 0xf47600d3,
+	0xcd35f819, 0xea71117d, 0xc451140c, 0xc0965540, 0xd5a30006, 0xf621a000,
+	0xc0900595, 0xd5a31006, 0xf6217c00, 0xc0900995, 0xc58d1c07, 0xc550015a,
+	0xc0365762, 0xf6405409, 0xc0103c58, 0xd5a33c06, 0xf6411c00, 0xc013c058,
+	0xcf0f1c42, 0xc3d0015a, 0xc0465762, 0xf6405409, 0xc0103c58, 0xd5a33c06,
+	0xf640bc00, 0xc013c058, 0xcf0f1c2a, 0xc250015a, 0xc0565762, 0xfd701c09,
+	0xc0056bff, 0xd95d881b, 0xc0602406, 0xc00568c4, 0xd95d8812, 0xc0602408,
+	0xc00568cf, 0xd95d8809, 0xc0402409, 0xc45568cf, 0xd945df47, 0xf625a4c0,
+	0xc0f01569, 0xd77d90eb, 0xcda00401, 0xd8901387, 0xe4717f95, 0xd69c245a,
+	0xe475d300, 0xc5ac1c1e, 0xc5107b00, 0xd0116ac7, 0xc4ca1c51, 0xf6416ec7,
+	0xc090416a, 0xc5ad1c72, 0xd7f30018, 0xfd7600c0, 0xcc25fbff, 0xea71117d,
+	0xd7f3000c, 0xfd7600c0, 0xcc85fb00, 0xea71117d, 0xd7f3000c, 0xcc7600c0,
+	0xd7d3057e, 0xc0ca9c44, 0xc085ab64, 0xcc103809, 0xd803117f, 0xd7e14bc7,
+	0xc445f4c4, 0xf47032a7, 0xcc00605b, 0xd803017f, 0xd7efffd7, 0xc445f4c2,
+	0xcc0032a7, 0xd803017f, 0xd7ec03d7, 0xc445f4c8, 0xcc0032a7, 0xd803017f,
+	0xcc15f8c7, 0xea71117d, 0xd6ad900c, 0xc5902408, 0xcc45fcc1, 0xcd2f1d80,
+	0xd7d3117e, 0xc0ca9c44, 0xf4712c00, 0xf620605a, 0xc0900554, 0xd7f30010,
+	0xfd7600c0, 0xcc25fbff, 0xea71117d, 0xc0e0000c, 0xcc05fcc0, 0xffff5d80,
+	0xd7d3097e, 0xc0ca9c44, 0xcc05fcc0, 0xf00f5d80, 0xd7d3217e, 0xc0ca9c44,
+	0xcc05fcc0, 0xd7e31d80, 0xc445f4c1, 0xf64032a7, 0xc090216a, 0xd7f3040d,
+	0xcd2600c4, 0xd7d3117e, 0xc0ca9c44, 0xd405ddd0, 0xc0402577, 0xd4101800,
+	0xf1400169, 0xd7765347, 0xd735df47, 0xd6e5df47, 0xcd832845, 0xd5135cc0,
+	0xed41114c, 0xfc711405, 0xf4736042, 0xf4735c58, 0xf085dc58, 0xd5091058,
+	0xdc553151, 0xd90110d7, 0xf4711407, 0xf7465058, 0xc09c0194, 0xd7730435,
+	0xcd810bc7, 0xc0f65364, 0xccf03c01, 0xff0f1176, 0xfe4f5d50, 0xd90110d7,
+	0xc1700007, 0xcf065364, 0xfc704801, 0xfc45d8f0, 0xccf5430f, 0xcd7724d7,
+	0xcd7093d5, 0xc0764044, 0xf4753151, 0xc005dd76, 0xc01f1405, 0xd94d1c09,
+	0xf4711458, 0xf7465058, 0xc09c0194, 0xd7730435, 0xcd810bc7, 0xc0f65364,
+	0xccf03c01, 0xff0f1176, 0xfe4f5d50, 0xd90110d7, 0xc1700007, 0xcf065364,
+	0xfc704801, 0xfc45d8f0, 0xccf5430f, 0xcd7724d7, 0xcd7093d5, 0xc0764044,
+	0xf4753151, 0xc005dd76, 0xc01f1405, 0xd94d1c09, 0xfc711458, 0xfc736042,
+	0xfd735c24, 0xcc05dfff, 0xd4c54550, 0xc0764044, 0xfd711445, 0xdc936020,
+	0xc42f54d8, 0xcd7300d8, 0xcc053151, 0xd7733d50, 0xc05b5044, 0xd54d8845,
+	0xc0b02401, 0xc0671c44, 0xd515dccf, 0xc150014c, 0xcd8083d7, 0xfd5361c9,
+	0xcc036042, 0xd4c544d7, 0xccf540c0, 0xed411177, 0xcc011405, 0xc7330074,
+	0xc0b8dc44, 0xd8900f87, 0xf00e6f95, 0xc4c14018, 0xc010cf22, 0xc32e8028,
+	0xec70cf25, 0xc13c9c12, 0xe6417307, 0xc0400402, 0xf8414f35, 0xed58d401,
+	0xc5cd9090, 0xc0c00404, 0xf0220b07, 0xc0600474, 0xe0814f07, 0xc13b1e24,
+	0xf071cd41, 0xcbec0873, 0xf64f1009, 0xc010105c, 0xc53c1c20, 0xc0124304,
+	0xc82c1c1a, 0xc011d302, 0xc53d1814, 0xc7450490, 0xf0720327, 0xd1113881,
+	0xd31ff807, 0xc00fe407, 0xc631179f, 0xc6619464, 0xc691a067, 0xc6c1ac6a,
+	0xc6f1b86d, 0xc721c470, 0xcc7170c0, 0xc1c30019, 0xc4406cd1, 0xc4500231,
+	0xf825ef07, 0xc3fe1014, 0xfb088229, 0xd99a1f05, 0xc4100f90, 0xcc011440,
+	0xc1931c5c, 0xcd0070c0, 0xe311101b, 0xc1931c00, 0xcd2070c0, 0xe311101b,
+	0xcc011400, 0xf871105d, 0xc13c1c0a, 0xc5d30586, 0xc0ae1c44, 0xe4704f05,
+	0xc29f1c5f, 0xf871105d, 0xc13d1c0a, 0xc2bf1c60, 0xf871105d, 0xc13d1c0a,
+	0xc3d11061, 0xcc01140a, 0xd7f3045c, 0xd80083c7, 0xfc75f8c0, 0xc445f420,
+	0xcc1032a7, 0xd803057f, 0xcc15f8c0, 0xea71117d, 0xd7f3040c, 0xcc3600d1,
+	0xd7d3457e, 0xc0ca9c44, 0xcc55fcc1, 0xc24e5d80, 0xc5fc1589, 0xcc55fa47,
+	0xea71117d, 0xd7f3040c, 0xf47600d4, 0xcd45f860, 0xea71117d, 0xc80e1c0c,
+	0xd8718705, 0xcce5fcc1, 0xd7e91d80, 0xc445f4ce, 0xfc7032a7, 0xc441742a,
+	0xf0702b87, 0xff8e5013, 0xcc15fcc1, 0xc03e1580, 0xcc15fa47, 0xea71117d,
+	0xef61100c, 0xcc01140c, 0xc31f1c5c, 0xf871105d, 0xc13d900a, 0xc1900440,
+	0xc5d0abc7, 0xc0ae1c44, 0xf9404f07, 0xd7f307f8, 0xf85600c1, 0xd7e91c07,
+	0xc445f4c1, 0xc45032a7, 0xc82083c7, 0xc80403c7, 0xc81403c7, 0xcc2170c4,
+	0xd803057f, 0xdc95f8c2, 0xe00f557e, 0xd26f1d7e, 0xea71117d, 0xc1bd1c0c,
+	0xcc411458, 0xc8272482, 0xcc0200d0, 0xc5c31081, 0xfb56a4b0, 0xc4420026,
+	0xfc400bef, 0xf6206c03, 0xc0100c1b, 0xc02f1405, 0xcc01145c, 0xd7f3045c,
+	0xfd7600c8, 0xcc85fb01, 0xea71117d, 0xd7f3040c, 0xfc7600c2, 0xcc25f925,
+	0xea71117d, 0xd7f3040c, 0xfd7600c2, 0xcc25fa35, 0xea71117d, 0xd7f3040c,
+	0xfd7600c3, 0xcc35fa03, 0xea71117d, 0xd421100c, 0xcc11140a, 0xd8034d7f,
+	0xd7e13f47, 0xd7d083d7, 0xfd55f5c9, 0xc445f413, 0xcc1032a7, 0xd803517f,
+	0xd7e14347, 0xd7d083d7, 0xfd55f5c9, 0xc445f414, 0xcc1032a7, 0xd803497f,
+	0xfd75f8c2, 0xdc95f420, 0xc12f557d, 0xea71117d, 0xc442040c, 0xf6200bef,
+	0xc010481b, 0xc01f1405, 0xfc71145c, 0xfc720820, 0xfc720100, 0xcc420500,
+	0xd7f3085c, 0xd80107c7, 0xcd05f8c0, 0xd7d7257d, 0xd7d04bd5, 0xc0ca9c44,
+	0xc5806f47, 0xc5c30045, 0xfb56a4b0, 0xc442000d, 0xf4700bef, 0xfb71681b,
+	0xfb56a420, 0xe082200d, 0xc4416b04, 0xf6200bef, 0xc010341b, 0xc01f1405,
+	0xd7f3085c, 0xcc0600c0, 0xd7d3417e, 0xfd55f5c9, 0xc445f40e, 0xf47032a7,
+	0xcc21601b, 0xd803017f, 0xcd05f8c0, 0xd7d7257d, 0xd7d03fd5, 0xc0ca9c44,
+	0xc5906f47, 0xc0123f62, 0xcc105c09, 0xd803357f, 0xf8516b07, 0xd7e91c01,
+	0xd7d083d7, 0xfd55f5c9, 0xc445f40d, 0xcc1032a7, 0xd803357f, 0xd7e16b47,
+	0xd7d083d7, 0xfd55f5c9, 0xc445f40d, 0xc45032a7, 0xcc1170c0, 0xd803217f,
+	0xd7ec03d7, 0xc445f4c8, 0xc45032a7, 0xcc1170c0, 0xd8032d7f, 0xccb5f8c1,
+	0xea71117d, 0xcc01140c, 0xda92c05c, 0xc8009bb5, 0xc02fbc44, 0xc5806f47,
+	0xc1b043c4, 0xc1006f64, 0xfc501401, 0xfb717002, 0xfb56a420, 0xe0824026,
+	0xc4416304, 0xf6200bef, 0xc010981b, 0xc01f1405, 0xcc01145c, 0xc28f1c5c,
+	0xf871105d, 0xc13d1c0a, 0xc58d8858, 0xc0502401, 0xc0a9f844, 0xc0716362,
+	0xc4401409, 0xc4502a9e, 0xc5d09fc7, 0xc0ae1c44, 0xd8304f07, 0xc5d0a3c7,
+	0xc0ae1c44, 0xd8304f05, 0xc440c3a7, 0xf6200bef, 0xc010c01b, 0xc01f1405,
+	0xcc21145c, 0xf871105d, 0xc13d1c0a, 0xc5871858, 0xc44174c3, 0xf4502b87,
+	0xc8416013, 0xc5891589, 0xcd15fcc1, 0xd7e30180, 0xc445f4d1, 0xfc7032a7,
+	0xc4417427, 0xf0702b87, 0xfc760c13, 0xc4417428, 0xf0502b87, 0xfa760c13,
+	0xfef11030, 0xc1bd8802, 0xc0500430, 0xc5c007c5, 0xcc55fcc1, 0xc58d1d80,
+	0xd7d3157e, 0xc0ca9c44, 0xcd85fcc1, 0xd7e34180, 0xfd55f9c9, 0xcd85fa21,
+	0xea71117d, 0xc442e80c, 0xcc100bef, 0xd803657f, 0xf0562481, 0xd7e91c1b,
+	0xc445f4d9, 0xfc7032a7, 0xc441742a, 0xcc102b87, 0xd803057f, 0xf9404f07,
+	0xc01e17f8, 0xcc15fa47, 0xea71117d, 0xd7f3040c, 0xf07600c1, 0xff8e5013,
+	0xe4700f85, 0xd7d3057e, 0xc0ca9c44, 0xc5c30045, 0xc8c09ba7, 0xfef11189,
+	0xd7f30402, 0xcc1600ca, 0xd7d3297e, 0xc0ca9c44, 0xc20f1c45, 0xd00f1c82,
+	0xd00f1c80, 0xc5c31081, 0xc8249ba7, 0xf00e5589, 0xc02fbc44, 0xc5806f47,
+	0xc1b007c4, 0xf4506dc0, 0xc451701b, 0xc45170c0, 0xcc010440, 0xc03e1c5c,
+	0xf9be5589, 0xc5006300, 0xc5dc804c, 0xec70cf25, 0xc5ed1c12, 0xc4210c13,
+	0xc4110045, 0xd8900f87, 0xf00e6f95, 0xc4c14018, 0xf2517720, 0xc12b1c33,
+	0xc4510843, 0xf97170c0, 0xcb562430, 0xc02fbc44, 0xc0106d40, 0xc1bd880b,
+	0xc0900415, 0xc00170c1, 0xc02f1405, 0xc5d31c5c, 0xc0ae1c44, 0xe6404f07,
+	0xc0400440, 0xf0520385, 0xc442d433, 0xd4000bef, 0xc0b0041b, 0xc1506f62,
+	0xcc102401, 0xc050005c, 0xc5c00bc5, 0xc44174c6, 0xf0702b87, 0xc34c1413,
+	0xfef110b5, 0xc1b50002, 0xf6202c01, 0xc010541b, 0xc5c30409, 0xfc501400,
+	0xcc517002, 0xf871105d, 0xc13c1c0a, 0xc0110264, 0xc80e1404, 0xfef110b5,
+	0xc1b50002, 0xf6202c01, 0xc010541b, 0xc5c30409, 0xfc501400, 0xc4517002,
+	0xcc4170c0, 0xf871105d, 0xf00e5c0a, 0xc0204f64, 0xf8501001, 0xc13d9010,
+	0xc0400401, 0xcb300785, 0xc02fbc44, 0xc1306f62, 0xfc501401, 0xc4517001,
+	0xcc4170c0, 0xf871105d, 0xf00e5c0a, 0xc0404f64, 0xf8501001, 0xc13d9001,
+	0xc0400408, 0xca804385, 0xc02fbc44, 0xc0806f62, 0xfc501401, 0xc4517001,
+	0xcc4170c0, 0xf871105d, 0xc13c1c0a, 0xd930c384, 0xc5c30045, 0xfc77ff87,
+	0xc4417425, 0xf6402b87, 0xc0102013, 0xd20e1c04, 0xc1303fc4, 0xcc25fcc1,
+	0xc13c1580, 0xcc25fa47, 0xea71117d, 0xcc01140c, 0xeffe5c5c, 0xc5d09bc7,
+	0xc0ae1c44, 0xc0804f64, 0xf0702001, 0xc07e1013, 0xcc18c395, 0xd803097f,
+	0xcc25fa47, 0xea71117d, 0xd7f3040c, 0xcc0600c3, 0xd7d30d7e, 0xc0ca9c44,
+	0xf6480f97, 0xc0902013, 0xd892200c, 0xf6440f95, 0xc0904013, 0xcc120c03,
+	0xd8030d7f, 0xcc35fa47, 0xea71117d, 0xcc01140c, 0xc8ed905c, 0xc1500404,
+	0xcc05fcc0, 0xd7e35980, 0xfd55f9c9, 0xfc75fb01, 0xc445f426, 0xc00032a7,
+	0xd7f30013, 0xcd6600c0, 0xd7e7257e, 0xd7ec03d5, 0xd7d09bc7, 0xc0ca9c44,
+	0xc44174c8, 0xf0702b87, 0xc01e1013, 0xc0804f64, 0xf8501c01, 0xd8920480,
+	0xc13d9205, 0xc0400410, 0xf6480395, 0xc0108013, 0xd00e1404, 0xc4004f64,
+	0xf8501001, 0xc442a840, 0xf6200bef, 0xc010281b, 0xc01f1405, 0xcc01145c,
+	0xc5d3245c, 0xc0ae1c44, 0xf8404f07, 0xf6460003, 0xc0102013, 0xc80e1404,
+	0xc1004f64, 0xf9501001, 0xc13d9200, 0xc0400420, 0xf6440385, 0xc0110013,
+	0xc40e1404, 0xfef110aa, 0xc1bd8802, 0xc050040a, 0xc5c007c5, 0xc2cf1c45,
+	0xf871105d, 0xc13d1c0a, 0xc5c3005f, 0xf8417f07, 0xf8561c0f, 0xd7f30440,
+	0xd80083c7, 0xd7e083c7, 0xd7d083c7, 0xc0ca9c44, 0xc5917347, 0xc0a8d444,
+	0xc5c007c4, 0xc5c16745, 0xc5c30045, 0xc5d09fc7, 0xc0ae1c44, 0xd8304f07,
+	0xc5d0a3c7, 0xc0ae1c44, 0xd8304f05, 0xfc75fcc1, 0xe4760030, 0xc30f1d7e,
+	0xea71117d, 0xcc01140c, 0xd7f3045c, 0xcc0600d7, 0xd7d35d7e, 0xc0ca9c44,
+	0xc5c30045, 0xc5d0c7c7, 0xc0ae1c44, 0xc4004f64, 0xc4401409, 0xc45027e4,
+	0xc4014764, 0xc4401c01, 0xc0002df2, 0xc51d9011, 0xc0700420, 0xc0b83044,
+	0xf4701c00, 0xcc12d051, 0xf47114be, 0xf622f8c9, 0xc06000be, 0xcbfe1c10,
+	0xc4c2fb00, 0xf002d387, 0xd51134be, 0xfef000be, 0xcbe32747, 0xc09e5c45,
+	0xfd4e5589, 0xfa414727, 0xc50a000f, 0xc52a1c4c, 0xcbed1cbe, 0xc5491c55,
+	0xc562d3c7, 0xc0015762, 0xd4104006, 0xc54c1c54, 0xc56c1c51, 0xc565044d,
+	0xc0015551, 0xf87117ef, 0xc73c00b4, 0xc18b1c4c, 0xf8414b07, 0xe208a43f,
+	0xe87917b0, 0xc03e4199, 0xc4510041, 0xcc05e0c1, 0xffff5c7c, 0xc7e3347d,
+	0xc7f093c7, 0xcd0200d0, 0xc8234081, 0xc8312bc7, 0xc840d7c7, 0xc851dfc7,
+	0xcc0218c0, 0xc8830087, 0xc45224c0, 0xfc7160c0, 0xcc01647c, 0xc58d8858,
+	0xc0f03c0e, 0xc4040451, 0xc4d16707, 0xc4216541, 0xc0016141, 0xcc0117f0,
+	0xc54d8854, 0xc1a03c05, 0xccae1c40, 0xc4c15300, 0xc4204ac7, 0xc2db88a0,
+	0xc520200e, 0xd2140413, 0xd41fe000, 0xfe500054, 0xc03e1c45, 0xfa5e5589,
+	0xf8718e47, 0xf9562403, 0xc6491fa8, 0xd8900f87, 0xe47eab95, 0xc03e1c65,
+	0xface5589, 0xf8719a47, 0xf9562403, 0xc6791fae, 0xd8900f87, 0xe47ec395,
+	0xc03e1c68, 0xfb2e5589, 0xf871a647, 0xf9562403, 0xc6a91fb2, 0xd8900f87,
+	0xe47ecb95, 0xc03e1c6b, 0xfb2e5589, 0xf871b247, 0xf9562403, 0xc6d91fb2,
+	0xd8900f87, 0xe47edf95, 0xc03e1c6e, 0xfb9e5589, 0xf871be47, 0xf9562403,
+	0xc7091fbb, 0xd8900f87, 0xe47ef795, 0xc03e1c71, 0xfbde5589, 0xc451ca47,
+	0xcd40cf47, 0xca132b87, 0xc54301a9, 0xcc015325, 0xc54d8854, 0xc0a03c05,
+	0xc40e804d, 0xc5450501, 0xc45fd400, 0xc14007c5, 0xc14013c5, 0xc14ffbc4,
+	0xc1400bc5, 0xc0efbfd4, 0xc5233445, 0xc5d0cbc7, 0xcc0178c0, 0xf6e11053,
+	0xc90d1c09, 0xc441145f, 0xc4400218, 0xc4402f7c, 0xc4402f88, 0xc4402f95,
+	0xc4402fa2, 0xc4402faf, 0xc4402fbc, 0xc4402fc9, 0xc4402fde, 0xc4402ff4,
+	0xf470300d, 0xc4517c90, 0xc51248c0, 0xc01936f2, 0xe20f5406, 0xc4511492,
+	0xc9230501, 0xf15bc851, 0xfd501801, 0xc4524a20, 0xcc240445, 0xef214492,
+	0xc06007a1, 0xc92883d5, 0xd0111445, 0xc51248c3, 0xc0197ef2, 0xe20f5406,
+	0xc4511492, 0xc9230101, 0xc05b8851, 0xfd501801, 0xc4524a10, 0xcc140445,
+	0xee214492, 0xc060042d, 0xc92843d5, 0xd0111445, 0xc51248c2, 0xc0f00520,
+	0xc0101ae2, 0xe10f5408, 0xc0011492, 0xd00f1c05, 0xd0111492, 0xc9200fc5,
+	0xc0148051, 0xc0eb880f, 0xfd502001, 0xc4524a10, 0xfc501400, 0xc4524880,
+	0xff0f5101, 0xc04f1492, 0xd2014492, 0xee203c01, 0xc0800418, 0xc92843d5,
+	0xc0500045, 0xc92103c5, 0xfd440445, 0xf6424bf0, 0xc0140092, 0xc8af1c19,
+	0xc5830059, 0xc0616362, 0xc5103c0f, 0xf0710101, 0xd4113459, 0xd4110859,
+	0xff000058, 0xc8024b64, 0xc4401401, 0xf6402e71, 0xc0110092, 0xeec11005,
+	0xe8b11011, 0xe00f540b, 0xf4711492, 0xf4735c22, 0xcc136023, 0xc5527579,
+	0xe475ee47, 0xd640802c, 0xf0711412, 0xcffe1023, 0xc0120264, 0xc7fe1014,
+	0xc991ee47, 0xcd708f47, 0xd7b91c55, 0xc200b247, 0xc0004964, 0xc4099018,
+	0xf8403401, 0xc7a91c3f, 0xc20024c0, 0xc000495c, 0xc7991c09, 0xc20024c0,
+	0xc450495c, 0xc090b540, 0xc093043d, 0xe8708f27, 0xd971ffa4, 0xc0108264,
+	0xc4099022, 0xdcb04001, 0xc1fe1009, 0xc4d1f380, 0xc20026c5, 0xc000495c,
+	0xc097301f, 0xf8007f84, 0xec51307c, 0xd5c08009, 0xc1100012, 0xec735e47,
+	0xc55268d8, 0xe470b4c0, 0xc2c91d7b, 0xc1259020, 0xc1259020, 0xc9030045,
+	0xc114d844, 0xc0bd1c44, 0xc044f844, 0xcc014cc0, 0xf6e11052, 0xc5230409,
+	0xc09db844, 0xc0c39444, 0xc9030045, 0xc114d844, 0xc0bd1c44, 0xc044f844,
+	0xcc214cc0, 0xf6e11052, 0xfd811009, 0xc5230c04, 0xc4414cc2, 0xcca0276e,
+	0xc5330052, 0xc09db844, 0xcc0148d4, 0xf6e11053, 0xc5234009, 0xc09db844,
+	0xc44148d3, 0xcd10276e, 0xf6e11052, 0xc5234809, 0xc09db844, 0xcc4148d6,
+	0xf6e11053, 0xc7ed9009, 0xc1800401, 0xc015e364, 0xcd704c09, 0xc5330052,
+	0xc09db844, 0xc44148cc, 0xcce0276e, 0xf6e11052, 0xc5330009, 0xc44148d5,
+	0xf640276e, 0xc090047e, 0xc8fd900c, 0xc1602402, 0xc115c444, 0xf6404400,
+	0xc010208e, 0xd7111007, 0xc0700011, 0xc44148db, 0xf640276e, 0xc0110051,
+	0xdf211007, 0xc110000b, 0xc2014764, 0xc4401c01, 0xc0002e0c, 0xc51d1c07,
+	0xcbe304b4, 0xcda14cc0, 0xf6e11052, 0xe00f5409, 0xc4411490, 0xfc70111d,
+	0xc441442f, 0xfc702dd8, 0xccd17860, 0xc31f1c52, 0xf6e1105d, 0xc5e30009,
+	0xc5d0cbc7, 0xc09db844, 0xc0c32844, 0xc5f24347, 0xc9030045, 0xc0bd5c44,
+	0xc3024b64, 0xfc501c01, 0xc0024020, 0xd8e11005, 0xe00f540c, 0xc90d1c90,
+	0xf051145f, 0xc0791c33, 0xc070d744, 0xc0edffd4, 0xc0026444, 0xc0830445,
+	0xf4502647, 0xf4402033, 0xc2002035, 0xc4500099, 0xf45020c1, 0xf4402033,
+	0xc2002035, 0xc4500099, 0xc511db47, 0xc0b76044, 0xc5d1df47, 0xc5e1e347,
+	0xcc0148cd, 0xf6e11053, 0xc7750409, 0xc44200b5, 0xc45031ca, 0xc44204b4,
+	0xc45031ca, 0xc511e747, 0xc0b76044, 0xc5d1eb47, 0xc5e1ef47, 0xcc0148cd,
+	0xf6e11053, 0xc7a50409, 0xc20200b9, 0xc45031d8, 0xc0110264, 0xc1fe1016,
+	0xfb088229, 0xd99a1f3b, 0xc4100f90, 0xc2ff1c40, 0xdd811051, 0xc120000b,
+	0xec714a47, 0xdd811051, 0xf7ff500b, 0xc80f1c90, 0xf6e11053, 0xf0711409,
+	0xcd8c9cd7, 0xc0c8b844, 0xc5fc1cba, 0xc0c76020, 0xc8e2ec45, 0xc0c76020,
+	0xcd5c1c45, 0xc4435b27, 0xcc10322e, 0xdb9731b9, 0xdb924345, 0xc5fc1cb6,
+	0xc0c72844, 0xc9330045, 0xc90f7fd4, 0xc5d0cbc7, 0xfc7178c0, 0xc441442f,
+	0xccd02dd8, 0xc5330052, 0xc09db844, 0xc5f24347, 0xc8a2dc45, 0xc0c72844,
+	0xc8c2e045, 0xc0c72844, 0xd7dc9c45, 0xc445fb07, 0xf0700bef, 0xd80c081b,
+	0xf4501401, 0xc451717f, 0xc1960747, 0xc1c60b47, 0xc1b60f47, 0xc008c444,
+	0xd84d1c45, 0xe4211019, 0xcc111400, 0xd803617f, 0xf0562490, 0xd7e91d87,
+	0xc445f4d8, 0xcba032a7, 0xc02fbc44, 0xd8862744, 0xe4462708, 0xd88d141b,
+	0xd7f3041b, 0xf47600d9, 0xcd95f81b, 0xea71117d, 0xcc01140c, 0xd8921061,
+	0xc0f18702, 0xd4113807, 0xff700061, 0xd77d1c45, 0xd6930199, 0xc055a762,
+	0xf642680f, 0xc0100577, 0xc04e1c89, 0xc5fe5589, 0xf0916a47, 0xd74c0169,
+	0xf0707a47, 0xc1ec005a, 0xc5ab1c51, 0xe8714501, 0xc5bb1c4c, 0xc035a762,
+	0xcc103409, 0xd9872598, 0xd98edbd5, 0xc00668c3, 0xd69d882b, 0xc0d02402,
+	0xdc9660c1, 0xf2df5598, 0xd9a30998, 0xf6206c00, 0xc0900569, 0xd983040d,
+	0xfd5661c9, 0xcc166245, 0xc0b0019a, 0xdc9660c1, 0xd7ef5598, 0xd9a30198,
+	0xc1816b47, 0xcc45fcc1, 0xd8923180, 0xe4766b05, 0xc3df1d7e, 0xea71117d,
+	0xd7f3040c, 0xc90600c4, 0xd98c1589, 0xfc75fa47, 0xc445f43d, 0xcc1032a7,
+	0xd803117f, 0xdc95f8c8, 0xc01f557e, 0xc3df1d7e, 0xea71117d, 0xd777400c,
+	0xc095dd40, 0xc0600004, 0xc005a541, 0xd99d1f65, 0xf4711577, 0xcc066577,
+	0xd69d8969, 0xc6703c05, 0xc015df64, 0xf8715801, 0xf9562404, 0xc5a91c5f,
+	0xf005a709, 0xc1e91d74, 0xf0016b07, 0xec71441e, 0xc514045a, 0xec713287,
+	0xd69c1c5b, 0xd9891d02, 0xc1816b47, 0xcc45fcc1, 0xd7e33180, 0xfd55f9c9,
+	0xfc75f804, 0xc445f43d, 0xcc1032a7, 0xd803117f, 0xf0562490, 0xd7e91d98,
+	0xd7d0f7c7, 0xc0ca9c44, 0xcc45fcc1, 0xd7e32180, 0xfd55f9c9, 0xfc75f803,
+	0xc445f43d, 0xdd0032a7, 0xd7750177, 0xc0001009, 0xd6950406, 0xf47e6000,
+	0xc455dd99, 0xc0965540, 0xd1611007, 0xc5000009, 0xc0165762, 0xc4401c09,
+	0xc0002683, 0xd95d8846, 0xc0702402, 0xc09a3444, 0xf620f000, 0xc0900d95,
+	0xea211007, 0xc3200009, 0xc0465762, 0xc4401c09, 0xc00026e4, 0xd95d8828,
+	0xc0702405, 0xc09c9844, 0xf6207800, 0xc0901995, 0xf3711007, 0xc1400009,
+	0xc0865762, 0xc4401c09, 0xc0002738, 0xd95d880a, 0xc0502409, 0xc09d3044,
+	0xc03e1c45, 0xfbde5589, 0xd0162b00, 0xc9063247, 0xd6ac1189, 0xd4201801,
+	0xd743158c, 0xc5163307, 0xf87632c7, 0xf9562404, 0xd8ac006b, 0xc9062e47,
+	0xd6ac1189, 0xd4201001, 0xd8bc1d8b, 0xd8bb1c51, 0xc07f9844, 0xc1862f47,
+	0xc00a0c44, 0xcc060cc6, 0xd8130182, 0xc0cae044, 0xc1863347, 0xcc05fcc0,
+	0xd7e30180, 0xd7d083c7, 0xc0ca9c44, 0xcc05fcc0, 0xd7e30180, 0xc445f4c1,
+	0xcc0032a7, 0xd803017f, 0xcd15f8c3, 0xea71117d, 0xd7f3000c, 0xcc0600c0,
+	0xc30f1d7e, 0xea71117d, 0xd7f3000c, 0xfd7600c0, 0xdc95f824, 0xc14f557e,
+	0xd7d3157e, 0xc0ca9c44, 0xcc05fcc0, 0xd7e30180, 0xc445f4d4, 0xcc0032a7,
+	0xd803017f, 0xd7e7ffc7, 0xc445f4c2, 0xcc0032a7, 0xd803017f, 0xd7e0c3d7,
+	0xcd55f9c9, 0xea71117d, 0xd7f3000c, 0xcc1600c0, 0xc2bf1d7e, 0xea71117d,
+	0xd7f3000c, 0xfd7600c0, 0xcc85fb00, 0xea71117d, 0xd7f3000c, 0xcc1600c0,
+	0xd7e7257e, 0xd7e403d5, 0xd7d09bc7, 0xc0ca9c44, 0xcc05fcc0, 0xd7e30580,
+	0xfd55f9c9, 0xfc75fa0f, 0xc445f426, 0xcc0032a7, 0xd803017f, 0xdc95f8cc,
+	0xc26f1d7e, 0xea71117d, 0xd7f3000c, 0xccc600c0, 0xd7e7257e, 0xd7e403d5,
+	0xd7d09bc7, 0xc0ca9c44, 0xcc05fcc0, 0xd7e33180, 0xfd55f9c9, 0xfc75fa00,
+	0xc445f426, 0xcc0032a7, 0xd803017f, 0xdc95f8cc, 0xf00f557e, 0xc26f1d7e,
+	0xea71117d, 0xd7f3000c, 0xccd600c0, 0xd7e7257e, 0xd7d09bc7, 0xc0ca9c44,
+	0xcc05fcc0, 0xd7e33580, 0xfd55f9c9, 0xfc75f900, 0xc445f426, 0xcc0032a7,
+	0xd803017f, 0xdc95f8cd, 0xe00f557e, 0xc26f1d7e, 0xea71117d, 0xd7f3000c,
+	0xccd600c0, 0xd7e7257e, 0xd7ec03d5, 0xd7d09bc7, 0xc0ca9c44, 0xcc05fcc0,
+	0xd7e33980, 0xfc75f9c9, 0xc445f426, 0xcc0032a7, 0xd803017f, 0xdc95f8ce,
+	0xd00f557e, 0xc26f1d7e, 0xea71117d, 0xd7f3000c, 0xcce600c0, 0xd7e7257e,
+	0xd7e803d5, 0xd7d09bc7, 0xc0ca9c44, 0xcc05fcc0, 0xd7e33980, 0xfd55f9c9,
+	0xfc75fb00, 0xc445f426, 0xcc1032a7, 0xd803057f, 0xcc15f8c7, 0xea71117d,
+	0xd7f3000c, 0xcd1600c0, 0xd7d32d7e, 0xc0ca9c44, 0xc1862f47, 0xcc060cc2,
+	0xd8136d82, 0xc0cae044, 0xd83307c7, 0xcdc608c0, 0xeb811181, 0xd8cd1c0c,
+	0xda92c018, 0xc8009bb5, 0xc02fbc44, 0xc0306f64, 0xcb003001, 0xc26ed5a9,
+	0xfef11080, 0xff300002, 0xc1862f47, 0xd8357f47, 0xcc7608c0, 0xeb811181,
+	0xd60d1c0c, 0xd8230183, 0xc44604c6, 0xf47032b8, 0xcc060d61, 0xd8131582,
+	0xc0cae044, 0xd8358b47, 0xcc4608c0, 0xeb811181, 0xd63d1c0c, 0xd8230183,
+	0xc44604c3, 0xf47032b8, 0xcc060d64, 0xd8130982, 0xc0cae044, 0xcc060cc1,
+	0xd8133582, 0xc0cae044, 0xd83083c7, 0xccc608c0, 0xeb811181, 0xd833000c,
+	0xccb608c0, 0xeb811181, 0xd833000c, 0xcca608c0, 0xeb811181, 0xd833000c,
+	0xcc9608c0, 0xeb811181, 0xd833000c, 0xcc8608c0, 0xeb811181, 0xd833040c,
+	0xcce608c0, 0xeb811181, 0xd833440c, 0xcc0608c0, 0xeb811181, 0xf871140c,
+	0xf9562403, 0xd8ac03bd, 0xd8c91d01, 0xf0462490, 0xc060056a, 0xcc563142,
+	0xd8cc1d74, 0xd8cb1c51, 0xd8901387, 0xf001af95, 0xd8b91d8a, 0xf0462490,
+	0xc040056a, 0xf0762d42, 0xec71458b, 0xd96d918b, 0xc6f02402, 0xc1862f47,
+	0xc44610c1, 0xf64032c5, 0xc090101b, 0xd96d1c08, 0xcfff1d9b, 0xd96d8996,
+	0xc57004ff, 0xc44610d4, 0xf47032c5, 0xcd36341b, 0xec511184, 0xc1bd1c0c,
+	0xd843498e, 0xc0cb1444, 0xd8f06f47, 0xc44610d1, 0xf47032c5, 0xcd06401b,
+	0xec511184, 0xc1bd1c0c, 0xd8433d91, 0xc0cb1444, 0xd9206f47, 0xc4063b64,
+	0xf4702809, 0xfc766d96, 0xc00658ff, 0xd933001a, 0xf47650c4, 0xf640618b,
+	0xc012018e, 0xd833640b, 0xcc0608c0, 0xeb811181, 0xc02f140c, 0xd96d9196,
+	0xc2202404, 0xc1862f47, 0xe4562484, 0xd96d8996, 0xc16004ff, 0xd84087c7,
+	0xc0cb1444, 0xc0106f64, 0xf4702009, 0xfc766d96, 0xfc5658ff, 0xf6465804,
+	0xc0902196, 0xd8922022, 0xfc765a45, 0xc446102b, 0xf62032c5, 0xc0903c1b,
+	0xd96d1c08, 0xcfff1d9b, 0xd96d8996, 0xc08004ff, 0xd9506f47, 0xd96023c5,
+	0xc0165540, 0xd95d892e, 0xd290040f, 0xcff65b62, 0xc9049001, 0xd9691589,
+	0xc1862f47, 0xc0865762, 0xfc704009, 0xf476502a, 0xc4461194, 0xfc5032c5,
+	0xc0006c10, 0xd95d8895, 0xc1002409, 0xd940abc7, 0xd8465347, 0xc0cb1444,
+	0xc1b083c5, 0xf6220800, 0xc0900595, 0xd943700f, 0xd8465347, 0xc0cb1444,
+	0xc1b013c5, 0xf621c000, 0xc0900995, 0xd943700f, 0xd8465347, 0xc0cb1444,
+	0xc1b023c5, 0xf6217800, 0xc0900d95, 0xc2af1c10, 0xd94d1d94, 0xec511184,
+	0xc01f140c, 0xc4b0001b, 0xc0465762, 0xfc704009, 0xf476502a, 0xc4461194,
+	0xfc5032c5, 0xc0006c02, 0xd95d8838, 0xc1b02405, 0xf47650dc, 0xc4461194,
+	0xfc5032c5, 0xfc706c08, 0xf476502a, 0xc4461194, 0xfc5032c5, 0xc0006c04,
+	0xd95d881a, 0xc1002406, 0xd940abc7, 0xd8465347, 0xc0cb1444, 0xc1b023c5,
+	0xf6201c00, 0xc0901d95, 0xc1bd1c02, 0xc1cd1d83, 0xd94d1d82, 0xeb811181,
+	0xc58c200c, 0xcc154244, 0xc1d11178, 0xd783000d, 0xc1863347, 0xfb56a4b0,
+	0xc4420026, 0xf6400bef, 0xc0900c1b, 0xda92c00c, 0xc8009bb5, 0xc02fbc44,
+	0xf47fcc00, 0xcc10618b, 0xe4211019, 0xc1bd9000, 0xc0902401, 0xc44610c1,
+	0xc00032c5, 0xd96307f6, 0xdc9048df, 0xe13f5412, 0xe4720412, 0xd6ad9013,
+	0xc0a02408, 0xc0152b62, 0xc4401409, 0xf4703304, 0xc441516a, 0xf6202586,
+	0xc0100554, 0xd6ad900e, 0xc0702408, 0xd7b093c7, 0xcdc01000, 0xd96d897b,
+	0xc05024ff, 0xd9666f47, 0xd9cd1c45, 0xf871105d, 0xd9dc1c0a, 0xc13c9d87,
+	0xf64162c7, 0xc0104013, 0xc33c140a, 0xec803fa4, 0xc5850458, 0xc26e9e85,
+	0xc02fbc44, 0xf0206f07, 0xc0400458, 0xc45170c1, 0xfc7170c0, 0xc4417423,
+	0xf6402b87, 0xc0910013, 0xd8920415, 0xf0540395, 0xd7f30413, 0xd8004f47,
+	0xfc75fa47, 0xc445f426, 0xfc7032a7, 0xc4417424, 0xf6402b87, 0xc0910013,
+	0xd8920415, 0xf0580395, 0xd7f30413, 0xd8004f47, 0xfc75fa47, 0xc445f426,
+	0xcdb032a7, 0xf871105d, 0xc13d900a, 0xc1f02440, 0xd8604f07, 0xc44174dc,
+	0xf0502b87, 0xc5891c13, 0xf475fcc1, 0xc8460058, 0xc58c1589, 0xfc75fa47,
+	0xc445f426, 0xcdd032a7, 0xf871105d, 0xc13d900a, 0xc2102440, 0xd8604f07,
+	0xc44174de, 0xf0502b87, 0xc5891c13, 0xf475fcc1, 0xc8460058, 0xd00e5589,
+	0xe4716305, 0xc26f1d7e, 0xea71117d, 0xc5d37c0c, 0xc0ae1c44, 0xc4004f64,
+	0xf0708809, 0xfc761813, 0xc4417420, 0xf0502b87, 0xc5891c13, 0xf475fcc1,
+	0xc8460058, 0xe00e5589, 0xe4716305, 0xc26f1d7e, 0xea71117d, 0xc21f1c0c,
+	0xf871105d, 0xc13d900a, 0xc2202440, 0xd8604f07, 0xc5d08bc7, 0xc0ae1c44,
+	0xe4704f05, 0xd7f30458, 0xd8016347, 0xf9562484, 0xc58c1700, 0xfc75fa47,
+	0xc445f426, 0xccc032a7, 0xf871105d, 0xc13d900a, 0xc1302440, 0xf475fcc1,
+	0xc8860013, 0xc13c1589, 0xfc75fa47, 0xc445f426, 0xccd032a7, 0xf871105d,
+	0xc13d900a, 0xc1502440, 0xf475fcc1, 0xc8860013, 0xd00e5589, 0xe4704f05,
+	0xc26f1d7e, 0xea71117d, 0xc5d3280c, 0xc0ae1c44, 0xc4004f64, 0xf0708409,
+	0xccb61813, 0xf871105d, 0xc13c140a, 0xcc116247, 0xc58d1d7f, 0xd8922180,
+	0xf0580395, 0xd7e91c58, 0xd7d09bc7, 0xc0ca9c44, 0xc44174ce, 0xf6402b87,
+	0xc0910013, 0xd7f30415, 0xd8004f47, 0xf9562488, 0xc13c1700, 0xfc75fa47,
+	0xc445f426, 0xccf032a7, 0xf871105d, 0xc13d900a, 0xc1302440, 0xf475fcc1,
+	0xc8c60013, 0xc13c1589, 0xfc75fa47, 0xc445f426, 0xcd0032a7, 0xf871105d,
+	0xc13d900a, 0xc5a02440, 0xd9d0c7c7, 0xc44670d0, 0xfc70390d, 0xcd167432,
+	0xd0d1119c, 0xc33f1c0e, 0xd9c3499d, 0xc0e43444, 0xd9d0d3c7, 0xc44670d3,
+	0xfc70390d, 0xcd467435, 0xd0d1119c, 0xc36f1c0e, 0xd9c3559d, 0xc0e43444,
+	0xd9d0dfc7, 0xc44670d6, 0xfc70390d, 0xcd767438, 0xd0d1119c, 0xc39f1c0e,
+	0xd9c3619d, 0xc0e43444, 0xd9d0ebc7, 0xc44670d9, 0xfc70390d, 0xcda6743b,
+	0xd0d1119c, 0xcc11140e, 0xd9f30d9e, 0xda115347, 0xf4567dc9, 0xc4467c54,
+	0xcc00204f, 0xc59d8859, 0xc6303c05, 0xc015cf64, 0xf8714001, 0xf9562404,
+	0xc5a91c5f, 0xf0016709, 0xc1e91d74, 0xf0016b07, 0xec71441e, 0xc514045a,
+	0xec713287, 0xd892205b, 0xc0968704, 0xc5ad1c22, 0xd7f30418, 0xfc7600c4,
+	0xcc45f852, 0xea71117d, 0xc5bd1c0c, 0xd7f30418, 0xfc7600c4, 0xcc45f8d2,
+	0xea71117d, 0xc100000c, 0xc1816b47, 0xcc45fcc1, 0xd7e34980, 0xc445f4c4,
+	0xdd0032a7, 0xd7350173, 0xc0001009, 0xd9e70008, 0xc0016541, 0xda1c1f9c,
+	0xe47fff94, 0xcc011573, 0xda92c1a0, 0xc8009fb5, 0xc02fbc44, 0xf0462481,
+	0xc0d0059f, 0xc0106f64, 0xfc502001, 0xfc517001, 0xc8268001, 0xd9fc1189,
+	0xf6403c01, 0xc010201b, 0xc02f1407, 0xc050005c, 0xda0007c5, 0xf0462484,
+	0xc0f0059f, 0xc2006f64, 0xfc501c01, 0xc0017004, 0xc01f1405, 0xda0501a0,
+	0xf4501401, 0xc450259e, 0xf62678c1, 0xc0900454, 0xc5472406, 0xf6205c00,
+	0xc0900854, 0xc5472406, 0xf6203800, 0xc0900c54, 0xc5431008, 0xc00151c9,
+	0xcc111403, 0xd9f30d9e, 0xf4567dc9, 0xcc067c54, 0xc59d8859, 0xc1903c0a,
+	0xd8901397, 0xf4917f95, 0xf0016859, 0xc514045a, 0xc44062c7, 0xdc003b93,
+	0xc595059e, 0xc45f9800, 0xf9562481, 0xc23c13f0, 0xf076a647, 0xc0fe1023,
+	0xdd36aa47, 0xc59301a9, 0xf62160c1, 0xc06001aa, 0xdaad904c, 0xc3f00401,
+	0xe4416308, 0xc58c21a8, 0xf0869e44, 0xdb091058, 0xe4416308, 0xc58c21b1,
+	0xf876ca44, 0xf9562404, 0xc59d245f, 0xc5bc005b, 0xc5ab1c51, 0xec714501,
+	0xc18c9c5b, 0xc5ad1c41, 0xc33f1c18, 0xda9d1c5d, 0xf6e1105e, 0xc5bd1c0a,
+	0xf6e11018, 0xec710c0a, 0xc5950418, 0xdc06a9d0, 0xfb300058, 0xda803fc4,
+	0xdb003fc4, 0xdb103fc4, 0xda703fc4, 0xdb203fc4, 0xc096a140, 0xc2dd1c07,
+	0xdaf3017a, 0xda8d1c45, 0xdb0d1da2, 0xdb1d1da3, 0xda7d1da4, 0xdb2d1da5,
+	0xc23c1da6, 0xe47fc384, 0xc23c1dad, 0xe4703f84, 0xc58305aa, 0xf62164c0,
+	0xc06001aa, 0xdaad9067, 0xc5a00401, 0xd8901387, 0xf4917f95, 0xf0007859,
+	0xec71441e, 0xc514045a, 0xf4716ec7, 0xfc70605a, 0xc4417433, 0xf4702b87,
+	0xf646a413, 0xc01005a9, 0xc58d1435, 0xd9e305a2, 0xf626ccc0, 0xc0f009b3,
+	0xdb370417, 0xf846a707, 0xdb3c080c, 0xf4501409, 0xdd16959e, 0xdb3505b3,
+	0xc00679c0, 0xdadd93e8, 0xc0500410, 0xda416345, 0xc206b764, 0xf4502801,
+	0xc0068c58, 0xc58d1405, 0xc59505a6, 0xdc06a9d0, 0xf9800058, 0xc0168940,
+	0xc2d37804, 0xc2c37855, 0xda8d1c45, 0xdb0d1da2, 0xdb1d1da3, 0xda7d1da4,
+	0xdb2d1da5, 0xc23d1da6, 0xc54c1c54, 0xe4703f84, 0xc58305aa, 0xf62164c0,
+	0xc06001aa, 0xdaad901b, 0xc0e00401, 0xe4416308, 0xc58c21a2, 0xf0868e44,
+	0xda491058, 0xdd016541, 0xc58701aa, 0xc45f9000, 0xc1816b47, 0xcc15fcc1,
+	0xd7e30180, 0xc445f4c1, 0xcc5032a7, 0xd803157f, 0xd7e17f47, 0xc445f4c5,
+	0xcc1032a7, 0xd803057f, 0xcc15f8c3, 0xea71117d, 0xc5bd1c0c, 0xd7f30418,
+	0xcc0600c1, 0xd7d3057e, 0xc0ca9c44, 0xcc55fcc5, 0xc5fd1d80, 0xd7d3157e,
+	0xc0ca9c44, 0xcc15fcc1, 0xd7e30d80, 0xc445f4c1, 0xc45032a7, 0xc206a764,
+	0xc4408401, 0xf470409b, 0xcc10605a, 0xd803057f, 0xcc15f8c7, 0xea71117d,
+	0xc5bd1c0c, 0xd7f30418, 0xcc7600c1, 0xd7d3057e, 0xc0ca9c44, 0xf046cf07,
+	0xc07005b1, 0xc1816f47, 0xf4701400, 0xcc00605a, 0xd803017f, 0xd7e083c7,
+	0xd7d083c7, 0xc0ca9c44, 0xda8c1c45, 0xc016bf02, 0xdb334482, 0xf62164c0,
+	0xc0f00859, 0xda8c1c79, 0xf276cf04, 0xdb3c91af, 0xc6803e82, 0xd8901387,
+	0xf4917f95, 0xf0007859, 0xec71441e, 0xc514045a, 0xf4716ec7, 0xfc70605a,
+	0xc4417433, 0xf4702b87, 0xf076a413, 0xc30e11a9, 0xc0904382, 0xcd83200c,
+	0xc5f093d7, 0xfd517dc9, 0xf0717c08, 0xc30e11a9, 0xc0908382, 0xc42f1c0d,
+	0xc24f5cd8, 0xc5f7245f, 0xc5f10bd5, 0xf846a707, 0xc30e0830, 0xfc703409,
+	0xfd7360a5, 0xdc917c24, 0xca5f545f, 0xdb3d1c5f, 0xdb3c1cd7, 0xc0169f04,
+	0xdb911007, 0xc050000f, 0xc0f5b844, 0xdc016541, 0xf86001b3, 0xdaf6a347,
+	0xc58c1c45, 0xc016c704, 0xc5bd1c07, 0xc0500018, 0xc1816b47, 0xfb56a4b0,
+	0xc4420025, 0xf6400bef, 0xc010101b, 0xdac30406, 0xcc001000, 0xdac501ac,
+	0xcc00ac01, 0xdb4301b5, 0xc036d362, 0xcb00540f, 0xc25ed5a9, 0xfef11080,
+	0xc1bd9002, 0xc0400404, 0xd416d541, 0xfea001b4, 0xc036d762, 0xf4503007,
+	0xc4469dab, 0xc0003ed4, 0xdb530004, 0xc5ad1c45, 0xd7f30418, 0xcc3600c1,
+	0xd7d3057e, 0xc0ca9c44, 0xc1816f47, 0xcc15fcc1, 0xd7e30d80, 0xc445f4c1,
+	0xcc0032a7, 0xdb5dc9b5, 0xc0603fe8, 0xc006d541, 0xc5ad1ff9, 0xd7f30418,
+	0xcc7600c1, 0xd7d3057e, 0xc0ca9c44, 0xc1816f47, 0xcc15fcc1, 0xd7e31d80,
+	0xc445f4c1, 0xc45032a7, 0xf846a707, 0xdae91cc0, 0xcc0678d0, 0xdae7541b,
+	0xf0206f07, 0xc08005ae, 0xd41679c0, 0xff60001b, 0xf0469f07, 0xc800059e,
+	0xc1816b47, 0xcc15fcc1, 0xd7e31d80, 0xc445f4c1, 0xf47032a7, 0xcc10605b,
+	0xd803057f, 0xcc15f8c7, 0xea71117d, 0xc5ac1c0c, 0xc0916f02, 0xdb0c1c08,
+	0xc0916304, 0xdb1c1c46, 0xc0116304, 0xc5ad1c0b, 0xc5bd1c18, 0xc18d1c5a,
+	0xd892045b, 0xc096a704, 0xc5ad1c20, 0xd7f30418, 0xfc7600c4, 0xcc45f852,
+	0xea71117d, 0xc5bd1c0c, 0xd7f30418, 0xfc7600c4, 0xcc45f8d2, 0xea71117d,
+	0xdb1c1c0c, 0xc0116304, 0xc5ad1c1b, 0xc5bd1c18, 0xc18d1c5a, 0xc100005b,
+	0xc1816b47, 0xcc45fcc1, 0xd7e34980, 0xc445f4c4, 0xf08032a7, 0xda891058,
+	0xda2d1c45, 0xda3d1da8, 0xda4d1db0, 0xda5d1db1, 0xda6d1da7, 0xdf9111b2,
+	0xfdc1100f, 0xc1c1100f, 0xc5611010, 0xda850010, 0xf4701409, 0xcbe0b57a,
+	0xc0c76020, 0xc5830445, 0xcc06acd0, 0xc59d8859, 0xc3603c02, 0xf046a307,
+	0xc2800458, 0xf0469f07, 0xc2200458, 0xd8901387, 0xf4917f95, 0xf0007859,
+	0xec71441e, 0xc514045a, 0xf4716ec7, 0xfc70605a, 0xc4417433, 0xf4702b87,
+	0xc446a413, 0xdc003e83, 0xdab70058, 0xc0016541, 0xcc1117c9, 0xdab34058,
+	0xf62164c0, 0xc0f00859, 0xda8c1c30, 0xc0116304, 0xc04e1c22, 0xc5fe5589,
+	0xc1e16749, 0xc5107b00, 0xd0116ac7, 0xc5bb1c51, 0xc1816b47, 0xc5d0cfc7,
+	0xc0ae1c44, 0xda904f47, 0xc0fc6044, 0xdc0161c0, 0xc59505ab, 0xc45f3c00,
+	0xcc0160c1, 0xc59d8859, 0xc3d03c02, 0xf0416307, 0xc31005b2, 0xd8901387,
+	0xf4917f95, 0xf0007859, 0xec71441e, 0xc514045a, 0xf4716ec7, 0xcc10605a,
+	0xd803057f, 0xcc15f8c0, 0xea71117d, 0xc5bd1c0c, 0xd7f30418, 0xcc0600c1,
+	0xd7d3057e, 0xc0ca9c44, 0xdc0161c0, 0xc5950458, 0xc45f0800, 0xcc0240c0,
+	0xcd8c1c53, 0xfc41f8cd, 0xfc7360ff, 0xd4014420, 0xc98004d7, 0xc0135f64,
+	0xc4423401, 0xc4402dd8, 0xf07014d5, 0xc7fe10d8, 0xcc117a47, 0xf6e1105d,
+	0xc5d30c09, 0xc09db844, 0xc5e36347, 0xfc4179d6, 0xcc017801, 0xf6e1105d,
+	0xc5d30809, 0xc09db844, 0xc5ec03d7, 0xc5d0c7c7, 0xc09db844, 0xc44240c0,
+	0xc4404536, 0xc4402f47, 0xcc00113e, 0xc5230053, 0xc09db844, 0xc44148c1,
+	0xcc20276e, 0xf6e11052, 0xfd811009, 0xc5230c04, 0xc4414cc2, 0xcca0276e,
+	0xc5330052, 0xc09db844, 0xc44148d4, 0xcd00276e, 0xf6e11052, 0xc5234c09,
+	0xc09db844, 0xc44148d1, 0xcd20276e, 0xf6e11052, 0xc5235809, 0xc4414cc0,
+	0xcd50276e, 0xf6e11052, 0xc5236809, 0xc09db844, 0xc90803d7, 0xd4135dd0,
+	0xf6800051, 0xc35f1c45, 0xc5e3045d, 0xcc0148cd, 0xf6e11053, 0xc90d1c09,
+	0xfc71145f, 0xcc217435, 0xc523345e, 0xc4414cc0, 0xf470276e, 0xc4517c90,
+	0xc5d0d7c7, 0xccd178c4, 0xc5330052, 0xc09db844, 0xc5f24347, 0xc31f1c45,
+	0xf871105d, 0xc13d900a, 0xc4500420, 0xc5d0d3c7, 0xc0ae1c44, 0xc0404f64,
+	0xfd502009, 0xc4417c02, 0xf64010fb, 0xc0902013, 0xc04f5408, 0xcfb1105f,
+	0xc13d9004, 0xc0500410, 0xc5f023d5, 0xc2004f64, 0xfd501401, 0xf6417c10,
+	0xc0101013, 0xc13d9015, 0xc3d00408, 0xc0104f64, 0xfc74f801, 0xc4417435,
+	0xcc002b87, 0xfc711413, 0xc4417431, 0xfc402b87, 0xfc704ffd, 0xc4417434,
+	0xfc402b87, 0xf6404ffe, 0xc0108013, 0xc802a807, 0xc02fbc44, 0xc101fb64,
+	0xfc729809, 0xc4417434, 0xfc402b87, 0xc2004ffc, 0xfc704288, 0xc4417434,
+	0xfc402b87, 0xf6404ffe, 0xc0904013, 0xc31f1c8c, 0xf871105d, 0xc13d900a,
+	0xc0800401, 0xc13ffbc4, 0xc10a2020, 0xc5d0d3c7, 0xc0ae1c44, 0xd9804f07,
+	0xc0901f84, 0xc34f1c6e, 0xf871105d, 0xc7ed900a, 0xc0502410, 0xc13ff7c4,
+	0xc021fb64, 0xf6416c01, 0xc0900813, 0xc7ed9056, 0xc0e00420, 0xc5d0d3c7,
+	0xc0ae1c44, 0xc1300bd5, 0xc10a2020, 0xc0223b64, 0xfc704001, 0xc4417435,
+	0xf6402b87, 0xc0100813, 0xffdf1017, 0xcd511013, 0xc08f540b, 0xc31f1c5f,
+	0xf871105d, 0xc01f540a, 0xe8808013, 0xc35f1c10, 0xf871105d, 0xc13d900a,
+	0xc1100404, 0xc13fefc4, 0xc5d0d3c7, 0xc0ae1c44, 0xc1300bd5, 0xc10a2020,
+	0xe5562881, 0xc7ed905f, 0xf3700404, 0xc5d0d3c7, 0xc0ae1c44, 0xc0104f64,
+	0xf07cb009, 0xf9710018, 0xf9562403, 0xe47407bd, 0xc2ff1c58, 0xf871105d,
+	0xc13d1c0a, 0xc30f1c5a, 0xf871105d, 0xc13d1c0a, 0xc593005b, 0xc0116b64,
+	0xf0704401, 0xc59c0058, 0xfc706052, 0xc4417431, 0xfd502b87, 0xdd004c10,
+	0xc060045a, 0xc0016541, 0xc5932be6, 0xc0116f64, 0xf0704401, 0xc59c0058,
+	0xfc706052, 0xc4417431, 0xfd502b87, 0xdd004c10, 0xc060045b, 0xc0016541,
+	0xe4710be6, 0xece00018, 0xc5d0d3c7, 0xc0ae1c44, 0xc1004f64, 0xfc7e2409,
+	0xc4417431, 0xf6402b87, 0xc0100813, 0xffdf100e, 0xc34f1c13, 0xf871105d,
+	0xc02f540a, 0xc34f1c13, 0xf871105d, 0xc13d900a, 0xca000402, 0xc401fb64,
+	0xc4401401, 0xf6402d35, 0xc010048e, 0xc35f1c14, 0xf871105d, 0xc13d900a,
+	0xc0902401, 0xe5562481, 0xe880805f, 0xc35f1c10, 0xf871105d, 0xffef100a,
+	0xc31f1c13, 0xf871105d, 0xc08f540a, 0xc34f1c13, 0xf871105d, 0xc01f540a,
+	0xc7ed9013, 0xf2802408, 0xc4006307, 0xd8900f97, 0xd01ef795, 0xfc716247,
+	0xc441742f, 0xf4702b87, 0xfc716813, 0xc4417430, 0xf4702b87, 0xcc016c13,
+	0xc5ad9059, 0xc1100401, 0xf0016307, 0xc1814859, 0xc5d0c7c7, 0xc0ae1c44,
+	0xc13013d5, 0xc01169d0, 0xc5950406, 0xccaf9800, 0xc5bd9059, 0xc1100401,
+	0xf0016307, 0xc1814859, 0xc5d0c7c7, 0xc0ae1c44, 0xc13013d5, 0xc0116dd0,
+	0xc5950406, 0xc42f9800, 0xc2006247, 0xfc704288, 0xc4417431, 0xfd502b87,
+	0xc0004c02, 0xc5c3026a, 0xc5d0c7c7, 0xc0ae1c44, 0xc2004f64, 0xfa70ec01,
+	0xd8722d26, 0xc02fbc44, 0xc5d0d3c7, 0xc0ae1c44, 0xc13f3fc4, 0xd9506f07,
+	0xd8400784, 0xc1b007c4, 0xf1506dc3, 0xc139541b, 0xc0904264, 0xc13d9019,
+	0xc1400401, 0xc0a8d444, 0xc0217364, 0xfc702c01, 0xc4417434, 0xfc402b87,
+	0xc4504c33, 0xf47164c3, 0xdd21687f, 0xc0ff105a, 0xc25e9c5a, 0xc800d325,
+	0xc02fbc44, 0xc0406f64, 0xfc401401, 0xc44167fe, 0xf6402a35, 0xc010085c,
+	0xffdf1005, 0xc5a54459, 0xc0016b62, 0xfa703c06, 0xc3fe1c3f, 0xc094444e,
+	0xc094c7fe, 0xfd3003f9, 0xc5d0d3c7, 0xc0ae1c44, 0xc13fcfc4, 0xc0116764,
+	0xf07edc01, 0xf8465413, 0xf2740407, 0xc07e907f, 0xec769585, 0xc078885a,
+	0xc5ac1c06, 0xfc401395, 0xe5504e3b, 0xc59d9013, 0xc1e00402, 0xd9804f07,
+	0xd0101f84, 0xfa41ff27, 0xda862007, 0xe2216ac7, 0xf0701807, 0xc08e545a,
+	0xc137dfc4, 0xc0004e55, 0xdf7f137f, 0xf7a00013, 0xfc7170c0, 0xc4417431,
+	0xf6402b87, 0xc0102013, 0xff7f1008, 0xffd11013, 0xcc011404, 0xc5c301b6,
+	0xc5d0c7c7, 0xc0ae1c44, 0xc4004f64, 0xf641dc01, 0xc0101013, 0xc5d31021,
+	0xc0ae1c44, 0xc0804f64, 0xca804001, 0xc44c0387, 0xca800bef, 0xc44c4387,
+	0xc0000bef, 0xc812ac09, 0xc02fbc44, 0xfc76d8c1, 0xc4417431, 0xfc402b87,
+	0xcb804ffb, 0xd8710b87, 0xc4404f95, 0xcba00bef, 0xc02fbc44, 0xc5806f47,
+	0xc0216364, 0xfd504809, 0xfc716002, 0xc4417431, 0xf6402b87, 0xc0104013,
+	0xc2200015, 0xe4482082, 0xc31f1c58, 0xf871105d, 0xc13d900a, 0xc0402410,
+	0xcb805000, 0xd8710b87, 0xc4404f95, 0xcb900bef, 0xc4416307, 0xfc400bef,
+	0xc4404fef, 0xc450462b, 0xe0862c81, 0xfd524244, 0xfc403810, 0xcc0053fd,
+	0xc90d1c91, 0xcc01145f, 0xc31f1c5c, 0xf871105d, 0xc60f100a, 0xc34f1c13,
+	0xf871105d, 0xc1333c0a, 0xc5d0d7c7, 0xc0ae1c44, 0xc13003c4, 0xc2ff1c45,
+	0xdd811051, 0xc5233c0b, 0xc4414cc0, 0xfd50276e, 0xfc403810, 0xf64053fd,
+	0xc091fc83, 0xc84d902a, 0xc250247f, 0xc7f21764, 0xf6408009, 0xc091fc86,
+	0xc87d901b, 0xc160247f, 0xc7f22364, 0xf6404409, 0xc090fc89, 0xe082000c,
+	0xe4705e47, 0xc1591c16, 0xf070a800, 0xc03e1085, 0xc84c5586, 0xc83c5586,
+	0xf0705e47, 0xc0fe1087, 0xc86c5586, 0xc85c9d84, 0xe47a55b1, 0xc89c1c16,
+	0xd860ff84, 0xd8222315, 0xdb321f27, 0xc1591e95, 0xc14007c5, 0xc14013c5,
+	0xc14ffbc4, 0xc1400bc5, 0xc0efbfd4, 0xcc0148d8, 0xf6e11053, 0xc90d1c09,
+	0xfc71145f, 0xc441442f, 0xcdc02dd8, 0xc5330052, 0xc09db844, 0xc5f24347,
+	0xc5ff83d4, 0xcc0148df, 0xf6e11053, 0xd8b20409, 0xf4717e55, 0xd412405f,
+	0xc8ed9091, 0xc0d00410, 0xc074b044, 0xc510bfc7, 0xc0b76044, 0xcdd02400,
+	0xc5330052, 0xc09db844, 0xcc0148de, 0xf6e11053, 0xc2029c09, 0xfc000099,
+	0xc016d800, 0xc18c1c26, 0xc0af1c40, 0xc00f1c18, 0xc00f1c19, 0xc07f1c1c,
+	0xe311101b, 0xc0af1c00, 0xc00f1c18, 0xc00f1c19, 0xc00f1c1c, 0xe311101b,
+	0xe4710800, 0xf4711418, 0xf646e4da, 0xc01201b7, 0xce0d1c05, 0xf12081b9,
+	0xcdbd1c12, 0xdb7d91b9, 0xc0d00401, 0xdb937347, 0xc026df64, 0xf4701401,
+	0xc206e4e4, 0xf4704b12, 0xf646e4dd, 0xc0100db7, 0xce1d1c0d, 0xdb7d91b9,
+	0xc0500402, 0xdb938b47, 0xc12c4820, 0xdb937b47, 0xc016df64, 0xf4701401,
+	0xc206e4df, 0xf4704b12, 0xc206e4e5, 0xc8004b12, 0xc02e5587, 0xc8336a47,
+	0xc29e5587, 0xc8d36e47, 0xc00e5587, 0xc8237247, 0xc00e5587, 0xc8f37647,
+	0xc02e5587, 0xc8037a47, 0xc00e5587, 0xc8137e47, 0xc81e5587, 0xc8438247,
+	0xc00e5587, 0xc8f38647, 0xc00e5587, 0xc8338a47, 0xc29e5587, 0xc9238e47,
+	0xcc0e5587, 0xc9039247, 0xc3fe5587, 0xc4539647, 0xfc7160c0, 0xc51164da,
+	0xc5a14901, 0xc5acd5a7, 0xf0710101, 0xd4113459, 0xc5850859, 0xc58d8842,
+	0xfec01c18, 0xc93d1c45, 0xdb7d91b9, 0xc2b00480, 0xc406df64, 0xcc105c09,
+	0xdb9731b9, 0xc206df64, 0xfc407409, 0xf876dc1f, 0xdb7c0090, 0xdb9b1c4c,
+	0xf4704400, 0xfc4061b7, 0xfc70601f, 0xc4417432, 0xf4702b87, 0xc206e413,
+	0xc2004b12, 0xc2004b12, 0xc2004b12, 0xc2004b12, 0xc2004b12, 0xf0704b12,
+	0xcffe11b7, 0xc0920264, 0xc4099010, 0xe4701809, 0xc1700076, 0xe470ff84,
+	0xc1100077, 0xfc41e247, 0xc951e07f, 0xcd56df47, 0xc2c91c55, 0xc12c7820,
+	0xc206e4c0, 0xcc104b12, 0xdb7c9db9, 0xee43ffa4, 0xc2d00480, 0xc09082e4,
+	0xcd5b1c0a, 0xcd61d747, 0xfe100096, 0xc40e1287, 0xfa46e655, 0xc7ce1c1f,
+	0xdb9d9280, 0xc0902440, 0xdb97304c, 0xc006e6d5, 0xc75c9c28, 0xdb972c4d,
+	0xc006e6d5, 0xdb972c1f, 0xec76e6d5, 0xc40b9075, 0xee405401, 0xc110041f,
+	0xc09082e4, 0xcc930004, 0xf002ff87, 0xc1fe90c9, 0xcc95044d, 0xc12c4820,
+	0xcc0064c1, 0xc1c3041b, 0xc44071cc, 0xcc200231, 0xc54f1c19, 0xe311101c,
+	0xc33d1400, 0xe311101c, 0xc1930000, 0xd8904f97, 0xd0512395, 0xd0207647,
+	0xc0fa0850, 0xc1dc1c8f, 0xe8068104, 0xd0169c51, 0xf00a1450, 0xda71441d,
+	0xd01076c7, 0xc1db1451, 0xda714501, 0xd0107ac7, 0xc1eb1451, 0xc1c0d347,
+	0xe3111227, 0xc44a1c00, 0xc440486c, 0xf470486c, 0xf4706c1d, 0xc4407034,
+	0xf2700231, 0xc570041e, 0xd01064ca, 0xd0106c52, 0xda910451, 0xc4306ec5,
+	0xc1cb1db5, 0xda314501, 0xec50df25, 0xe311101c, 0xc1e54c00, 0xcc0f9c07,
+	0xc1c30019, 0xc008c444, 0xcc506cca, 0xd8724019, 0xe470eb95, 0xe311101c,
+	0xc1930800, 0xc1b083c7, 0xc44070c0, 0xf4700231, 0xc4407033, 0xc4500231,
+	0xda714501, 0xd0106ec7, 0xc1bb1451, 0xf2514501, 0xc1cb1c37, 0xc008c444,
+	0xc1b31445, 0xf47f3c00, 0xf4708800, 0xcc008c01, 0xc0930008, 0xf8408b07,
+	0xe208a43f, 0xe87273b0, 0xc12e4199, 0xc4510041, 0xc125ac20, 0xc125d020,
+	0xc125f420, 0xc12a8820, 0xc1274820, 0xc1295420, 0xc1296820, 0xc1297c20,
+	0xc1299020, 0xc129a420, 0xc129b820, 0xc129cc20, 0xc129e020, 0xc129f420,
+	0xc12a0820, 0xc12a1c20, 0xc12a2820, 0xc12a4020, 0xc12a5420, 0xc12a6420,
+	0xc12a9420, 0xc12aa420, 0xc12ac820, 0xc12aec20, 0xc12af820, 0xc12b0420,
+	0xc1290820, 0xc12b1020, 0xc12b5420, 0xc1259820, 0xc1259820, 0xc12b7c20,
+	0xc082c420, 0xc0834020, 0xc07f7c20, 0xc1259820, 0xc0c11020, 0xc0c15820,
+	0xc0c21c20, 0xc1259820, 0xc1259820, 0xc02cb020, 0xc02f0820, 0xc0287020,
+	0xc0282c20, 0xc1259820, 0xc1259820, 0xc12b8420, 0xc1259820, 0xc1259820,
+	0xc1259820, 0xc1259820, 0xc1259820, 0xc1259820, 0xc1259820, 0xc1259820,
+	0xc1259820, 0xc1259820, 0xc1259820, 0xc1259820, 0xc1259820, 0xc1259820,
+	0xc1259820, 0xc1259820, 0xf45020c1, 0xf4402033, 0xc4e02035, 0xffff1c47,
+	0xff800008, 0xda7013b7, 0xec707fa5, 0xfea00009, 0xda701fb7, 0xec7013a5,
+	0xfe100009, 0xc13edc80, 0xc48ed5a9, 0xcc008ec7, 0xc2930028, 0xc4408852,
+	0xc0104a27, 0xc0040405, 0xc52407f8, 0xc28d1822, 0xcfff1022, 0xc22d8822,
+	0xc2e024ef, 0xc2214901, 0xdb70a327, 0xf6208ac6, 0xc092f822, 0xc5240421,
+	0xc29d1822, 0xcfff1022, 0xc22d8822, 0xc13024ad, 0xc2214901, 0xdb70a727,
+	0xf6208ac6, 0xc0937822, 0xc0930406, 0xfc7e4400, 0xc00027ff, 0xd892078c,
+	0xcc004a47, 0xc2930028, 0xda704f27, 0xec704f25, 0xc1291c23, 0xc13d1c80,
+	0xe2711022, 0xc0500412, 0xff700101, 0xc2204f47, 0xc220a346, 0xc223ffc4,
+	0xcef08b62, 0xf47f4809, 0xf2708813, 0xec66dc28, 0xc22d8822, 0xfc5024be,
+	0xc2204f47, 0xc220a746, 0xc223ffc4, 0xcad08b62, 0xf47edc09, 0xf2708813,
+	0xec66dc29, 0xc22d8822, 0xfaa024de, 0xf40e9000, 0xfc10a022, 0xfc60a400,
+	0xf490a0d8, 0xf4b0a028, 0xc0a0a429, 0xce5f0008, 0xc00f0428, 0xc23c9c29,
+	0xf9711622, 0xf9562413, 0xc5141448, 0xc23b1da7, 0xec514501, 0xe4044423,
+	0xf3200023, 0xc2608f47, 0xf47c1000, 0xc0009c23, 0xc23d1eff, 0xefa00028,
+	0xc2908f47, 0xf47bd400, 0xc000a823, 0xc23d1ef0, 0xeeb0002b, 0xc090a347,
+	0xf47b9800, 0xc0002429, 0xc2ad1ee1, 0xedc00009, 0xc090af47, 0xf47b5c00,
+	0xc550b423, 0xc2c08f47, 0xf47b3800, 0xc0008423, 0xc21c1ec9, 0xf0701800,
+	0xc2150421, 0xc4d08f27, 0xf47af000, 0xf0708423, 0xc0600021, 0xd4108707,
+	0xec713021, 0xeac00009, 0xc23d1c8c, 0xe47155c4, 0xeab0002c, 0xff70008d,
+	0xff40008e, 0xff10008f, 0xd8308b07, 0xc099899b, 0xf4701c0b, 0xc0002037,
+	0xc44e4292, 0xf97f2800, 0xf9562413, 0xe4741448, 0xe7f00009, 0xc449f400,
+	0xc55004b6, 0xc000b0df, 0xc04d9275, 0xc6c02402, 0xc0801364, 0xf6453009,
+	0xc0901004, 0xc073006a, 0xc0e203d5, 0xdb701b47, 0xf076e4c0, 0xf8465db7,
+	0xe208a40f, 0xe87c8fb0, 0xc12e4199, 0xc4510041, 0xdb90cf45, 0xc076e747,
+	0xc070d744, 0xc0edffd4, 0xc0e083c5, 0xc2011c4e, 0xc2004655, 0xc2004663,
+	0xc2004679, 0xc200468f, 0xc200469d, 0xc200473c, 0xc200473f, 0xc2004708,
+	0xc2004b53, 0xc2001151, 0xc2001164, 0xc2004742, 0xc2004745, 0xc200474b,
+	0xc2004775, 0xf4504748, 0xc006e437, 0xcc3157bf, 0xd00f542c, 0xfc00000e,
+	0xdbb04747, 0xdbbff3c4, 0xc406eb64, 0xc442b809, 0xc0104bbe, 0xfa41107a,
+	0xc0500412, 0xfa800055, 0xc12eb444, 0xdbadffc4, 0xc38e91b5, 0xdbaf1fc4,
+	0xdb26eac5, 0xc0101ee2, 0xc06b8852, 0xee213801, 0xc5200402, 0xc01006e2,
+	0xc03b883c, 0xfd70c401, 0xca66e47f, 0xc12ffc44, 0xf64df000, 0xc0900810,
+	0xc11d9005, 0xfd511401, 0xfc503840, 0xfc404001, 0xf276ebbf, 0xc0502dbb,
+	0xdba103c5, 0xc04c9c45, 0xd986ef07, 0xdb80e384, 0xe220e3a4, 0xc40d1445,
+	0xc0e00440, 0xfb705000, 0xfa569c04, 0xdb9b1c1f, 0xfc6000a7, 0xdb96ef47,
+	0xc1303444, 0xc55cf400, 0xc000b0c4, 0xfad11338, 0xc80f1412, 0xff8f11ba,
+	0xdfce91ba, 0xdba91481, 0xdbbe41b1, 0xd00f144d, 0xf21001ba, 0xdb91ffc4,
+	0xf076e5c1, 0xf84661bb, 0xd88a1438, 0xfc46e645, 0xf4504003, 0xfc5041b9,
+	0xc4504002, 0xc12ef844, 0xf0702409, 0xdbad91ba, 0xc0c02480, 0xc12e9044,
+	0xc44d3c09, 0xc0004bad, 0xfad113b0, 0xc07e1012, 0xc0101e62, 0xdba506ea,
+	0xc35c9101, 0xfd5eec00, 0xc5503810, 0xc440b0c7, 0xc0002f37, 0xc3c13ad8,
+	0xcae3b46a
+};
\ No newline at end of file
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_sensor.c OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_sensor.c
--- OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_sensor.c	1969-12-31 16:00:00.000000000 -0800
+++ OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_sensor.c	2018-06-28 15:08:31.074008787 -0700
@@ -0,0 +1,232 @@
+/* AAPL CORE Revision: 2.5.3
+ *
+ * Copyright (c) 2014-2017 Avago Technologies. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/** @file   sensor.c
+ ** @brief  Functions for accessing Avago sensors (for temperature, voltage, etc.).
+ ** @defgroup Sensor Sensor API for Measuring Temperature and Voltage
+ ** @{
+ **/
+
+#define AAPL_ENABLE_INTERNAL_FUNCTIONS
+#include <common.h>
+#include <malloc.h>
+#include "avago.h"
+#include "avago_sensor.h"
+#include "avago_sbus.h"
+#include "avago_logging.h"
+
+#define AAPL_LOG_PRINT5 if(ah->debug >= 5) avago_log_printf
+
+/** @brief Prepare sensor for measurement */
+static void initialize_sensor(
+    struct avago_hdl *ah,   /**< [in] Pointer to avago_hdl structure. */
+    uint32_t addr,      /**< [in] Sensor sbus address. */
+    uint32_t frequency) /**< [in] Sensor clock input frequency in Hertz. */
+                    /**<      If non-zero, configures the sensor, */
+                    /**<      which only need be done once. */
+{
+    avago_sbus_wr(ah, addr, 0x00, 0x01);
+    if( frequency > 0 )
+    {
+        uint32_t divider = (frequency + 1000000) / 2000000;
+        avago_sbus_wr(ah, addr, 0x01, divider & 0x03FF);
+    }
+    if (avago_get_process_id(ah, addr) == AVAGO_PROCESS_B)
+    {
+        avago_sbus_wr(ah, addr, 0x06, 0x4fe4);
+        avago_sbus_wr(ah, addr, 0x07, 0xb5dd);
+        avago_sbus_wr(ah, addr, 0x08, 0x1e);
+        avago_sbus_wr(ah, addr, 0x0b, 0x07);
+        avago_sbus_wr(ah, addr, 0x0c, 0x5e70);
+        avago_sbus_wr(ah, addr, 0x0e, 0x2a);
+        avago_sbus_wr(ah, addr, 0x10, 0x5);
+        /*//avago_sbus_wr(ah, addr, 0x13, 0x0); */
+        /*//avago_sbus_wr(ah, addr, 0x14, 0x5); */
+    }
+}
+
+/** @brief   Starts a temperature measurement.
+ ** @details Use this function to start measurements on multiple devices.
+ ** @details Note that each device (sensor sbus address) can perform only
+ **          one measurement (voltage or temperature) at a time.
+ ** @see avago_sensor_wait_temperature(), avago_sensor_get_temperature().
+ **/
+void avago_sensor_start_temperature(
+    struct avago_hdl *ah,   /**< [in] Pointer to avago_hdl structure. */
+    uint32_t addr,      /**< [in] Sensor sbus address.  Chip/ring broadcast OK. */
+    int sensor,     /**< [in] Which sensor to access. A value of 0 selects */
+                    /**<      the main sensor. Values of 1 through 8 */
+                    /**<      select remote sensors 0 through 7. */
+    uint32_t frequency) /**< [in] Sensor clock input frequency in Hertz. */
+                    /**<      If non-zero, configures the sensor, */
+                    /**<      which only need be done once. */
+{
+    initialize_sensor(ah, addr, frequency);
+    if( sensor > 8 ) sensor = 0;
+    avago_sbus_wr(ah, addr, 0x03, 0x01 << sensor );
+    avago_sbus_wr(ah, addr, 0x00, 0x02);
+}
+
+/** @brief   Performs a blocking read on a temperature sensor, which is
+ **          assumed to be properly initialized.
+ ** @return  On success, returns the temperature in milli-degrees C.
+ ** @return  On error, decrements ah->return_code and returns -1000000.
+ ** @see avago_sensor_start_temperature(), avago_sensor_get_temperature().
+ **/
+int avago_sensor_wait_temperature(
+    struct avago_hdl *ah,   /**< [in] Pointer to avago_hdl structure. */
+    uint32_t addr,      /**< [in] Sensor sbus address. */
+    int sensor)     /**< [in] Which sensor to access. A value of 0 selects */
+                    /**<      the main sensor. Values of 1 through 8 */
+                    /**<      select remote sensors 0 through 7. */
+{
+    int i;
+    for( i = 0; i < 16; i++ )
+    {
+        int data;
+        if( i > 0 ) mdelay(5);
+        data = avago_sbus_rd(ah, addr, 65 + sensor);
+        if( data & 0x8000 )
+        {
+            int temp;
+            if( data & 0x800 )
+                temp = data | ~0x7ff;
+            else
+                temp = data & 0x7ff;
+            temp *= 125;
+            AAPL_LOG_PRINT5(ah, AVAGO_DEBUG5, __func__, __LINE__, "Temp = %7d mC (data=0x%x, %d reads)\n", temp, data, i+1);
+            return temp;
+        }
+    }
+
+    avago_fail(ah, __func__, __LINE__, "SBus 0x%02x, Temperature conversion failed, returning -1000000 after %d reads.\n",addr, i);
+    return -1000000;
+}
+
+
+/** @brief   Performs a temperature measurement.
+ ** @details Combines the start and wait functions into one blocking operation.
+ ** @return  On success, returns the temperature in milli-degrees C.
+ ** @return  On error, decrements ah->return_code and returns -1000000.
+ ** @see     avago_sensor_start_temperature(), avago_sensor_wait_temperature().
+ ** @see     avago_sensor_get_voltage().
+ **/
+int avago_sensor_get_temperature(
+    struct avago_hdl *ah,   /**< [in] Pointer to avago_hdl structure. */
+    uint32_t addr,      /**< [in] Sensor sbus address. */
+    int sensor,     /**< [in] Which sensor to access. A value of 0 selects */
+                    /**<      the main sensor. Values of 1 through 8 */
+                    /**<      select remote sensors 0 through 7. */
+    uint32_t frequency) /**< [in] Sensor clock input frequency in Hertz. */
+                    /**<      If non-zero, configures the sensor, */
+                    /**<      which only need be done once. */
+{
+    int temp;
+    avago_sensor_start_temperature(ah, addr, sensor, frequency);
+    temp = avago_sensor_wait_temperature(ah, addr, sensor);
+    return temp;
+}
+
+
+/** @brief   Starts a voltage measurement.
+ ** @details Use this function to start measurements on multiple devices.
+ ** @details Note that each device (sensor sbus address) can perform only
+ **          one measurement (voltage or temperature) at a time.
+ ** @see     avago_sensor_wait_voltage(), avago_sensor_get_voltage().
+ **/
+void avago_sensor_start_voltage(
+    struct avago_hdl *ah,   /**< [in] Pointer to avago_hdl structure. */
+    uint32_t addr,      /**< [in] Sensor sbus address.  Chip/ring broadcast OK. */
+    int sensor,     /**< [in] Which sensor to access.  A value of 0 selects */
+                    /**<      the VDD voltage, 1 selects CORE_VDD_VIN, and */
+                    /**<      values [2..7] select SENSOR_A2D_VIN[0..5] */
+    uint32_t frequency) /**< [in] Sensor clock input frequency in Hertz. */
+                    /**<      If non-zero, configures the sensor, */
+                    /**<      which only need be done once. */
+{
+    if( sensor > 7 ) sensor = 0;
+    initialize_sensor(ah, addr, frequency);
+    avago_sbus_wr(ah, addr, 0x03, 0x200 << sensor );
+    avago_sbus_wr(ah, addr, 0x00, 0x02);
+}
+
+/** @brief   Performs a blocking read on a voltage sensor, which is
+ **          assumed to be properly initialized.
+ ** @return  On success, returns the voltage in mV.
+ ** @return  On error, decrements ah->return_code and returns -1.
+ ** @see     avago_sensor_start_voltage(), avago_sensor_get_voltage().
+ **/
+int avago_sensor_wait_voltage(
+    struct avago_hdl *ah,   /**< [in] Pointer to avago_hdl structure. */
+    uint32_t addr,      /**< [in] Sensor sbus address. */
+    int sensor)     /**< [in] Which sensor to access.  A value of 0 selects */
+                    /**<      the VDD voltage, 1 selects CORE_VDD_VIN, and */
+                    /**<      values [2..7] select SENSOR_A2D_VIN[0..5] */
+{
+    int i;
+    for( i = 0; i < 8; i++ )
+    {
+        uint32_t data;
+        if( i > 0 ) ms_sleep(4);
+        data = avago_sbus_rd(ah, addr, 74 + sensor);
+        if( data & 0x8000 )
+        {
+            uint32_t avdd = (data & 0xfff) / 2;
+            AAPL_LOG_PRINT5(ah, AVAGO_DEBUG5, __func__, __LINE__, "Voltage = %4d mV (data=0x%x, %d reads)\n",avdd,data,i+1);
+            return avdd;
+        }
+    }
+    return avago_fail(ah, __func__, __LINE__, "Voltage conversion failed, returning -1 after %d reads.\n",i);
+}
+
+/** @brief   Performs a voltage measurement.
+ ** @details Combines the start and wait functions into one blocking operation.
+ ** @return  On success, returns the voltage in mV.
+ ** @return  On error, decrements ah->return_code and returns -1.
+ ** @see     avago_sensor_start_voltage(), avago_sensor_wait_voltage().
+ ** @see     avago_sensor_get_temperature().
+ **/
+int avago_sensor_get_voltage(
+    struct avago_hdl *ah,   /**< [in] Pointer to avago_hdl structure. */
+    uint32_t addr,      /**< [in] Sensor sbus address. */
+    int sensor,     /**< [in] Which sensor to access.  A value of 0 selects */
+                    /**<      the VDD voltage, 1 selects CORE_VDD_VIN, and */
+                    /**<      values [2..7] select SENSOR_A2D_VIN[0..5] */
+    uint32_t frequency) /**< [in] Sensor clock input frequency in Hertz. */
+                    /**<      If non-zero, configures the sensor, */
+                    /**<      which only need be done once. */
+{
+    int volt;
+    avago_sensor_start_voltage(ah, addr, sensor, frequency);
+    volt = avago_sensor_wait_voltage(ah, addr, sensor);
+    return volt;
+}
+
+
+/** @} */
+
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_sensor.h OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_sensor.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_sensor.h	1969-12-31 16:00:00.000000000 -0800
+++ OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_sensor.h	2018-06-28 15:08:31.074008787 -0700
@@ -0,0 +1,46 @@
+/* AAPL CORE Revision: 2.5.3
+ *
+ * Copyright (c) 2014-2017 Avago Technologies. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* AAPL (ASIC and ASSP Programming Layer) sensor functions */
+
+/** Doxygen File Header
+ ** @file
+ ** @brief Function definitions for temperature and voltage sensor.
+ **/
+
+#ifndef AAPL_SENSOR_H_
+#define AAPL_SENSOR_H_
+
+/* Sensor functions: */
+void avago_sensor_start_temperature(struct avago_hdl *aapl, uint32_t addr, int sensor, uint32_t frequency);
+int  avago_sensor_wait_temperature(struct avago_hdl *aapl, uint32_t addr, int sensor);
+int  avago_sensor_get_temperature(struct avago_hdl *aapl, uint32_t addr, int sensor, uint32_t frequency);
+void avago_sensor_start_voltage(struct avago_hdl *aapl, uint32_t addr, int sensor, uint32_t frequency);
+int  avago_sensor_wait_voltage(struct avago_hdl *aapl, uint32_t addr, int sensor);
+int  avago_sensor_get_voltage(struct avago_hdl *aapl, uint32_t addr, int sensor, uint32_t frequency);
+
+#endif
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_serdes_0x4064_0241.h OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_serdes_0x4064_0241.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_serdes_0x4064_0241.h	1969-12-31 16:00:00.000000000 -0800
+++ OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_serdes_0x4064_0241.h	2018-06-28 15:08:31.076008789 -0700
@@ -0,0 +1,683 @@
+static const uint32_t avago_serdes_4064_0241_rom[] = {
+	0xc0a00e8c, 0xc03fe800, 0xc0219040, 0xc3ff1c41, 0xe0030000, 0xf6480307,
+	0xc091002b, 0xf972800b, 0xd1113774, 0xc097fe72, 0xc00f23fc, 0xffff3a1e,
+	0xe1fd221f, 0xe1dd3a1d, 0xe21d3a21, 0xe1cd3a1c, 0xffdf1e20, 0xc20f1e3d,
+	0xc77f1e3e, 0xe023022d, 0xc029f444, 0xc30c0fd7, 0xe360cb47, 0xc9084fb7,
+	0xc003b844, 0xf87813b7, 0xcee1107c, 0xf9729000, 0xcee1127c, 0xe30f5400,
+	0xe1dd1632, 0xe21ede32, 0xc4462c81, 0xfb7000fc, 0xcd811080, 0xc0ce1400,
+	0xc44f3f84, 0xfc500102, 0xfb708440, 0xc21e1c20, 0xcee11189, 0xc0830000,
+	0xcc0014c0, 0xc003000b, 0xc27083c5, 0xf6415055, 0xc2980200, 0xc5402bbc,
+	0xc4080364, 0xc0b2fc29, 0xe00d9054, 0xd5a0a500, 0xc4415003, 0xc5500451,
+	0xc038ff64, 0xc4404801, 0xc2900655, 0xc4400f00, 0xe270064a, 0xdba92726,
+	0xc03c0029, 0xc00f7fc4, 0xe0050055, 0xf64f2809, 0xc0900e3f, 0xc4e13fc5,
+	0xf87f0400, 0xe0208080, 0xc2fe1c01, 0xfff02511, 0xd1115045, 0xc45ff809,
+	0xc0039844, 0xc540cb07, 0xce611045, 0xc33c1c00, 0xc5511454, 0xd400c2c7,
+	0xffe02435, 0xce611045, 0xc33c1400, 0xc4404800, 0xf06000e6, 0xc0b00033,
+	0xce611208, 0xc33c1000, 0xc30b1c55, 0xf450c647, 0xd400c21d, 0xffe02435,
+	0xc3087746, 0xc4011454, 0xc0b0d940, 0xd4b11020, 0xe1fd1000, 0xfeff1036,
+	0xc4427c36, 0xc00000cf, 0xd4010010, 0xc0c00c36, 0xc0052c44, 0xc3687745,
+	0xc36fbfc4, 0xe2bc9c54, 0xd3300fa4, 0xca103809, 0xec4aa1aa, 0xc4423c21,
+	0xea8000cf, 0xc42086c5, 0xc8815445, 0xc36043c5, 0xfc4dfc00, 0xf2709bfe,
+	0xc07e922c, 0xc01006e6, 0xd2711005, 0xf6411400, 0xc0900a33, 0xe81d1c0d,
+	0xe0f11280, 0xc0502402, 0xc0840444, 0xe008cb74, 0xfd729401, 0xc44a2a00,
+	0xc44005a2, 0xc0900a0f, 0xe3411005, 0xe21edc09, 0xc038af64, 0xc8301c09,
+	0xcee1118b, 0xe00e6000, 0xfb78ca44, 0xd8924621, 0xc444a385, 0xc83000ee,
+	0xc003f044, 0xc44883b7, 0xd97000d8, 0xc0901e64, 0xc0024405, 0xfb720403,
+	0xc4462621, 0xf64000fc, 0xc0904246, 0xe21edc02, 0xc4463481, 0xc81000ee,
+	0xcee11189, 0xed7e1c00, 0xc003f444, 0xc038af64, 0xfb702409, 0xd8b20621,
+	0xc003f044, 0xc200af64, 0xca308009, 0xc038af64, 0xc4401801, 0xca002564,
+	0xd9794707, 0xe2003f84, 0xc4401401, 0xf27000c8, 0xc1fe9251, 0xc4401401,
+	0xc44003f1, 0xf6400113, 0xc0140232, 0xfc111005, 0xff0f1000, 0xc01f162d,
+	0xc26d9026, 0xdae00402, 0xc0162444, 0xf87c03b7, 0xed700020, 0xc0b0db07,
+	0xd13113ea, 0xfe500000, 0xf27fff87, 0xc07e922c, 0xc1a00531, 0xe32803d5,
+	0xc8001800, 0xc1100531, 0xc44817b7, 0xfb700102, 0xd0211222, 0xe51edc00,
+	0xc0040844, 0xd00853b7, 0xc4402809, 0xfc400102, 0xc000877b, 0xc84f16b4,
+	0xeaf00021, 0xc028cf64, 0xf4703409, 0xc44a0282, 0xc0900a0f, 0xd2111005,
+	0xe2dc1c08, 0xf861c384, 0xc4a00410, 0xc200af64, 0xfb711409, 0xd28e1c71,
+	0xc003b844, 0xc44da387, 0xf87000fd, 0xcfd112d7, 0xf0728400, 0xc30e122b,
+	0xcac00c01, 0xf8495b07, 0xc018801f, 0xdf811005, 0xf2720001, 0xc30e922b,
+	0xc090c3a2, 0xdab2840e, 0xc24b12a8, 0xccf1108f, 0xec5aa000, 0xe56c9c24,
+	0xc7fe91b7, 0xc0500620, 0xc017ec44, 0xc0283c44, 0xcc001c09, 0xda21128a,
+	0xff611001, 0xf0ff1000, 0xe0f1122d, 0xc0502402, 0xc096ac44, 0xc1c87745,
+	0xf0487707, 0xc0700633, 0xc441c7a7, 0xfc5000ee, 0xc4409802, 0xc2000451,
+	0xc5500589, 0xc27fbfc4, 0xc26ff7c4, 0xc029ff64, 0xfc402001, 0xc449fffd,
+	0xf4400596, 0xfc40721f, 0xfc4803bf, 0xcc0b779f, 0xca0152e6, 0xc2062481,
+	0xc44000ee, 0xf8700315, 0xf43113ff, 0xc22e9c00, 0xc0040820, 0xd89204a0,
+	0xc003b820, 0xf4311080, 0xf00edc00, 0xc4408387, 0xf64000ee, 0xc0100824,
+	0xf05e6406, 0xf9701000, 0xe2c11200, 0xc22e9c01, 0xc0040844, 0xc028cb64,
+	0xc4401401, 0xc0000695, 0xc61e9cc1, 0xc0040844, 0xd02110a5, 0xc72e9c00,
+	0xc0040844, 0xc443c7a7, 0xf8500102, 0xc202c404, 0xf6400102, 0xc0900a2c,
+	0xe34d92c3, 0xc5800401, 0xc0058420, 0xc27ffbc4, 0xc028d364, 0xc0013401,
+	0xe11edee4, 0xc0037c44, 0xd4003f84, 0xc0402e39, 0xd4004385, 0xc0402e37,
+	0xc4408385, 0xf0700102, 0xc0402e39, 0xf8440608, 0xf2760c1f, 0xc0402e37,
+	0xfa4486a8, 0xd84a140f, 0xe3807fc4, 0xc178e362, 0xca10140b, 0xf05a15ad,
+	0xe38caa38, 0xe85023a4, 0xc44843b7, 0xf4700102, 0xf478ea37, 0xf478f238,
+	0xc458ee39, 0xc2187345, 0xe1cc2045, 0xcc008644, 0xc22c1e40, 0xe4500784,
+	0xe4050a40, 0xd0090364, 0xca1fac09, 0xc00fc444, 0xf2790307, 0xf84a1822,
+	0xfee00401, 0xe2bc1ca2, 0xc0100f84, 0xe622a808, 0xc0300403, 0xe40a24a5,
+	0xc84e1e40, 0xc0180820, 0xd8b208a0, 0xc0908304, 0xd89207c1, 0xc003f020,
+	0xf646a4a1, 0xc0100a34, 0xe2cd9018, 0xc1600420, 0xc108b364, 0xf6402401,
+	0xc0120232, 0xc070000c, 0xc408cb64, 0xec501401, 0xf0911424, 0xffb00c24,
+	0xc24b12a8, 0xe13edc45, 0xc048d364, 0xf0705c09, 0xc0a60a33, 0xc40f1407,
+	0xc0500021, 0xc21effc4, 0xcfc11082, 0xc2022000, 0xc82000ee, 0xc003b844,
+	0xc21effc4, 0xcfc08088, 0xf6415400, 0xc0100826, 0xc24d9027, 0xc0702402,
+	0xc0409764, 0xf0907409, 0xc0400c1c, 0xf6405c0a, 0xc09046dd, 0xc10f1412,
+	0xe34d9027, 0xc0500440, 0xc24dffc4, 0xc25023c5, 0xf6404000, 0xc0110234,
+	0xc80f1405, 0xfeff1024, 0xc10f1427, 0xc4515026, 0xc0109b64, 0xfc502001,
+	0xc448c804, 0xc9f00152, 0xe448218a, 0xe5091243, 0xf2690f27, 0xf1a00650,
+	0xe5090f47, 0xe0861c87, 0xf6408244, 0xc0100826, 0xc08f170d, 0xee408232,
+	0xe33d9000, 0xc0400408, 0xfc588307, 0xe4703001, 0xd8d20c1b, 0xc4407244,
+	0xca3004cf, 0xc1fb15a8, 0xcfff1045, 0xc442141f, 0xfd5000cf, 0xfb707d00,
+	0xe00e5f00, 0xc003b844, 0xe521ffc7, 0xe5254455, 0xd4001801, 0xffa02c1e,
+	0xc4480397, 0xfc4000fc, 0xc4507eff, 0xf078b327, 0xc04b922d, 0xe8603409,
+	0xc0101f84, 0xc07b900f, 0xc000c801, 0xc07e1039, 0xe2cfe3c4, 0xf278b245,
+	0xe2dc1e2c, 0xc09102e4, 0xe64a1816, 0xc1800470, 0xc011c3a4, 0xc026a829,
+	0xee41102e, 0xf1511000, 0xc0900000, 0xfc41c384, 0xe458b38f, 0xe2cd1e2c,
+	0xe271162d, 0xc008c044, 0xc0058444, 0xc44f4800, 0xc4400152, 0xc0000222,
+	0xf1b113ca, 0xe5511000, 0xfe500000, 0xc0100844, 0xc00b9044, 0xc00c2044,
+	0xfa7f6800, 0xc01e1080, 0xc8204401, 0xc003b844, 0xcfc11081, 0xc04f1400,
+	0xc08f1424, 0xf6611425, 0xc010822e, 0xc4420810, 0xc81000fc, 0xc003b844,
+	0xc24fefc4, 0xc25fdfc4, 0xe48c2045, 0xd5a0819e, 0xc20c1c01, 0xe661c384,
+	0xc0700410, 0xc209fcc2, 0xfc5004bc, 0xcc003001, 0xccf1101b, 0xffef1001,
+	0xca11140c, 0xc44a2b25, 0xe47000d8, 0xfe0e5e4f, 0xc003b844, 0xe8ac94a0,
+	0xc4450387, 0xc44000ee, 0xc84000cd, 0xc003b844, 0xc0033444, 0xc4410387,
+	0xf87000fc, 0xccf11106, 0xd00e1c00, 0xc003f044, 0xc4426787, 0xca1000cf,
+	0xf07a2b25, 0xd021124f, 0xf2528000, 0xc442128a, 0xf87000fc, 0xe0f11099,
+	0xc0402402, 0xc20fff99, 0xc41000cf, 0xfa48db27, 0xc434d00c, 0xc0025045,
+	0xc5524003, 0xc301c7d7, 0xc5501800, 0xc30887d7, 0xe6a0d347, 0xd400d0c0,
+	0xffe02435, 0xc310cb47, 0xc3087745, 0xf740c646, 0xc0180030, 0xc3191807,
+	0xc0034844, 0xff302531, 0xc3087746, 0xc349ab47, 0xf6411454, 0xc0110233,
+	0xe00edc06, 0xc45a12a8, 0xc4015627, 0xf0080f97, 0xd4113602, 0xe02d8a02,
+	0xc0402418, 0xc42808c0, 0xc5511454, 0xc303cbc7, 0xc090d540, 0xc32c1ffe,
+	0xdaa28445, 0xc458cf24, 0xcdee5c40, 0xc39e1587, 0xc428db06, 0xe22c9c45,
+	0xc011ffa4, 0xf071542c, 0xc3430034, 0xc3550040, 0xfc7ff809, 0xf870c071,
+	0xc32d1cd7, 0xe1dd1431, 0xe3d50430, 0xd5301c09, 0xe1cd1a3d, 0xc3191831,
+	0xff402531, 0xc3087746, 0xc3491c42, 0xc8311454, 0xe1dd158d, 0xeddd9233,
+	0xc0500404, 0xc45c5645, 0xc201c7a7, 0xc83000ee, 0xeddd918d, 0xc0600404,
+	0xf1591208, 0xe1dca045, 0xfa78cec4, 0xcfc08071, 0xc0148000, 0xef410427,
+	0xc0a00600, 0xc821cfa7, 0xc003b844, 0xfa702400, 0xffde1c73, 0xc003f444,
+	0xd80b9043, 0xee405801, 0xc1702480, 0xe3200bc5, 0xc01a5444, 0xfc404800,
+	0xc448cbfd, 0xc00006a7, 0xe661100a, 0xc0500001, 0xc4010c81, 0xc03f5020,
+	0xc3affbc4, 0xcc59c247, 0xd0099275, 0xd4801001, 0xfbff1275, 0xc03e100c,
+	0xc3a91d87, 0xc0c103c5, 0xe6f91c42, 0xd0010843, 0xe470200b, 0xe471083c,
+	0xe471083b, 0xe4710839, 0xc3a50838, 0xe6fc1c41, 0xc3a54840, 0xc3a9d745,
+	0xffef1045, 0xe7191c3d, 0xe649d4c5, 0xc0400500, 0xfc49d548, 0xf840337f,
+	0xe4761c03, 0xc80f143d, 0xe471080c, 0xc4210e6f, 0xc0802d00, 0xc420fe47,
+	0xc420fa47, 0xc420e647, 0xd420e247, 0xf071043d, 0xd521026f, 0xe75d143d,
+	0xfc41143d, 0xcc1103fe, 0xfcff1041, 0xc415440c, 0xe479d4c0, 0xc4030274,
+	0xe2700f84, 0xf84a15a0, 0xe4561ffd, 0xc4191440, 0xfc59d645, 0xfc703030,
+	0xd420e7ff, 0xc4054840, 0xf6410144, 0xc0140274, 0xc4052004, 0xe4710c42,
+	0xe72b1e73, 0xc01fc444, 0xea86aca3, 0xf0712ac4, 0xc30e1274, 0xc4a91587,
+	0xe74c1ca1, 0xd930c384, 0xc0100262, 0xc0198808, 0xc0001c01, 0xc0028006,
+	0xdad28803, 0xca39d6c5, 0xf849d307, 0xe626440c, 0xc0800401, 0xc0100a62,
+	0xc0600007, 0xc03000a1, 0xec5694a2, 0xe74dd275, 0xc0e00600, 0xf279cf07,
+	0xc4010672, 0xc419d747, 0xc4510141, 0xc419d747, 0xc2010141, 0xc4200087,
+	0xe6e91c43, 0xfff99042, 0xe470200b, 0xe4710843, 0xe4710842, 0xe4710839,
+	0xc4050838, 0xf0710152, 0xc401066e, 0xd4015445, 0xc090066b, 0xc019af22,
+	0xc5428407, 0xe6bb1c45, 0xc0902264, 0xc123006e, 0xe6cb1c43, 0xe6db1c43,
+	0xe009d227, 0xfa408809, 0xc0db1c06, 0xffdf1227, 0xffcf100c, 0xc01e1018,
+	0xd4206245, 0xe471080c, 0xe4710814, 0xc0b48013, 0xe4710808, 0xe4710811,
+	0xc50f1c10, 0xc1250a7e, 0xc8003541, 0xc01402e4, 0xd5142003, 0xc070067e,
+	0xc4004b64, 0xd52fe409, 0xc0d54412, 0xc01202e4, 0xe4541003, 0xe6dc1c12,
+	0xe6cc1c40, 0xc03aa440, 0xe7e54417, 0xf6401c03, 0xc0920012, 0xc26d93f9,
+	0xc0700402, 0xc0409764, 0xd4101c09, 0xc5428012, 0xeddd9045, 0xff800407,
+	0xeddff3c4, 0xedd803d5, 0xe00103c5, 0xc0295420, 0xe8705e47, 0xfa70180b,
+	0xc03003ff, 0xcffe11bb, 0xc0120264, 0xf00e1404, 0xc0b04780, 0xca010418,
+	0xc14e0131, 0xc41ff403, 0xea8698bf, 0xd86062c4, 0xc8306245, 0xc179158d,
+	0xd0310c42, 0xda762921, 0xc1a91e85, 0xe47fff87, 0xe4562c19, 0xc17c1c18,
+	0xc039899d, 0xe6203801, 0xc1300401, 0xc0900a62, 0xcaae9c37, 0xcc103400,
+	0xd8b23c19, 0xc1891208, 0xfa70e400, 0xfa710455, 0xcd811071, 0xc1002c00,
+	0xcf2e9c40, 0xc0036044, 0xfa410d98, 0xc0402401, 0xc4300786, 0xc0100664,
+	0xcffe9804, 0xe8561e87, 0xd8b06647, 0xc1891103, 0xc3093764, 0xc8f03009,
+	0xe448218b, 0xdfee5c18, 0xc1991182, 0xdba05f27, 0xc0101fa4, 0xc03b8819,
+	0xc4105401, 0xc44183a7, 0xc43000d8, 0xc0102384, 0xc03b880a, 0xfa601003,
+	0xc01e9802, 0xd8900b87, 0xe8055795, 0xc1a91450, 0xc0c3fc45, 0xc0f0f030,
+	0xc20010f0, 0xf849ff07, 0xe208a403, 0xe879abb0, 0xc05e4199, 0xc4510041,
+	0xc1fca455, 0xf6422c0b, 0xc0120234, 0xc24d900e, 0xc0902402, 0xc0409764,
+	0xc0001001, 0xc1dc9c12, 0xc8102809, 0xc209158d, 0xe4607727, 0xc20e8820,
+	0xf090ac03, 0xc2200c1c, 0xc27fbfc4, 0xc26043c5, 0xfdfe1ca0, 0xc003f444,
+	0xc4462481, 0xd40000ee, 0xc0d02c1c, 0xcd8110a1, 0xe8e91c00, 0xc44fff95,
+	0xf4400102, 0xc000721f, 0xc1cc1c2a, 0xf4509803, 0xe090721d, 0xf0708003,
+	0xc0360420, 0xc25d901b, 0xc0502404, 0xc25023c5, 0xd89204a0, 0xc003f044,
+	0xc4408387, 0xca1000ee, 0xc44a3b07, 0xc5500102, 0xc028d364, 0xf0703c01,
+	0xc70e1020, 0xc0104266, 0xe7f30807, 0xc012f044, 0xef408054, 0xe34d1c03,
+	0xe1dd1a35, 0xfd40ae32, 0xe33d9003, 0xede08401, 0xffef1003, 0xcb708233,
+	0xc20c9c00, 0xf07115be, 0xc7fe129b, 0xc40a1a2a, 0xcd8110b0, 0xf80e1000,
+	0xcb0a1443, 0xc0040820, 0xc41504a2, 0xf97c0141, 0xc4154600, 0xc0203844,
+	0xe34d9055, 0xc1100402, 0xc01bbf07, 0xef5c0806, 0xc5403803, 0xc4004b64,
+	0xc45fb801, 0xc37b7764, 0xc44ff001, 0xfc400a5c, 0xfc4b7480, 0xcca802bf,
+	0xc46202dc, 0xc0025820, 0xcc004cc0, 0xe6b30014, 0xca222045, 0xc0203844,
+	0xc029af64, 0xc4201c09, 0xc9608042, 0xc85e1c00, 0xc80e1587, 0xfc510647,
+	0xc4503020, 0xe471ff87, 0xeb091eaf, 0xe47ac647, 0xeb591eb2, 0xe47ada47,
+	0xeb491eb3, 0xc031b044, 0xc100af64, 0xc4404409, 0xc4400aa7, 0xf4700abc,
+	0xf47b529e, 0xf47b4e9d, 0xc45b4a9c, 0xcc8b70c0, 0xeee30ee3, 0xcc1b60cf,
+	0xed6306d5, 0xccfb68c4, 0xf05302df, 0xc45b6cdd, 0xc44b98c0, 0xfc700ad0,
+	0xccca7838, 0xe9c3029d, 0xc44a7ccd, 0xc2000b49, 0xf6400b80, 0xc090402b,
+	0xea132813, 0xea2e5ca0, 0xe724044d, 0xffc026ae, 0xc02e0044, 0xc02ec844,
+	0xc22e9c90, 0xc003b844, 0xeafae347, 0xeb0ae747, 0xeb1aeb47, 0xeb2aef47,
+	0xc02c3420, 0xc02d2444, 0xc02ec820, 0xc84083a7, 0xc003f020, 0xc84083a7,
+	0xc003b820, 0xd87abf07, 0xfa4ac727, 0xe08a14ff, 0xc44093a7, 0xf0700102,
+	0xf2761eb0, 0xcffe92b2, 0xfa782285, 0xd0211026, 0xeb5c1c00, 0xeb3c9d87,
+	0xe853ffa4, 0xc25e9e08, 0xc0040844, 0xd87adb07, 0xfa4ad327, 0xe08a14ff,
+	0xc2009fa7, 0xcc000102, 0xc0d0029d, 0xc03a7540, 0xe9dd8bfa, 0xc0402c0f,
+	0xd40a74cf, 0xc0b00e9c, 0xc0fa7362, 0xccf0200b, 0xc040029c, 0xf07a70c0,
+	0xf0560e9d, 0xfa48aa9c, 0xf27a1bf7, 0xe8569e9e, 0xc440afa7, 0xc4400102,
+	0xc0900a0f, 0xf4711402, 0xc00a86d8, 0xed8c1c11, 0xc03a8702, 0xed7c9ff7,
+	0xc03a8722, 0xed7d1c05, 0xe9fc1ea1, 0xc8000c0b, 0xc0b03662, 0xe4723403,
+	0xc221129f, 0xf6428403, 0xc0940236, 0xda329403, 0xf0560e85, 0xf0560ea0,
+	0xc2ce9ea1, 0xc0040820, 0xc44a9307, 0xc4000c22, 0xc44a8f07, 0xc4000c22,
+	0xc44a8b07, 0xd8400c22, 0xd84a1443, 0xfa7a1443, 0xd0211028, 0xea7c1c00,
+	0xc0308844, 0xea6c1c40, 0xc0308844, 0xea5c1c40, 0xc0308844, 0xe8510d84,
+	0xe8510d84, 0xc440a7a7, 0xf0700102, 0xc22112ad, 0xf0710003, 0xc22112ac,
+	0xf0710003, 0xc22112ab, 0xc4361003, 0xc4361285, 0xc31e9e85, 0xc0040844,
+	0xc44aab07, 0xc4000c22, 0xc44aa707, 0xc4000c22, 0xc44aa307, 0xd8400c22,
+	0xd84a1443, 0xfa7a1443, 0xd020802a, 0xc0340000, 0xe868a805, 0xd218a045,
+	0xf85a1a8a, 0xc8311410, 0xd8228582, 0xd8100785, 0xf8560685, 0xe8560402,
+	0xc200c3a7, 0xc4400102, 0xf8200c77, 0xeb39007f, 0xc44ad240, 0xc2000c50,
+	0xf6400b0d, 0xc01c02b3, 0xc1000c07, 0xeb33ffc7, 0xf00ad364, 0xc0301c01,
+	0xcfff1c0a, 0xcc0116b4, 0xff3002b3, 0xc45ad0c0, 0xc4cabf97, 0xd1813509,
+	0xc09ade72, 0xf47117fa, 0xf47acebc, 0xc45ad2bd, 0xc0fc3b42, 0xc450fc03,
+	0xc03c3b02, 0xc4210819, 0xc0ec9c45, 0xc0203f09, 0xe08aa005, 0xc4083921,
+	0xf0dc8841, 0xf03fac01, 0xfeb02f0e, 0xf0d91c42, 0xf0e91c42, 0xcc00b800,
+	0xe261130f, 0xc17d9002, 0xfdc02404, 0xc4711b40, 0xf4208401, 0xc0103b0d,
+	0xf0ed0fc5, 0xc1702c0f, 0xf0d03b47, 0xf0e03f47, 0xd4003409, 0xc0900f0d,
+	0xf0dc4342, 0xcc00100b, 0xf0f3070d, 0xe1dc3845, 0xc0400102, 0xf278770e,
+	0xf27106d5, 0xca2106d6, 0xc0203844, 0xedcd1c45, 0xedc32303, 0xc449fcc2,
+	0xcc2004bc, 0xc26d930a, 0xc1900402, 0xf0a50054, 0xcc9fe00b, 0xf0a5030a,
+	0xc5401c03, 0xc0b07140, 0xc1c503f9, 0xf4501403, 0xf47c0e20, 0xc45b7303,
+	0xfcec44c0, 0xc40c3bff, 0xc02c3444, 0xc0329c44, 0xd4013042, 0xc1000711,
+	0xc0fc4746, 0xf200a403, 0xd00b9313, 0xc4d0a809, 0xcc1f9c00, 0xc0fd1f13,
+	0xc0402f11, 0xc09c4d52, 0xf1130404, 0xc60e9c40, 0xc0036044, 0xc0102264,
+	0xf13d2007, 0xf1350713, 0xd40f4000, 0xc050270f, 0xc4dc4f22, 0xeddd9045,
+	0xc1902480, 0xc0298c44, 0xea2e5ca0, 0xe724044d, 0xffc026ae, 0xc02ec844,
+	0xc44a84c0, 0xc4400b80, 0xd4000ddc, 0xc02026e1, 0xc0dbf7c4, 0xc0297044,
+	0xe00bffc4, 0xc0021c20, 0xf47b70cd, 0xf47acebc, 0xf07ad2bd, 0xf14502f2,
+	0xe0801009, 0xeb490101, 0xc44ace40, 0xc4400c50, 0xcc000cd6, 0xc71e1f19,
+	0xc01c5140, 0xf6442003, 0xc0100719, 0xc40e0004, 0xca041987, 0xc0228044,
+	0xf00acf97, 0xd1411319, 0xf1950403, 0xc02c6762, 0xc44f8009, 0xf4700b0d,
+	0xf42bcab3, 0xc0bbcabc, 0xef2d2007, 0xef2506f2, 0xc09c5d40, 0xef2d1c05,
+	0xf6411717, 0xc09202dd, 0xedc304ac, 0xc04f1455, 0xc71e9edd, 0xc0036044,
+	0xc54c5647, 0xd0211080, 0xc2ce9c00, 0xc44c3f87, 0xfa7000fd, 0xc4422822,
+	0xc8100102, 0xc4428189, 0xf0e000ee, 0xcb040a1d, 0xc4128041, 0xc0e110a2,
+	0xca020002, 0xc0b00662, 0xcffe9c04, 0xeafe5c40, 0xc4d4044d, 0xd0113501,
+	0xc4344c4d, 0xc80e9e80, 0xf921004d, 0xc0598aaf, 0xc4001c0b, 0xc02c0444,
+	0xfa489c42, 0xda548401, 0xd87a1591, 0xc4428106, 0xc42008a0, 0xc0345044,
+	0xf9240441, 0xc08992af, 0xf90f1801, 0xc43446af, 0xeaf9c84d, 0xc44fec03,
+	0xc4400c6c, 0xc4400b07, 0xf6400b80, 0xc09022a0, 0xfa720008, 0xd0211022,
+	0xc20c1c00, 0xc1300992, 0xc100099a, 0xca062481, 0xc003f044, 0xc71e9c55,
+	0xc44c5707, 0xc4400102, 0xfc400b0d, 0xfc5b77fb, 0xc54b7480, 0xc00c1c45,
+	0xe1b91d83, 0xf4702c03, 0xf070221e, 0xc07c9c06, 0xf4702400, 0xf0702e1e,
+	0xc0ac9c09, 0xc0404420, 0xe4b16747, 0xe4a92347, 0xc0192844, 0xc5492247,
+	0xc8000764, 0xf4714c09, 0xf649224a, 0xc0900401, 0xc01d9170, 0xd7002402,
+	0xc0400764, 0xf645ec09, 0xc0902001, 0xc01d91a3, 0xf5d0a420, 0xc01d9008,
+	0xdae02440, 0xd0000764, 0xf276a409, 0xc20c921c, 0xc03bf029, 0xc038ff64,
+	0xc4403001, 0xe270064a, 0xe48c99ba, 0xc2602454, 0xf0692f07, 0xc80e1059,
+	0xc5506c09, 0xc4700142, 0xc00083c5, 0xe33007c5, 0xf6404800, 0xc0100633,
+	0xc20f140a, 0xe4ad1c00, 0xfe900248, 0xc0192844, 0xf4792247, 0xc4492c59,
+	0xc0900655, 0xe49c1808, 0xfd70059a, 0xe3fd9054, 0xc6600402, 0xd9e92307,
+	0xfc50980a, 0xfc408484, 0xf0709bfe, 0xe49c1a48, 0xc2c02e09, 0xc0196844,
+	0xf6401c09, 0xc090323f, 0xe10edc22, 0xc0036044, 0xc8095e47, 0xc0040844,
+	0xf6405400, 0xc0900426, 0xf7bf1010, 0xe34d9021, 0xc0800401, 0xc26007c5,
+	0xc0467044, 0xd9d92307, 0xfc401c0a, 0xc0009bfd, 0xe34d900d, 0xc0800402,
+	0xc2600bc5, 0xc0114444, 0xc0196844, 0xf6401c09, 0xc090323f, 0xe48c9c0b,
+	0xc0b92726, 0xd8311005, 0xe3fd9001, 0xc1300401, 0xc0195444, 0xea801c01,
+	0xc008cec4, 0xe48c9c0b, 0xdba92726, 0xc0100fa4, 0xe48c9c1f, 0xd90a1dba,
+	0xfa401802, 0xc04003fb, 0xfa4013a5, 0xe34c1c07, 0xe25fe384, 0xe3287f44,
+	0xe4992347, 0xc09f2020, 0xe4992347, 0xc018cf64, 0xfc4c4801, 0xc208cffe,
+	0xf28000b7, 0xe371121b, 0xf0710c01, 0xc0e0261b, 0xd44016c7, 0xe33d9000,
+	0xef900401, 0xc03bd020, 0xcc00240b, 0xc0bb1e1b, 0xc4700148, 0xec786cc0,
+	0xc0050408, 0xfdff1047, 0xc00d9000, 0xea600500, 0xc018cf64, 0xfc501401,
+	0xf4700020, 0xf070161e, 0xc04c9c03, 0xe3611041, 0xc4410c01, 0xc4000637,
+	0xc7c00a09, 0xd8820803, 0xe2910599, 0xf9010e80, 0xd9910276, 0xc4001790,
+	0xff3f1045, 0xeae00012, 0xea869caf, 0xfc507ec4, 0xf4480001, 0xd518ca1f,
+	0xd5d0830a, 0xc3ad9002, 0xc0702440, 0xc3afdfc4, 0xfc4a5000, 0xf640ebf0,
+	0xc01006dd, 0xeddd901b, 0xc1602402, 0xd410e942, 0xc00f06f5, 0xc3acaaf6,
+	0xc01802f4, 0xc3a50ffc, 0xe009c374, 0xc0000809, 0xc3dd9271, 0xc0702440,
+	0xc3dfdfc4, 0xfc499c00, 0xc000f7f0, 0xe71dd262, 0xc0202600, 0xfc496c00,
+	0xc44097f7, 0xc2000451, 0xc4200ef4, 0xda7103a7, 0xc20193a5, 0xc4201432,
+	0xc4dfff94, 0xfd408040, 0xf9410803, 0xc20133ff, 0xf6401432, 0xc2901edd,
+	0xc4201430, 0xc6b00d86, 0xee41b402, 0xc5900401, 0xc0ee1287, 0xf70e9190,
+	0xca010685, 0xc0228044, 0xfc46cc43, 0xfc4033fd, 0xe87063fc, 0xf821c384,
+	0xc0700430, 0xd3301fa4, 0xfc401c09, 0xd41087ef, 0xc0c50818, 0xf646a8a1,
+	0xc0901026, 0xc2ab1404, 0xc4420aa8, 0xec4000cf, 0xff7f102a, 0xc01f140d,
+	0xffef100d, 0xc135000d, 0xd4002c09, 0xc0702414, 0xc0d023c5, 0xcc005000,
+	0xc1230812, 0xcc5048c0, 0xc0a00012, 0xc44034c0, 0xfc400a5c, 0xca3033fd,
+	0xc050c820, 0xc0004ec7, 0xc14b1ffa, 0xc20fd800, 0xee400fd4, 0xc4202500,
+	0xc07e9041, 0xd8901387, 0xe805c395, 0xe7730c50, 0xc0b01662, 0xe7731c04,
+	0xee26cc43, 0xc0b02403, 0xc8410041, 0xcfc110b1, 0xc4310800, 0xe77d26a9,
+	0xc0b44677, 0xf4aaabfb, 0xf489de77, 0xc419de77, 0xc440c3a7, 0xc43000d8,
+	0xe859df04, 0xc440c3a7, 0xc0000102, 0xcb121007, 0xc003b844, 0xc03f5020,
+	0xc0901800, 0xec701002, 0xd00bd22c, 0xfb707801, 0xcd811210, 0xe5791c00,
+	0xd0211080, 0xd9c11000, 0xe3fd9004, 0xc0502402, 0xc03f5020, 0xe3287745,
+	0xc0280c20, 0xc013d444, 0xc44fbc00, 0xc91004f5, 0xc0033c44, 0xc0196844,
+	0xf6402009, 0xc010323f, 0xfb711403, 0xe57c1e10, 0xc0040820, 0xfc46e5ad,
+	0xec58cbcf, 0xfd408232, 0xee4a1c03, 0xc1600500, 0xc01e1041, 0xfb710182,
+	0xcee11211, 0xf8510800, 0xe11edff3, 0xc003f444, 0xef4a1c43, 0xc1600600,
+	0xd9004384, 0xe8564227, 0xc60e9c40, 0xc003b844, 0xff3e1442, 0xc44183a7,
+	0xc20000fd, 0xee400fd4, 0xc6302500, 0xcffe1287, 0xc0120264, 0xf00e1404,
+	0xc03e91bd, 0xe4701009, 0xc094c63a, 0xd8911010, 0xc0702409, 0xc0101264,
+	0xe4740803, 0xc3600e3c, 0xc0402531, 0xd318ee47, 0xe4702809, 0xc2a00e3a,
+	0xe478f247, 0xe3ac9e3b, 0xea80100b, 0xe3b50121, 0xf220180b, 0xc040023b,
+	0xf208ef20, 0xe3ec8a3c, 0xf4704007, 0xf478de3a, 0xf478e63b, 0xc448e23c,
+	0xc0000373, 0xe37d1c23, 0xe39d1e3a, 0xe38d1e3b, 0xc300823c, 0xc02a2405,
+	0xc0600c0c, 0xc008df27, 0xe38c9c08, 0xf2701000, 0xc2010a39, 0xec701432,
+	0xfd40801a, 0xc0cc9c03, 0xc0c00bc5, 0xc0d007c5, 0xccf1108f, 0xffef1000,
+	0xc0cb1c0d, 0xc03f5020, 0xc1300530, 0xccf11083, 0xc01f1800, 0xc4420c2b,
+	0xfc6000cf, 0xd310ac01, 0xc20fc409, 0xf2700fd4, 0xc02f140c, 0xc7ce1c0c,
+	0xc8fe1587, 0xc880aa44, 0xe4541d87, 0xc442082a, 0xc81000cf, 0xe448218a,
+	0xc0cb1c2a, 0xc03f5020, 0xc0209b64, 0xf6401c01, 0xc0110012, 0xfd4083f8,
+	0xf2710803, 0xd680000d, 0xc12c9c42, 0xc4258c00, 0xc0199197, 0xe6404409,
+	0xc1502402, 0xc0901264, 0xc1099017, 0xca006c09, 0xf2553800, 0xc54b1e1d,
+	0xc00ffb84, 0xc54303e7, 0xc00ff784, 0xe1fc93e1, 0xf84152c7, 0xfd9003fb,
+	0xc42f9c00, 0xc0165c40, 0xc014440d, 0xc0144428, 0xc0144429, 0xc410002a,
+	0xfb7952c7, 0xd00e1e41, 0xc003b844, 0xcd811121, 0xc30e1000, 0xc444c840,
+	0xfb8000d8, 0xc43a1300, 0xf95a15a3, 0xc1e00080, 0xc00952c7, 0xe55b1c1f,
+	0xe8706c00, 0xe41edc40, 0xc0040844, 0xcd811131, 0xc61e9c00, 0xe84aa1a6,
+	0xe00e9043, 0xe40ede85, 0xc0040844, 0xc03f5020, 0xc01d3362, 0xc03f5021,
+	0xc42d30c1, 0xcc0d28c0, 0xc512034b, 0xfc1d2ac0, 0xfc6d2c00, 0xf49d28d8,
+	0xf4bd2b4a, 0xc0ad2f4b, 0xce5f0008, 0xc00f074a, 0xc0bedf4b, 0xfcced5a9,
+	0xc0500622, 0xfe000101, 0xf2614501, 0xcffe934a, 0xc093bee2, 0xc5140429,
+	0xf4ac1c40, 0xee289997, 0xc1e024be, 0xc5140442, 0xfa4d2f26, 0xcadb88ff,
+	0xd0104c09, 0xf4bc9c50, 0xe62a19b7, 0xc09024de, 0xcc010080, 0xfd40834c,
+	0xcffe1c03, 0xc43fe000, 0xfa569ca2, 0xc7800041, 0xe3388745, 0xc0c02a8a,
+	0xfc4c03a4, 0xec509cff, 0xfd408027, 0xc59c9c03, 0xc00109a7, 0xc20b9062,
+	0xc8104801, 0xe339158c, 0xc09042e4, 0xe4482005, 0xc2a11233, 0xc4200001,
+	0xd8924441, 0xc0100ae4, 0xc40f1415, 0xc2491633, 0xc0209b64, 0xfa707401,
+	0xe00e5c22, 0xc003f044, 0xfc405000, 0xf648cfbf, 0xc0100826, 0xe448200c,
+	0xc22e9c24, 0xc4480397, 0xc43000ee, 0xee462481, 0xc0900401, 0xc44083a7,
+	0xc00000ee, 0xc20e9c08, 0xcfd11208, 0xfd408000, 0xcc0e1c03, 0xc5491d87,
+	0xc4311c4f, 0xc20104a0, 0xee200fd4, 0xc670040f, 0xcc0b7707, 0xc01482e1,
+	0xc1802c66, 0xfc4b84c1, 0xfc5b740f, 0xc0080100, 0xee63004f, 0xc01fdfa4,
+	0xee63044b, 0xc00ba2c7, 0xc08b9045, 0xee2fc809, 0xc2102404, 0xc0209b64,
+	0xf64f3001, 0xc0104027, 0xf09503c7, 0xd40f0c09, 0xfbf006e6, 0xf64ba327,
+	0xc0100826, 0xeddd93b8, 0xc300a473, 0xc8ff1005, 0xc03b92dd, 0xe8705c01,
+	0xee2b1db5, 0xc0104264, 0xe1dd1405, 0xc07e12e2, 0xedd91583, 0xe00103c5,
+	0xc20c24c0, 0xf0a00fd4, 0xc20e12dd, 0xf47fc800, 0xfc4c26dd, 0xfc4b77cf,
+	0xc00803bf, 0xec710bee, 0xf84a1e7b, 0xc02684ff, 0xc1402c0b, 0xc44a6e47,
+	0xc0000a13, 0xc4111005, 0xe7b50003, 0xca106c0b, 0xc0289c44, 0xc0b9ed40,
+	0xc12d9013, 0xffd00440, 0xe7803b47, 0xe7903f47, 0xca180397, 0xc0203844,
+	0xe7aa6f47, 0xd979ef07, 0xf9000f84, 0xc4113278, 0xc03f5020, 0xe7791c42,
+	0xc05e5c41, 0xd28e5589, 0xc07e91bb, 0xc4314280, 0xfa46dc41, 0xc43a000f,
+	0xd009df64, 0xd2006c09, 0xfa40200b, 0xd21aa0ff, 0xfa401000, 0xc41134ff,
+	0xc02c3444, 0xc02bec44, 0xc02e0044, 0xc03f5020, 0xc001044c, 0xeafb4bfb,
+	0xec0a869c, 0xe7dbcee2, 0xe2f8bb47, 0xee48bac7, 0xc1900440, 0xc44203a7,
+	0xf84000d8, 0xe2ec9fc3, 0xc3ce91b5, 0xc80e9e85, 0xc0040844, 0xe2e8bf47,
+	0xfc506400, 0xf648cc04, 0xc090062e, 0xffbf1005, 0xe2ed9233, 0xc0502420,
+	0xc0300080, 0xd5a11081, 0xfd408001, 0xe23b1c03, 0xc00890c0, 0xe23c241e,
+	0xc0307402, 0xc3000420, 0xc0189362, 0xd1204403, 0xd1207c01, 0xd1615c01,
+	0xd141a801, 0xd1215401, 0xc2018001, 0xe0e00fd4, 0xc003ff84, 0xe2910455,
+	0xc44109b1, 0xc0000102, 0xe1fd13f1, 0xd8b20c2a, 0xc000aa45, 0xe1fd1005,
+	0xfffed029, 0xe6289307, 0xfdd03807, 0xe4760e0a, 0xe24c282d, 0xec701802,
+	0xc090002c, 0xe4562687, 0xec56d42c, 0xe23c1c2d, 0xfc502801, 0xfc40b480,
+	0xc000b77f, 0xc40f1430, 0xfbff102d, 0xc280002d, 0xc0004f97, 0xed5e5c04,
+	0xd4089300, 0xc0502624, 0xca04044d, 0xc160004d, 0xc00b66c7, 0xe24503a0,
+	0xec701809, 0xc0a00019, 0xe0862c8f, 0xdab06244, 0xd41062c5, 0xf8c00224,
+	0xe23c2442, 0xc030f802, 0xc0145843, 0xc0144849, 0xc294500e, 0xf9701431,
+	0xe24c0200, 0xc001044c, 0xe24c1fe5, 0xc2e01e62, 0xf6401431, 0xc2901026,
+	0xe0a01431, 0xda728d87, 0xc2ab12a8, 0xf270aa45, 0xe24c1c2e, 0xc0902a0a,
+	0xc2fc1db9, 0xd8503f84, 0xfffed225, 0xe0a08800, 0xc4c3ff84, 0xf4400041,
+	0xe2e87f04, 0xc0036044, 0xf3b00040, 0xc028930a, 0xc0dc1c11, 0xc0dfdfc4,
+	0xe7c03f47, 0xe4703b27, 0xc001040d, 0xe7cc9f9a, 0xc20fec00, 0xc2002158,
+	0xc200215c, 0xc200096c, 0xc200228d, 0xc200108e, 0xc20027bf, 0xc2002e26,
+	0xc20010a6, 0xc2001430, 0xc20028cb, 0xc200297e, 0xc2001430, 0xc20027b9,
+	0xc2001121, 0xc2001436, 0xc2002eab, 0xc20006bb, 0xc2002e8e, 0xc2002ecf,
+	0xc2001124, 0xc2001175, 0xc20011b5, 0xc2001430, 0xc20011bf, 0xc2002a08,
+	0xc20011f3, 0xc200126b, 0xc2001270, 0xc200156a, 0xc2001570, 0xc2001602,
+	0xc2001284, 0xc200129b, 0xc20012ba, 0xc20012c7, 0xc20012cc, 0xc2001530,
+	0xc2001430, 0xc2001430, 0xc2001430, 0xc2002b6d, 0xc20014b0, 0xc20014f1,
+	0xc2002eec, 0xc20029b8, 0xc2001430, 0xc20013bc, 0xc20013d2, 0xc2001430,
+	0xc2001430, 0xc2001430, 0xc2001430, 0xc2002f54, 0xc2001430, 0xc2001430,
+	0xc2001430, 0xc2001430, 0xc2001430, 0xc2001430, 0xc2001430, 0xc2001430,
+	0xc2001429, 0xc20012d1, 0xc20012fe, 0xc2001350, 0xc2001736, 0xc2001430,
+	0xe87013b5, 0xd9b6cda3, 0xc0100662, 0xc089880b, 0xc050c029, 0xc008fac7,
+	0xc02f1405, 0xfd408233, 0xedc32403, 0xc0336c44, 0xc01c1540, 0xed9d900b,
+	0xc0602402, 0xc00c7cc0, 0xf1f32004, 0xc10c7f62, 0xc442cc0f, 0xf4a01840,
+	0xf62c4f1f, 0xc0f0231f, 0xf1fc1c36, 0xec0e4108, 0xf15b1c4c, 0xc01c7f64,
+	0xf0703001, 0xf9041f1f, 0xec0132c0, 0xc0a00315, 0xd09c7f07, 0xc4cb0390,
+	0xf64c56c0, 0xc0100b1f, 0xf15c280a, 0xe47af700, 0xc0d002b4, 0xf00c570a,
+	0xeb391ebc, 0xfc401400, 0xcc1c4c05, 0xf1fd9320, 0xc0402401, 0xf97c8152,
+	0xf1fc02c0, 0xf15b1c4c, 0xf00ae397, 0xec013313, 0xf20d0b15, 0xeafe5f15,
+	0xf27c4f00, 0xc8c13715, 0xc02c7f64, 0xd0800c01, 0xc04c7f64, 0xd0100c01,
+	0xd01e158a, 0xca0110a0, 0xeafe5c02, 0xc4cc4f00, 0xc4dc8320, 0xc01402e4,
+	0xc1200004, 0xc02c3444, 0xc0289844, 0xc0903d40, 0xc0ec1c08, 0xc0ab6f02,
+	0xeafe5fe4, 0xc4cc4f00, 0xf97c56c7, 0xf13c02b8, 0xf15b084c, 0xf15c8342,
+	0xf00b0397, 0xf15c9f1f, 0xf1f5044d, 0xc44d3000, 0xcc002e0e, 0xf13302b7,
+	0xc08c4f62, 0xf970580f, 0xf13c02c0, 0xf13d884c, 0xc0603c04, 0xc00adec0,
+	0xeb7b0804, 0xc00c4d41, 0xeb7c2be9, 0xeb792a0a, 0xc0610044, 0xf0550045,
+	0xf6401c09, 0xc0100add, 0xec0c1c73, 0xe47b0700, 0xec2c1eaf, 0xe47b0f00,
+	0xec4c1eb0, 0xe47b1700, 0xec6c1eb1, 0xe47b1f00, 0xeddd92b2, 0xc2200402,
+	0xf00ba707, 0xec9c02c8, 0xf07abe47, 0xecac02ea, 0xe47b2f00, 0xeebc1eb0,
+	0xf00b3300, 0xeb191ecd, 0xf00bb307, 0xecfc02ce, 0xf62aca47, 0xc06002af,
+	0xeaf50404, 0xf00abf0a, 0xeaf91eb8, 0xc00ac362, 0xd4101006, 0xeb0c2ab0,
+	0xe47ae700, 0xeb1d8ab0, 0xc0401800, 0xf0aac541, 0xebac02b1, 0xf62ac647,
+	0xc06002b2, 0xeb250404, 0xf00acb0a, 0xeb291ebb, 0xeb3af347, 0xeb4af747,
+	0xc02c3444, 0xf1f30045, 0xc10c7f62, 0xf970300f, 0xf1fc02c0, 0xd41134a0,
+	0xff30031f, 0xee2d9045, 0xc0300402, 0xedc31c45, 0xf0ba7b47, 0xf15a7b47,
+	0xf9563081, 0xc4428101, 0xc44008a0, 0xf0900cdb, 0xc14d2c13, 0xf4b82746,
+	0xe09d1b46, 0xf46d1b4b, 0xf46d2e09, 0xf4b82746, 0xe49d1b46, 0xf46d2c13,
+	0xebcc1c14, 0xd14b2300, 0xf07ace47, 0xecbc02bd, 0xeb491d04, 0xf11fffc7,
+	0xd41ad151, 0xeb4d92b3, 0xc0400500, 0xf6406800, 0xc01402b3, 0xc1300004,
+	0xc02ca444, 0xc0289844, 0xcc0b6f07, 0xc0ec0b46, 0xf4603f43, 0xfcef7c0a,
+	0xd41c3bff, 0xc0402eb4, 0xd51ad0c0, 0xc0402eb3, 0xf62accc0, 0xc063feb4,
+	0xcfff1c05, 0xeb3d8ab4, 0xc05018ff, 0xeb33ffc7, 0xc02ca444, 0xe42c4f09,
+	0xf143029e, 0xc03c5362, 0xf400b00f, 0xf62a7b13, 0xc0f0029e, 0xe9e30004,
+	0xcffa7b62, 0xfc701c06, 0xc00a78ff, 0xf4911018, 0xe2611002, 0xf0f30002,
+	0xc032c444, 0xc01c3d40, 0xe9ed1c05, 0xf1450715, 0xf62f4c00, 0xc0f00311,
+	0xf15d1c1b, 0xf0bd1f11, 0xcfff1a9e, 0xebcc1c1a, 0xd14b3300, 0xf07ace47,
+	0xecfc02bd, 0xeb491d04, 0xf07da800, 0xf11c0315, 0xc44a7a4a, 0xc4500b49,
+	0xc44bccc0, 0xcc000cdb, 0xcc4112f9, 0xc38f1c06, 0xe9dd1f27, 0xe9cd1f28,
+	0xf2b30329, 0xf64cb0c0, 0xc01082e2, 0xed4d1c05, 0xee2d9327, 0xc0500402,
+	0xf27a7b47, 0xccfcb8c0, 0xee2d9334, 0xc0800404, 0xf2ea7747, 0xf34a7747,
+	0xccfcbcc0, 0xee2d9335, 0xc0800408, 0xf2fa7347, 0xf35a7347, 0xc10b8b64,
+	0xf4702801, 0xf47cda9f, 0xc00caa9f, 0xe9f33408, 0xccdca8cd, 0xddd11336,
+	0xf5130007, 0xf50b6f47, 0xf53b6b47, 0xc02b8b64, 0xcc101001, 0xf5330753,
+	0xf07d48c0, 0xf53c0b52, 0xc4427406, 0xcc001d87, 0xeb7d8ab7, 0xc8c03814,
+	0xf62c50cf, 0xc0700314, 0xedc30c7a, 0xe9dc5347, 0xf14c088f, 0xf47a7247,
+	0xf62a7e9c, 0xc0f01a9d, 0xe9c33c04, 0xc04b8b64, 0xf4701401, 0xf64a772e,
+	0xc01022e2, 0xf2fd1c05, 0xee2d929c, 0xc0500410, 0xe9fcab47, 0xc0da7f62,
+	0xccd01006, 0xeb7d1e9f, 0xeb8c1f23, 0xe47adf00, 0xeb9c1eaf, 0xe47adf00,
+	0xebac1eb0, 0xe47adf02, 0xebbc1eb1, 0xe47adf02, 0xd48112b2, 0xf1130407,
+	0xe9ecb747, 0xf02a7b07, 0xc0a01f33, 0xc070c044, 0xe9ece740, 0xf07fd000,
+	0xf25c0324, 0xf07c9a47, 0xc1ce12e2, 0xc0907382, 0xc0600004, 0xc00c5151,
+	0xf26d8b85, 0xc0401828, 0xd4101800, 0xf73002b7, 0xf51c9f40, 0xc00d4941,
+	0xf51d1f61, 0xf53d8b27, 0xc0402404, 0xc44c9dd1, 0xf4701d9e, 0xf47bcef5,
+	0xf47be327, 0xf47adf2b, 0xf47c8eb7, 0xc81be726, 0xee2c118e, 0xc4500c01,
+	0xcc8c68c0, 0xed9d1f07, 0xfc0f1773, 0xdec112d9, 0xf053040b, 0xf47d84d4,
+	0xcc0d3aa2, 0xf52d8b52, 0xc1a03c02, 0xc0752044, 0xe9ecb747, 0xf02a7b07,
+	0xc0a01f33, 0xc070c044, 0xe9ece740, 0xd41fd000, 0xfe500352, 0xe9ec9f47,
+	0xc08b8b64, 0xf6401c01, 0xc09042e2, 0xe9c54846, 0xf62d48c0, 0xc0f00f52,
+	0xe9c5043d, 0xe9fa7347, 0xc08b8b64, 0xf4704401, 0xf62a7329, 0xc070029f,
+	0xe9fd8807, 0xc100180d, 0xf6208000, 0xc070029c, 0xe9cd8807, 0xc040180f,
+	0xf6405000, 0xc01042e2, 0xf2ad1c05, 0xe9fd8a9f, 0xc040180d, 0xc44a7ccd,
+	0xd4101bef, 0xfc200352, 0xc0764444, 0xc04b8b64, 0xd520a809, 0xf523029d,
+	0xc03d4b62, 0xd410840f, 0xee2d929d, 0xc0700404, 0xe9dca347, 0xf6203800,
+	0xc070029d, 0xe9dd8807, 0xc040180f, 0xc4401400, 0xd4101bef, 0xfde00352,
+	0xc0764444, 0xf02d8307, 0xc160269d, 0xf02d8707, 0xc100269c, 0xf02d8b07,
+	0xc0a0269f, 0xf02dcb07, 0xc04026a1, 0xf4705400, 0xf47dcaa1, 0xf47d829d,
+	0xf47d869c, 0xf47d8a9f, 0xd60d8e9e, 0xf3202401, 0xed9dcf47, 0xef4bd747,
+	0xea2d1c45, 0xec1c1f4e, 0xe47b0302, 0xe9dd1f26, 0xe9ed1f28, 0xe9cd1f27,
+	0xe9fd1f29, 0xc441172a, 0xcc100aca, 0xf073131a, 0xc0b7b044, 0xc44b70c4,
+	0xf0700a26, 0xf4ec0aa2, 0xf0703c09, 0xec0c0ac1, 0xc0fc9b02, 0xfd911025,
+	0xc2000006, 0xc00a8b62, 0xf6204806, 0xc060034e, 0xea2c1c0d, 0xc06d3b02,
+	0xfd911010, 0xc0b00006, 0xf02a8b07, 0xc0503f4e, 0xc06f6444, 0xf4030045,
+	0xcc0d04c0, 0xf3f3033e, 0xc02b2844, 0xf07c4cc0, 0xedfc0b13, 0xf642f006,
+	0xc0100713, 0xebcc1c16, 0xd14c8f02, 0xe47c9702, 0xebdc1eb3, 0xd04c8f02,
+	0xe47c9700, 0xc14002b4, 0xf00af307, 0xf02452b7, 0xeb391f24, 0xf00af707,
+	0xf00412b7, 0xeb491f24, 0xc00acf62, 0xc4500c0f, 0xcffad362, 0xc4500c06,
+	0xc02c3444, 0xc09c4d40, 0xd8a20c32, 0xca040785, 0xc0228044, 0xc01c4540,
+	0xce811005, 0xe2611003, 0xf1130002, 0xf47d1307, 0xf02d1b45, 0xc47d0c46,
+	0xc0e02b46, 0xf4711b07, 0xf02d1847, 0xf43d0f42, 0xc0600b46, 0xe9eccf47,
+	0xf13c1c45, 0xd0400784, 0xd01e158a, 0xca0110a0, 0xe2611002, 0xc46c1c02,
+	0xf4611f47, 0xf43d0b02, 0xc02d1b43, 0xf33d1c06, 0xf641169e, 0xc0100713,
+	0xc0ed000a, 0xc0fd0740, 0xc0800341, 0xf3e03b40, 0xf3f03f41, 0xf47c3707,
+	0xf27d1b0e, 0xf3fd1f3e, 0xf40c8347, 0xf47d0741, 0xf47d0e82, 0xc0300b46,
+	0xf1350445, 0xf47d0800, 0xf47c9e9e, 0xf47ca29d, 0xf47ca69c, 0xf47caa9f,
+	0xf47caeb7, 0xf47cb323, 0xf07d3ea1, 0xf3fd1f3e, 0xf40c0346, 0xf46d0741,
+	0xf47c3647, 0xf07c3b46, 0xf0ed1f0d, 0xf50c9f46, 0xe82d1cc0, 0xf46d1f43,
+	0xf0a06402, 0xf40c9f50, 0xc0402a82, 0xf0ac9541, 0xf3ec9f50, 0xc0402a82,
+	0xfcec9141, 0xc00c3bff, 0xf64116eb, 0xc0100ae2, 0xf27d1c0c, 0xf27d1f2d,
+	0xf3930733, 0xf620c400, 0xc0e00326, 0xee2d9007, 0xc1f00420, 0xd14c9f07,
+	0xf07cb647, 0xe4741327, 0xf3931333, 0xc00cb762, 0xcc00100f, 0xf33d8b2d,
+	0xc0f018b8, 0xf332e3c7, 0xfc702800, 0xfc7cb438, 0xcc4cccb8, 0xcc011739,
+	0xf2530324, 0xfcec98c0, 0xc45c3bff, 0xe9cca747, 0xe9dca347, 0xe9ec9f47,
+	0xe9fcab47, 0xd9111045, 0xf4fd1c07, 0xf2bd1ea1, 0xecbd1ecb, 0xecad1eca,
+	0xec9d1ec9, 0xec8d1ec8, 0xec3d1ec3, 0xec2d1ec2, 0xec1d1ec1, 0xf02202c0,
+	0xecf91f2c, 0xeceb3f47, 0xecdb3b47, 0xeccb3747, 0xec7b3347, 0xec6b1f47,
+	0xec5b1b47, 0xec4b1747, 0xc02b2844, 0xc0610044, 0xed5c2445, 0xf46b5b4b,
+	0xf46d2e09, 0xf4b82746, 0xf00d1b46, 0xed6d06d5, 0xf4291f46, 0xf43d1b47,
+	0xf4bb5709, 0xe09d1ad6, 0xf46d1b4b, 0xf41d0b00, 0xe47d1b43, 0xf46d1f44,
+	0xe4dd9345, 0xc2802430, 0xf4bb5709, 0xe09d1ad6, 0xf46d1b4b, 0xf47b5b4e,
+	0xe82b572c, 0xf46d1f43, 0xf47d0a47, 0xf07d0f46, 0xf43d1f42, 0xed5c0346,
+	0xf46b5b41, 0xf47d1247, 0xc45d1746, 0xc9008ba7, 0xc01b8b64, 0xf6402c01,
+	0xc01006dd, 0xcee11005, 0xc4411400, 0xf62000fc, 0xc0f00b06, 0xf143002b,
+	0xc0361844, 0xef1acf47, 0xf4701c01, 0xc09bc2b4, 0xefd50405, 0xf06d9045,
+	0xc3700401, 0xc44c50c1, 0xf6200d86, 0xc013feb3, 0xeb4d8807, 0xc28024ff,
+	0xc45bf541, 0xf00b2707, 0xeb391ebc, 0xf00b2f07, 0xeb491ebd, 0xef1acf47,
+	0xef0ad347, 0xc01c1b64, 0xf0703801, 0xebcc02cc, 0xf07ace47, 0xebdc02ce,
+	0xc44ad247, 0xf6200cdb, 0xc0f00b06, 0xeddd900f, 0xc0700401, 0xc13803d7,
+	0xfc5050c0, 0xcc603500, 0xf16d3adc, 0xf1830b16, 0xc0dc6362, 0xf070640e,
+	0xf9044b18, 0xec7132a2, 0xf16d3b13, 0xf16d9316, 0xc0502401, 0xc07d4444,
+	0xc00c6141, 0xf1a503e6, 0xcc019801, 0xf1430313, 0xc0bc5362, 0xf971480e,
+	0xf14c02a2, 0xf15b1c4c, 0xc00c5762, 0xf0801c0f, 0xe4740715, 0xf15c1f15,
+	0xc0fc4f02, 0xf15d1c05, 0xf15d8b13, 0xc2f0240f, 0xcc0a8541, 0xf073131a,
+	0xf62c50c0, 0xc0e02f14, 0xea2e5c26, 0xc4cc5300, 0xf62c56c7, 0xc0701715,
+	0xf1554404, 0xffbc5762, 0xd410100e, 0xea2e5f15, 0xf27c5300, 0xd4113715,
+	0xfdd00314, 0xc00c5141, 0xf13d8bad, 0xc0803c0a, 0xcc0a8551, 0xf073131a,
+	0xc02e0044, 0xc02ec844, 0xeb3c1c45, 0xeb3bc747, 0xf07bc647, 0xef0d1eb4,
+	0xef091eb4, 0xc02ca444, 0xf13d1c45, 0xf14d1f14, 0xffff3b1e, 0xf1354b0e,
+	0xf62c54c0, 0xc0f00f15, 0xf13504b9, 0xff1c4f62, 0xc000100f, 0xf13d88ac,
+	0xc070180f, 0xf1dc7347, 0xf0729800, 0xf9044b18, 0xf13c9ea2, 0xfb21104d,
+	0xf3f11002, 0xf06d8807, 0xc0d03c02, 0xf9562c83, 0xf18ca104, 0xcffe9121,
+	0xc8101c00, 0xd01e558c, 0xca0110a0, 0xe2611002, 0xc0ed1c02, 0xc0fd1f3e,
+	0xf06d933f, 0xc2400401, 0xc07cfc44, 0xc02c1b62, 0xc870400f, 0xd04e558a,
+	0xd21c6328, 0xc443ffa4, 0xc00008a0, 0xcfff1805, 0xe261101a, 0xc0ed0002,
+	0xc0fd073e, 0xf155033f, 0xf6201c01, 0xc09fc713, 0xf3fd1c05, 0xf15d8b1b,
+	0xc0502401, 0xf1ccff47, 0xc02c5762, 0xf4701409, 0xf62c773f, 0xc0f0033f,
+	0xf3ed200d, 0xf3fd233e, 0xf3e5073f, 0xf3f003c1, 0xf47cfb07, 0xf02d1b3f,
+	0xf0ed0f0d, 0xc0b00b46, 0xf14c4f47, 0xf0dcfb47, 0xf0ecff47, 0xc09c5540,
+	0xf0d50407, 0xf0e003c1, 0xc00c5541, 0xf1bc1f46, 0xc03c7706, 0xf1ec1c1d,
+	0xf1491d11, 0xc00c7362, 0xd420100f, 0xf14d8b14, 0xc0503ff1, 0xf14fc7c7,
+	0xc0fc5362, 0xccf01006, 0xf18c1f14, 0xea2e4112, 0xc4dc5327, 0xe31b1c45,
+	0xc01402e4, 0xc01b9045, 0xfb708001, 0xc4421213, 0xfb7000ee, 0xc4421250,
+	0xf99000ee, 0xc22e9f05, 0xc003b844, 0xc018b044, 0xc2400bc5, 0xea0023c5,
+	0xfc408000, 0xf64093fd, 0xc0100a34, 0xc22e9c09, 0xc44c1799, 0xfb7000fc,
+	0xc4421213, 0xfb7000fc, 0xc4421250, 0xfc4000fc, 0xc44a8007, 0xf0700b80,
+	0xe009d231, 0xe7406001, 0xc0800410, 0xe4508387, 0xc0b00021, 0xe44f7f87,
+	0xf8561421, 0xc24910ff, 0xc0959044, 0xe30c9c45, 0xc048cf64, 0xc4500c01,
+	0xf478a8c2, 0xcc0a0284, 0xc109928a, 0xcc102809, 0xe83d1e2a, 0xe00f5e80,
+	0xe30c9e8a, 0xc0101264, 0xe86d1c12, 0xc1099280, 0xf4701c09, 0xf84a0285,
+	0xdb74480f, 0xfa401000, 0xe25b1cff, 0xe6203f84, 0xc0b00403, 0xd00f0901,
+	0xe25d2a80, 0xff300225, 0xc09dc444, 0xc0922444, 0xc028ab64, 0xf4701801,
+	0xc45a0a80, 0xe81a0347, 0xe0f11045, 0xc1502402, 0xd9790707, 0xc0101f84,
+	0xd00f0808, 0xc0944680, 0xe00f5ffc, 0xc891128a, 0xe41d1c09, 0xe2a30626,
+	0xc0850020, 0xc0283c44, 0xf0705009, 0xf8465e43, 0xc0800407, 0xe80403c2,
+	0xffc02511, 0xc44a28c0, 0xf4702489, 0xcc289a43, 0xd400822a, 0xe26c9c08,
+	0xfc4896c7, 0xdb7894ff, 0xc0101fa4, 0xe25d280d, 0xc0800a25, 0xffa02531,
+	0xc09dc444, 0xe7f30445, 0xf2714000, 0xf80b901d, 0xd3a02809, 0xfc50280b,
+	0xc008cc08, 0xff7f1005, 0xc1dc9e33, 0xc0905c21, 0xc0408364, 0xf0906809,
+	0xc0902e32, 0xe81a0347, 0xe4488708, 0xe81d1e32, 0xf9211280, 0xc4c00408,
+	0xe81a0347, 0xf0906000, 0xc0900632, 0xe82a0347, 0xe4488708, 0xe82d1e32,
+	0xf9211280, 0xc8900408, 0xe82a0347, 0xc4480397, 0xf64004b7, 0xc0900a7f,
+	0xffef1005, 0xc20d9200, 0xdfa0a405, 0xc20d9002, 0xce902410, 0xd0008364,
+	0xc204dc09, 0xfc4009fa, 0xf648cff7, 0xc0900420, 0xc20d900c, 0xc5d02404,
+	0xfc5f6000, 0xf6408080, 0xc0101a33, 0xd8920431, 0xc098cb04, 0xe81d1c17,
+	0xf6420283, 0xc0901233, 0xcc121403, 0xcaa1122a, 0xd8920408, 0xc008ca45,
+	0xe81d1cc8, 0xd8920685, 0xe3291208, 0xd978af07, 0xcc101f84, 0xcaa1122a,
+	0xc0500008, 0xc0840444, 0xf87803b7, 0xcfd113df, 0xe03edc00, 0xc44fdf87,
+	0xf07000fd, 0xc42e1420, 0xe47f3b84, 0xf5c11020, 0xf8300000, 0xec56a8a1,
+	0xe33d9020, 0xc3900406, 0xf0462481, 0xc1702632, 0xe84a0b47, 0xe33d9080,
+	0xc0302404, 0xe2a30895, 0xc082a844, 0xe4562481, 0xcda00232, 0xe86a0b47,
+	0xe0862481, 0xf078ca44, 0xf6465e2b, 0xc0100a33, 0xf8464c07, 0xc10e1407,
+	0xc448a8c2, 0xc00020aa, 0xe82d1c08, 0xd2111280, 0xd8a20408, 0xe3291208,
+	0xff7e1ca3, 0xc003f444, 0xca408307, 0xc08e95a7, 0xf04ede85, 0xe47a12a8,
+	0xf8728020, 0xcfd113df, 0xe0f11000, 0xc0f02402, 0xc80b7764, 0xcc302809,
+	0xcbc1127f, 0xdfa08001, 0xf6911002, 0xf0800000, 0xe33fdfc4, 0xc068cf64,
+	0xc4404c01, 0xc0900a0f, 0xf642040e, 0xc0901233, 0xcc120c03, 0xcaa1122a,
+	0xe00f5c08, 0xe813028a, 0xc0962444, 0xfd701409, 0xfb7a0780, 0xfdfe1f00,
+	0xc003f444, 0xc91887b7, 0xcee11189, 0xe7d50000, 0xfb702409, 0xca6e1e01,
+	0xc0040844, 0xc20087c5, 0xc20fb7c4, 0xf87803b7, 0xd4a11020, 0xf1e02409,
+	0xe80a0747, 0xfa717400, 0xe1dc1c71, 0xc003f044, 0xe33fdfc4, 0xc0283c44,
+	0xcc101c09, 0xd00f16e1, 0xd8a20600, 0xf648ca45, 0xc0101a33, 0xe0f11013,
+	0xc0e02402, 0xe33d9081, 0xc0302404, 0xe2a30893, 0xc082a844, 0xcc0a28c0,
+	0xd8911282, 0xc0502409, 0xe82e03d7, 0xf87c03b7, 0xcee11020, 0xf9728400,
+	0xe8e91e05, 0xc0040844, 0xc20813d5, 0xc20bffc4, 0xc21e1ca0, 0xd4a11184,
+	0xf2202409, 0xe80a0b47, 0xc0922444, 0xc4480397, 0xc20004b7, 0xfc4009fa,
+	0xfc4803fe, 0xf449fffe, 0xcc08ca1f, 0xdab28c20, 0xc44082c5, 0xc4400152,
+	0xc4400222, 0xc44002e4, 0xca900308, 0xd8a27dab, 0xc55c1208, 0xccb11225,
+	0xc55c1c0a, 0xc03e119b, 0xe2568e27, 0xc0a82044, 0xfc8080a7, 0xe20c9c09,
+	0xc018cb24, 0xc7fe1c06, 0xf9904c00, 0xc7fe1640, 0xc01a0306, 0xe40e6474,
+	0xfa4a0327, 0xc0189b80, 0xe20c9c15, 0xc098cb24, 0xe32d9019, 0xc2b00401,
+	0xf0707727, 0xe826401b, 0xf0710403, 0xf806441b, 0xc03a0810, 0xc1900034,
+	0xf2488327, 0xc0a00632, 0xf84a0327, 0xc7fe907f, 0xf2702000, 0xc7fe9280,
+	0xe8601401, 0xf070dc01, 0xc7fe1280, 0xc091ff86, 0xc80e1c0a, 0xe401ff82,
+	0xc2400280, 0xf64a0141, 0xc091fe80, 0xc1b0001d, 0xe80103c0, 0xf0705800,
+	0xf8465a80, 0xc099980f, 0xfc004001, 0xc44a0080, 0xc0902589, 0xc80f0005,
+	0xc8911280, 0xf0911409, 0xc1302e32, 0xe80a0747, 0xe00a2b74, 0xf4701409,
+	0xc44a0282, 0xc2002489, 0xf27021c5, 0xc2368a32, 0xf07021c5, 0xd1965a80,
+	0xc0871421, 0xd818cb07, 0xc0871423, 0xc80a0364, 0xc0871429, 0xe4563083,
+	0xff7f1232, 0xf80f1233, 0xc80f0280, 0xc8911280, 0xe00e5c09, 0xc012dc44,
+	0xc086a820, 0xc0000000, 0xc0a00002, 0xc000a800, 0xcaa008aa, 0xc2a2a80a,
+	0xcaa1a8aa, 0xc7e2a87a, 0xcaa1fcaa, 0xc7f2e87f, 0xcfe1fcbe, 0xc073fc7f,
+	0xc0105c00, 0xc3701c27, 0xc3f11c0f, 0xf643fc80, 0xf071fe80, 0xc7fe1280,
+	0xc8903409, 0xe80c1986, 0xfc501c01, 0xc008c801, 0xffef1005, 0xe80d1e32,
+	0xc07f128b, 0xe8add28b, 0xc0a00600, 0xc088cf64, 0xc4401401, 0xca302634,
+	0xc44a2b25, 0xf84000d8, 0xe8bc17f8, 0xc0040844, 0xd92a0307, 0xfb903f84,
+	0xe33c9200, 0xe2905001, 0xd8902787, 0xe8017795, 0xe8cb1c51, 0xd01a31c7,
+	0xe8cb1451, 0xcc004400, 0xc0fe128c, 0xf4902c01, 0xfc5a328c, 0xd11a3001,
+	0xca2fdc00, 0xf07a2b25, 0xd021128c, 0xe8add000, 0xc2c00600, 0xe89a0347,
+	0xe891ffc4, 0xf87a20c0, 0xf9562409, 0xc411447d, 0xec714501, 0xc4340688,
+	0xc0ba2722, 0xff400004, 0xca3a21c7, 0xc44a2b25, 0xf84000d8, 0xe88c14ff,
+	0xc0040844, 0xf2488327, 0xc2202632, 0xf07a34c0, 0xc0a65e80, 0xc0500004,
+	0xe8d063c5, 0xec5888a4, 0xf252928d, 0xcd81128a, 0xfe0e1000, 0xe8d07fc4,
+	0xc44a3705, 0xc4500102, 0xc003b844, 0xe0863083, 0xfc58ca44, 0xca303001,
+	0xc88a2b25, 0xc003b844, 0xc44fe387, 0xc20000fd, 0xfc700a0f, 0xfb7a3c20,
+	0xcd811215, 0xe4791c00, 0xc01a3d51, 0xc4428416, 0xfb7000c8, 0xcd811215,
+	0xe47c1800, 0xca2fc401, 0xc038af64, 0xca500c01, 0xc0032020, 0xe36c9c41,
+	0xcb7b99b7, 0xee601001, 0xc4510cd0, 0xdf5615f6, 0xcd07d129, 0xd223f1b3,
+	0xd897d8ff, 0xdf546df5, 0xcce650aa, 0xcd23cd23, 0xe33d90ff, 0xc5102420,
+	0xd96a0b07, 0xcc903f84, 0xe9590a95, 0xd8902797, 0xc4465795, 0xc09005f0,
+	0xc0ae0004, 0xe93b1c51, 0xec714501, 0xc7fe9296, 0xe82c1c40, 0xe221ff84,
+	0xc0502c42, 0xfed00101, 0xe94a4f47, 0xe9303fc4, 0xdd6a51d3, 0xe96d0a96,
+	0xc0800e95, 0xd51a5156, 0xffc02e95, 0xc03a5362, 0xcc301003, 0xe94c1e94,
+	0xf05610a1, 0xd0211293, 0xfdb11400, 0xcff2e471, 0xd2c38889, 0xc0d6fd76,
+	0xc0301807, 0xcb301402, 0xe7f7e956, 0xd4b27880, 0xc809fdf0, 0xde95008b,
+	0xd382067f, 0xc0f9fde3, 0xdf053cb2, 0xca32027f, 0xe7f79d45, 0xd3d25480,
+	0xc8b9fde0, 0xe7f76d36, 0xc099f540, 0xe99314bf, 0xe90a0747, 0xe901ffc4,
+	0xc44a44c5, 0xc09005f0, 0xe9130804, 0xc09bd844, 0xe97a4b47, 0xf6490707,
+	0xc0100a33, 0xe25c1c04, 0xe423ff84, 0xc5602e92, 0xf02a64c3, 0xc09e5e97,
+	0xe00e5589, 0xc017c044, 0xf8001009, 0xec714404, 0xd21aa69a, 0xc401ffa4,
+	0xf84a0707, 0xc42a087f, 0xc0101c03, 0xc0040405, 0xe9a757ed, 0xe9090747,
+	0xc028cf64, 0xf4701401, 0xfc4a4225, 0xf42a40ff, 0xf47a4297, 0xf66a469a,
+	0xc0903e91, 0xe9070006, 0xc44a44c1, 0xc01026f6, 0xe995040d, 0xc3fa6762,
+	0xd5103401, 0xff500292, 0xc0aa6762, 0xcca01003, 0xc09e5e99, 0xe0ee5589,
+	0xc017c044, 0xf8001009, 0xe4cc9c13, 0xc0500d31, 0xffc00105, 0xe98b1c51,
+	0xd211ffa4, 0xe81c1c40, 0xe821ff84, 0xc0500c42, 0xff000101, 0xf87a61d6,
+	0xf9562409, 0xe98c0209, 0xe9891c50, 0xfb7a670a, 0xf0561201, 0xd0211298,
+	0xcc111400, 0xe91d0a92, 0xc0600e90, 0xc00a4941, 0xc00117f9, 0xf0740f01,
+	0xe1e43806, 0xc384f33e, 0xcf07e078, 0xc0300400, 0xd8701802, 0xc09e1e27,
+	0xf02e5589, 0xd1189f00, 0xe4c91c50, 0xf84931d7, 0xc44a14ff, 0xf6402760,
+	0xc010062a, 0xe00f540e, 0xdaa10232, 0xe20ede85, 0xc0040844, 0xe2ad9042,
+	0xc2200402, 0xc73e9c40, 0xc0036044, 0xc44c7f84, 0xda402760, 0xc73e9e85,
+	0xc0040844, 0xc441c3a7, 0xd9a000d8, 0xe8510d8a, 0xc441c3a7, 0xc4500102,
+	0xc09e1c40, 0xf0fe5589, 0xc51a1f00, 0xc0a11442, 0xc1509858, 0xcc00c844,
+	0xf9728287, 0xf9562409, 0xc50a036b, 0xfc48a247, 0xf478a00f, 0xc408a628,
+	0xc01a1f07, 0xe29d0008, 0xc0044628, 0xd9310bfa, 0xf4789cc0, 0xd4189a25,
+	0xe27d9a27, 0xc0b0040e, 0xe268a342, 0xd40fd807, 0xc1100626, 0xc06b8921,
+	0xd41f3009, 0xe87d9a87, 0xfc402405, 0xc06000a1, 0xc09c5044, 0xc44114a0,
+	0xc2002044, 0xf4500fd4, 0xf648ca1d, 0xc290063f, 0xec7009fa, 0xe00e6634,
+	0xf648ce45, 0xc0908234, 0xe4482005, 0xd8c20e33, 0xc3691208, 0xc01022e4,
+	0xe20d1407, 0xc0700232, 0xe0862c81, 0xf078ca44, 0xfa489a35, 0xc1000401,
+	0xee48d327, 0xc4102401, 0xd5211041, 0xe2211000, 0xca310c00, 0xc39e95ad,
+	0xc018db26, 0xcbfe9c2f, 0xc39e95a7, 0xc018db26, 0xe34c9c26, 0xe868d707,
+	0xc0100b84, 0xc02b901d, 0xc4114409, 0xec56b4a1, 0xc24c1c24, 0xc050099a,
+	0xc24b12a8, 0xc00b9044, 0xc0100844, 0xc00c2044, 0xc6400043, 0xc0109b64,
+	0xc41f1809, 0xe30110a0, 0xe7fd9000, 0xc4a08402, 0xd961100a, 0xe7f30401,
+	0xc20c1c43, 0xc07e1193, 0xc0c00510, 0xc108cb64, 0xc4401c09, 0xc000035c,
+	0xffef13a3, 0xc01f167f, 0xc10f1600, 0xf1ff1020, 0xf9500020, 0xc0209b64,
+	0xc41f1409, 0xc00c6c44, 0xc20c1c43, 0xc07e1197, 0xc0c00510, 0xc208cb64,
+	0xc4401c09, 0xc0000369, 0xffcf13ae, 0xc01f167f, 0xd00f1600, 0xd8821c20,
+	0xc2091208, 0xc44e7800, 0xf070042a, 0xe35c1a34, 0xc2100f84, 0xf47009fa,
+	0xf668d634, 0xc2100a7f, 0xf64009fa, 0xc2100e34, 0xf27009fa, 0xc20c921c,
+	0xc0a2f021, 0xc0257420, 0xc018ff64, 0xc0a31421, 0xc0257420, 0xe3287745,
+	0xc0257420, 0xf07906c7, 0xc01a1a42, 0xe2a30491, 0xf2690b27, 0xcffe9241,
+	0xfc401401, 0xf470838f, 0xf4790a41, 0xf0789a41, 0xe41c121d, 0xcc302801,
+	0xe41d1e2a, 0xebc11243, 0xe41c9c02, 0xec73ffa4, 0xf00f1225, 0xe30b1630,
+	0xc0a7f444, 0xf0462c81, 0xc0d02626, 0xd008cb64, 0xc8102009, 0xc448218a,
+	0xc44000fd, 0xf270048c, 0xc3100e26, 0xc0283c44, 0xc4406401, 0xf4702771,
+	0xc8189a41, 0xf848ab06, 0xc0500403, 0xe2690f47, 0xc0850044, 0xc000b002,
+	0xf7111030, 0xc1b02409, 0xc0a79844, 0xf246aca2, 0xc2200420, 0xc018cf64,
+	0xc4407400, 0xfc50048c, 0xf478a803, 0xc0090e41, 0xfffe93c8, 0xf2703801,
+	0xc20c921c, 0xc4301809, 0xc413ffa7, 0xc44a00c0, 0xfc4029e6, 0xf278abfc,
+	0xc20c921c, 0xf0704009, 0xc0500e80, 0xc03f5020, 0xcffe9c43, 0xfd408041,
+	0xec711403, 0xe50c1e43, 0xfde00686, 0xc418a8c2, 0xc02af044, 0xe26b1c43,
+	0xec73ffa4, 0xcfff1225, 0xec569e30, 0xe1dc1e30, 0xc0190f04, 0xcfff1013,
+	0xe43d1e43, 0xe43d1e41, 0xc03f1642, 0xc8c1122a, 0xc0500001, 0xc0125c44,
+	0xc0390f27, 0xf6300394, 0xf07a02c7, 0xe80c1221, 0xd2003c01, 0xf270180b,
+	0xc0400281, 0xc42a0b27, 0xc050c820, 0xe4487f0e, 0xe1dc9280, 0xf4701c01,
+	0xc00a0680, 0xe80d1c05, 0xec76d682, 0xc891128a, 0xfd408009, 0xe32d9003,
+	0xc0800404, 0xc0058444, 0xe32fefc4, 0xc088cb64, 0xc4402001, 0xfc400255,
+	0xc458cbf7, 0xc83887b7, 0xcee11189, 0xc2020c00, 0xec7000fc, 0xe33d924d,
+	0xc1900402, 0xd21e07b9, 0xe2562881, 0xc0193704, 0xf6311005, 0xe4d5000a,
+	0xda30200b, 0xc0ad8c44, 0xf0704800, 0xc01a1220, 0xf3ff100d, 0xfa46da32,
+	0xe32b14c0, 0xc0abb820, 0xf6493727, 0xc011c020, 0xf83e640a, 0xe2bc9901,
+	0xc2e00634, 0xe33203c5, 0xe32803d5, 0xc0109b64, 0xfc502801, 0xc448c804,
+	0xf0700152, 0xe4dc1e4d, 0xc0101f84, 0xc0144c9a, 0xf01edca8, 0xc0036044,
+	0xd03fe384, 0xc0040844, 0xc21fdfc4, 0xca72bc00, 0xc20c91a7, 0xf2705001,
+	0xe2bc9a4d, 0xf64dc397, 0xc0100a33, 0xd8b21c06, 0xe341c385, 0xfc50ac01,
+	0xf648cd00, 0xc0100826, 0xc08f1408, 0xee411232, 0xe4dc1c00, 0xc011c384,
+	0xc30e0891, 0xfb729801, 0xcd811301, 0xfc7e1000, 0xc4406385, 0xfc400102,
+	0xc00093f7, 0xe4dd1ca4, 0xe33d922b, 0xc3300406, 0xf648af07, 0xc0100a33,
+	0xe33d9023, 0xc0a00480, 0xd9793707, 0xc4401f84, 0xf64020b2, 0xc0140233,
+	0xe4dc1c0c, 0xc07e119b, 0xc4404385, 0xfc4020b2, 0xc008ce7f, 0xc03f140b,
+	0xc4465e2a, 0xc03020aa, 0xde61126a, 0xdab2880a, 0xc2108324, 0xc4500fd4,
+	0xc87c07b7, 0xc003f044, 0xc82847b7, 0xc003f044, 0xc21fdfc4, 0xfb7db000,
+	0xcd811301, 0xff8e1000, 0xd0211105, 0xe11edc00, 0xcee11082, 0xc08f1400,
+	0xe1fd1021, 0xe50edc21, 0xcee11088, 0xe11edc00, 0xcee11082, 0xf4700000,
+	0xf87c07b7, 0xcfd113c7, 0xc60e9c00, 0xcfc11083, 0xc70edc00, 0xc4462883,
+	0xfc4000fc, 0xc00093f7, 0xf01edf6f, 0xc0036044, 0xf85f1f84, 0xd0211028,
+	0xc48f1400, 0xc60e9c24, 0xcee11083, 0xc70edc00, 0xc4462883, 0xc00000ee,
+	0xe2bc1f51, 0xec4aa284, 0xe4d9164d, 0xeaa116a8, 0xd510a40a, 0xc2000ee4,
+	0xfc50fc09, 0xf6480040, 0xc092002b, 0xee130016, 0xfc5b88c0, 0xcc0b7410,
+	0xe1cd1ed6, 0xed574ad5, 0xcc2b7cc1, 0xed9302da, 0xe00803c5, 0xeaa06c00,
+	0xc4401c02, 0xc0002c99, 0xffdf1013, 0xe63c9c27, 0xe62c95a7, 0xee210442,
+	0xc05024ff, 0xc02a9c44, 0xc03f5020, 0xcc0988c0, 0xc02f1663, 0xff600027,
+	0xc4080364, 0xc0023c29, 0xc030bc44, 0xc0999d40, 0xe683000c, 0xcc1988c0,
+	0xe6930263, 0xd40998c1, 0xcb602668, 0xc0298c44, 0xc800af64, 0xcc001c09,
+	0xd8611314, 0xe6950003, 0xcc001801, 0xc8b00269, 0xf64b70c2, 0xc092002b,
+	0xd8722413, 0xca110104, 0xc0228044, 0xc0336c44, 0xc0d403c5, 0xc0289844,
+	0xf0e99747, 0xf0d99347, 0xe6403b47, 0xe6503f47, 0xc800af64, 0xc4202809,
+	0xca0110a2, 0xe2611002, 0xe64c9c02, 0xf2099707, 0xc0fc040e, 0xd4004003,
+	0xc0800667, 0xc0199940, 0xc1100024, 0xc00998c0, 0xe08aa028, 0xe6750121,
+	0xd4008401, 0xc1302666, 0xf229a0c1, 0xf0ec0f0d, 0xcc001806, 0xc2b00263,
+	0xe6300fc6, 0xc4109800, 0xf0dc8840, 0xc06c3b03, 0xc431080a, 0xe47992c7,
+	0xc1600265, 0xf4710c42, 0xf479930d, 0xcc19970e, 0xc03f1a69, 0xe67d8a63,
+	0xc0401801, 0xc449a0c1, 0xd4102ca6, 0xebcd1e67, 0xebdd1eb3, 0xf0d112b4,
+	0xefdf1002, 0xe5c1100d, 0xc0700002, 0xe623ffc7, 0xfc498cc0, 0xfc5801ff,
+	0xc2009c02, 0xcc10008f, 0xc03f1a69, 0xe67d8a63, 0xc0401801, 0xc459a0c1,
+	0xc800af64, 0xfc701801, 0xc4598840, 0xc44c14c2, 0xcc00174d, 0xecfc1f05,
+	0xf84b3b02, 0xe6291cff, 0xc25d9045, 0xc0b02404, 0xd8ab7707, 0xc0204003,
+	0xce7000b8, 0xc028d364, 0xfc43e809, 0xc00803bf, 0xe00d90f5, 0xcea02500,
+	0xcc0bd4c0, 0xd8b236f6, 0xc4024385, 0xf8710083, 0xef611080, 0xe6311001,
+	0xc01f1402, 0xee6302dd, 0xfc4c00c0, 0xf8709fef, 0xf8561c85, 0xc4191c80,
+	0xc0c083c5, 0xc44c18c0, 0xd4000ad0, 0xc29026e1, 0xc08a8364, 0xc4409009,
+	0xc44019bc, 0xcd000ce8, 0xf1a30322, 0xcd0bf4c0, 0xdec11307, 0xea1d080b,
+	0xc0e00722, 0xf47c68c1, 0xcc8c8aa1, 0xdec11307, 0xff10000b, 0xcc0c68c0,
+	0xec0c1f05, 0xf02b0700, 0xec9c0ac8, 0xf07ba647, 0xec3c02c2, 0xf02b2b02,
+	0xeea91ecb, 0xf00b1307, 0xeccc0ac5, 0xe47b3702, 0xec6c1eeb, 0xf02b1f00,
+	0xecfc0ace, 0xf07bb247, 0xf0560e9e, 0xf0560e9d, 0xf0191e9c, 0xc030bc44,
+	0xeed50055, 0xccf02801, 0xfbff12dc, 0xdc408200, 0xdfcf100b, 0xc20f16dd,
+	0xc09002dd, 0xc0298c44, 0xc09b8307, 0xc02f1447, 0xee3d1edd, 0xf1331307,
+	0xc0635844, 0xc05d3444, 0xc0bc1d51, 0xee3d1ff6, 0xdec11307, 0xf471540b,
+	0xccec12e0, 0xeddd92dc, 0xc0e02440, 0xc10b7764, 0xccf01001, 0xfbff12dc,
+	0xc0f00200, 0xedd7a3c4, 0xc40c2764, 0xfc501409, 0xc0080040, 0xdc8f1005,
+	0xe5c112dd, 0xc9608002, 0xc3ad9000, 0xc0f02401, 0xc4062c8e, 0xd21bebb9,
+	0xef611041, 0xff3f1001, 0xc3ad903a, 0xfe800440, 0xd510e8c0, 0xfa003f04,
+	0xf47f8000, 0xc44c5ad9, 0xc4401e33, 0xd510174d, 0xff502707, 0xe01e5c45,
+	0xca0110a0, 0xcdb08002, 0xec8e5c03, 0xc4d4604c, 0xecf9c909, 0xc45fe80b,
+	0xc4cb0397, 0xd01c4ec7, 0xf13c884c, 0xc4c0240b, 0xd0113511, 0xc4dc4f27,
+	0xecf9c901, 0xc45fb40b, 0xc01802f4, 0xeddd9008, 0xc300a407, 0xf85a1c05,
+	0xc0182300, 0xc02f1445, 0xf84a1c0c, 0xe1dc14ff, 0xc01b91b7, 0xc4007401,
+	0xd1701f84, 0xfc503001, 0xc810b440, 0xc0033c44, 0xc2deffc4, 0xc2991c42,
+	0xc0106364, 0xfc501409, 0xee408410, 0xc1700402, 0xc0120264, 0xda729005,
+	0xfc510285, 0xc810b480, 0xc0033c44, 0xc2ddffc4, 0xc2a91c42, 0xf8e05000,
+	0xc0a6e3ff, 0xc299100a, 0xc21fbfc4, 0xc0cff7c4, 0xc0400520, 0xc200aa44,
+	0xe8900fd4, 0xec70100a, 0xf648ba51, 0xc0100426, 0xfa410411, 0xc050041f,
+	0xc00fc444, 0xc016dc43, 0xcc811005, 0xfd408000, 0xc02b9003, 0xfc406c09,
+	0xd208caff, 0xfd504801, 0xc448cb00, 0xf2a029fd, 0xc0802826, 0xc0054844,
+	0xc0058444, 0xc03f5020, 0xe40c1c42, 0xc001020a, 0xc0aa27f8, 0xe56b1c04,
+	0xc26d922e, 0xc1100402, 0xc1fe9041, 0xc4401401, 0xc43005f8, 0xc05005b7,
+	0xc017ec44, 0xc03f5020, 0xc038ff64, 0xc4401c09, 0xe470064a, 0xf4715249,
+	0xec792249, 0xd8a20e3f, 0xf6406385, 0xc010063f, 0xc5791406, 0xe0801400,
+	0xc4415e44, 0xc090065a, 0xe3fd9007, 0xc1c02408, 0xf8563087, 0xe3fd90e0,
+	0xc0600402, 0xc0015e45, 0xe4482005, 0xe5a11057, 0xc2502401, 0xc048ff64,
+	0xfb704801, 0xcd811211, 0xc80e1400, 0xc0040844, 0xd5a11081, 0xc1300001,
+	0xc44847b7, 0xfb7000d8, 0xe84aa080, 0xc44847b7, 0xc4400102, 0xc2000583,
+	0xec700fd4, 0xf00ede46, 0xc0036044, 0xf27cff84, 0xcc0e9246, 0xf00ede85,
+	0xc0040844, 0xc44803b7, 0xca3000d8, 0xe84aa1a9, 0xe46c1c40, 0xe640c384,
+	0xc1600410, 0xc099f540, 0xc4110012, 0xc44807b7, 0xf84000d8, 0xc06e17e0,
+	0xc0040844, 0xd8510843, 0xe27a12a8, 0xfb7a1442, 0xd0211200, 0xe46c1c00,
+	0xc4401f84, 0xfa702fbf, 0xe46c1c73, 0xc1402984, 0xc0036044, 0xf27f8b84,
+	0xfa46d646, 0xfa7a141c, 0xd0211073, 0xc0600000, 0xcee11081, 0xfd408000,
+	0xc01f1403, 0xca761c0c, 0xf24aa1a7, 0xec78940c, 0xc4e1140c, 0xca02a4b6,
+	0x400000b7
+};
\ No newline at end of file
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_uboot.c OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_uboot.c
--- OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/common/phy/avago_uboot.c	2018-05-15 11:35:35.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/board/octeon/common/phy/avago_uboot.c	2018-06-28 15:08:31.077008789 -0700
@@ -53,12 +53,18 @@
 #include "avago_logging.h"
 #include "avago_sbus_master_0704_heal.h"
 #include "avago_serdes_0x2264_0241.h"
+#include "avago_avsp_5410_sw_sh.h"
+#include "avago_sbus_master_041f_0704_heal.h"
+#include "avago_serdes_0x4064_0241.h"
 #include <asm/arch/cvmx.h>
 #include <asm/arch/cvmx-app-init.h>
 #include <i2c.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#define AVSP_5410_CHIP_MODE(is_10g, is_fec)	\
+	((is_10g) ? AVSP_REPEATER_DUPLEX : ((is_fec) ? AVSP_RS_FEC : AVSP_GEARBOX_4_1))
+
 #ifdef DEBUG
 static int avago_debug_level = 6;
 #else
@@ -72,6 +78,9 @@ extern bool avago_i2c_sbus(struct avago_
 			       uint8_t reg_addr, uint8_t command,
 			       uint32_t *sbus_data);
 
+int uboot_garnet_host_tuning(int i2c_bus, int i2c_base_addr, uint32_t chip,
+		     uint32_t ring, bool enable_fec, uint32_t host_tx_atten,
+		     bool enable_10g);
 /**
  * Performs phase calibration on the host side for the specified chip and ring
  *
@@ -116,7 +125,8 @@ static struct avago_hdl *avago_init_hand
 	ah->debug = avago_debug_level;
 	ah->sbus_fn = avago_i2c_sbus;
 	ah->serdes_int_fn = avago_serdes_spico_int_sbus_fn;
-	debug("%s: Set sbus_fn to %p\n", __func__, ah->sbus_fn);
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"Set sbus_fn to %p\n", ah->sbus_fn);
 	ah->chips = 1;
 	ah->sbus_rings = 1;
 	return ah;
@@ -156,11 +166,54 @@ static void uboot_avago_tx_atten_set(str
 {
 	uint32_t serdes;
 
-		for (serdes = 6; serdes <= 9; serdes++) {
+	for (serdes = 6; serdes <= 9; serdes++) {
 		uboot_avago_tx_atten_set_per_lane(ah, chip, ring, serdes,
 						  tx_atten);
-			mdelay(50);
-		}
+		mdelay(50);
+	}
+}
+
+/**
+ * Sets the speed and fec
+ *
+ * @param	ah		Avago handle
+ * @param	chip		chip number
+ * @param	ring		ring number
+ * @param	enable_10g	Enable 10G or 25G
+ * @param	enable_fec	Enable fec
+ *
+ * @return	0 for success, otherwise error
+ */
+static int uboot_garnet_set_speed(struct avago_hdl *ah, uint32_t chip,
+				  uint32_t ring, bool enable_10g, bool enable_fec)
+{
+	int i, rc;
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"Configuring for %dG operation\n", enable_10g ? 10 : 25);
+
+	if (enable_10g) {
+		/* Low byte is the multiplier for 161MHz clock */
+		rc = avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd),
+				     0x24, 0x0040);
+	} else {
+		rc = avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd),
+				     0x24, enable_fec ? 0x40a0: 0x80a0);
+	}
+
+	if (!rc)
+		printf("%s: Error %sabling FEC and Setting Speed\n", __func__,
+		       enable_fec ? "en" : "dis");
+
+        for (i = 0; i < 1000; i++) {
+                rc = avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd),
+                        0x26, 0x3400);
+                if (rc & 0x200)
+                        break;
+                mdelay(1);
+        }
+
+	return ((i == 1000) ? 1 : 0);
 }
 
 /**
@@ -181,18 +234,17 @@ int uboot_garnet_set_fec(int i2c_bus, in
 	struct avago_hdl *ah;
 	int rc;
 	int old_i2c_bus = i2c_get_bus_num();
+	bool enable_avago_hw_self_heal = getenv_yesno("enable_avago_hw_self_heal") > 0;
+
+	i2c_set_bus_num(i2c_bus);
 
 	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
 	if (!ah)
 		return -1;
 
-	i2c_set_bus_num(i2c_bus);
+	avago_init_ip_info(ah, false);
 
-	if (enable_10g) {
-		/* Low byte is the multiplier for 161MHz clock */
-		rc = avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd),
-				     0x24, 0x0040);
-	} else {
+	if (enable_avago_hw_self_heal) {
 		/* Disable supervisor */
 		rc = avsp_supervisor_enable(ah, chip, false);
 		if (rc) {
@@ -200,22 +252,26 @@ int uboot_garnet_set_fec(int i2c_bus, in
 			       __func__, i2c_bus, i2c_base_addr);
 			goto error;
 		}
-		rc = avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd),
-				     0x24, enable_fec ? 0x40a0: 0x80a0);
-		if (rc) {
-			printf("%s: Error %sbling the FEC for %x:%x\n",
-			       __func__, enable_fec ? "ena" : "dis",
-			       i2c_bus, i2c_base_addr);
-			goto error;
+ 	}
+ 
+	rc =  uboot_garnet_set_speed(ah, chip, ring, enable_10g, enable_fec);
+	if (rc) {
+		printf("%s: Error %sbling the FEC for %x:%x\n",
+			__func__, enable_fec ? "ena" : "dis",
+			i2c_bus, i2c_base_addr);
+		goto error;
 	}
+
+	if (enable_avago_hw_self_heal) {
 		/* Enable the supervisor */
 		rc = avsp_supervisor_enable(ah, chip, true);
 	}
-error:
-	free(ah);
 
+error:
 	i2c_set_bus_num(old_i2c_bus);
 
+	free(ah);
+
 	return rc;
 }
 
@@ -223,31 +279,29 @@ int uboot_garnet_init(int i2c_bus, int i
 		     uint32_t ring, bool enable_fec, uint32_t host_tx_atten,
 		     struct avago_serdes_tx_eq *line_tx_eq, bool enable_10g)
 {
-	const int serdes_rom_size = ARRAY_SIZE(avago_serdes_2264_0241_rom);
 	const bool squelch_tx = true;
 	const bool run_adaptive = false;
 	const enum avsp_supervisor_mode run_mode =
 			AVSP_SUPERVISOR_MODE_TUNE_IF_LOCKED_SIGNAL;
+	enum avsp_mode chip_mode = AVSP_5410_CHIP_MODE(enable_10g, enable_fec);
 	const char *device_name;
 	const int electrical_idle_threshold = 0;
 	const uint32_t *sbus_rom;
 	struct avago_hdl *ah;
-	int rc;
+	int i, count, retries1, retries2, retries3, rc, serdes;
+	int serdes_rom_size;
 	int sbus_rom_size;
-	bool reuse_ical = true;
+	bool enabled, reuse_ical = true;
 	struct avsp_supervisor_config self_heal_config;
-	bool disable_self_heal = getenv_yesno("disable_avago_heal") > 0;
+	bool enable_avago_hw_self_heal = getenv_yesno("enable_avago_hw_self_heal") > 0;
+	int old_i2c_bus = i2c_get_bus_num();
 	int old_i2c_speed;
 
-	debug("%s(0x%x, 0x%x, 0x%x, %s)\n", __func__, i2c_bus, i2c_base_addr,
-	      chip, enable_fec ? "enabled" : "disabled");
-
 	avago_debug_level = getenv_ulong("avago_debug_level", 10, 0);
 
-	if (avago_debug_level)
-		printf("%s(i2c bus: %d, i2c base addr: 0x%x, chip: %d, ring: 0x%x, FEC: %sabled): debug level: %d\n",
-		       __func__, i2c_bus, i2c_base_addr, chip, ring,
-		       enable_fec ? "en" : "dis", avago_debug_level);
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"i2c bus: 0x%x, i2c base addr: 0x%x, chip: 0x%x, fec: %s\n",
+			i2c_bus, i2c_base_addr, chip, enable_fec ? "enabled" : "disabled");
 
 	i2c_set_bus_num(i2c_bus);
 	old_i2c_speed = i2c_get_bus_speed();
@@ -257,64 +311,76 @@ int uboot_garnet_init(int i2c_bus, int i
 	if (!ah)
 		return -1;
 
-	debug("%s: Initializing IP\n", __func__);
+	count = 0;
+	retries1 = 0;
+	retries2 = 0;
+	retries3 = 0;
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Initializing IP\n");
 	avago_init_ip_info(ah, true);	/* Reset chip */
 	mdelay(100);
-	debug("%s: Getting chip name\n", __func__);
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Getting chip name\n");
 	device_name = avago_get_chip_name(ah, avago_make_addr3(chip, ring, 0));
 	if (ah->return_code < 0) {
 		printf("%s: Error getting device info and name\n", __func__);
-		return -1;
+		rc = 1;
+		goto __garnet_init_exit;
 	}
-	debug("%s: device name: %s\n", __func__, device_name);
 
-		sbus_rom_size = ARRAY_SIZE(avago_sbus_master_0704_heal_rom);
-		sbus_rom = avago_sbus_master_0704_heal_rom;
-		debug("Loading self-healing SBus ROM, size: %u bytes\n",
-		      sbus_rom_size);
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"device name: %s\n", device_name);
+
+	serdes_rom_size = ARRAY_SIZE(avago_serdes_4064_0241_rom);
+	sbus_rom_size = ARRAY_SIZE(avago_sbus_master_041f_0704_heal_rom);
+	sbus_rom = avago_sbus_master_041f_0704_heal_rom;
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"Loading self-healing SBus ROM, size: %u bytes\n",
+	      		sbus_rom_size);
 
+__garnet_init:
 	rc = avsp_upload_firmware_u32(ah, chip, false,
 				      serdes_rom_size,
-				      avago_serdes_2264_0241_rom,
+				      avago_serdes_4064_0241_rom,
 				      sbus_rom_size, sbus_rom);
 	if (rc) {
 		printf("%s: Error uploading firmware\n", __func__);
-		return -1;
+		goto __garnet_init_exit;
 	}
-	debug("Firmware upload complete.\n");
-	/*avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd), 0x26, 0x5b01); */
 
-	if (!disable_self_heal) {
-		debug("Self-healing enabled, initializing supervisor config\n");
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Firmware upload complete.\n");
+
+	if (enable_avago_hw_self_heal) {
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+				"Avago hardware Self-healing enabled, initializing supervisor config\n");
 		reuse_ical = false;
 		avsp_supervisor_config_init(ah, run_mode, squelch_tx, reuse_ical,
 					run_adaptive, &self_heal_config);
 		/* Turn on self-healing */
-		debug("Set self healing config\n");
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Set self healing config\n");
 		avsp_supervisor_set_config(ah, 0, &self_heal_config);
-		debug("Setting signal OK electrical idle threshold to %d\n",
-		      electrical_idle_threshold);
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"Setting signal OK electrical idle threshold to %d\n",
+		      	electrical_idle_threshold);
 		avsp_supervisor_set_signal_ok(ah, 0, 0x2f,
 					      electrical_idle_threshold);
+	} else {
+        	/* configure self-healing not to run automatically as part of state-ing */
+        	avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd), 0x26, 0x6207);
 	}
 
-	debug("%s: Configuring for %dG operation\n", __func__,
-	      enable_10g ? 10 : 25);
-	if (enable_10g) {
-		/* Low byte is the multiplier for 161MHz clock */
-		rc = avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd),
-				     0x24, 0x0040);
-	} else {
-	rc = avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd),
-			     0x24, enable_fec ? 0x40a0: 0x80a0);
+	rc =  uboot_garnet_set_speed(ah, chip, ring, enable_10g, enable_fec);
+
+	if (rc) {
+		if (count++ < 10) {
+			printf("%s: Reinitializing chip\n", __func__);
+			goto __garnet_init;
+		} else {
+			printf("%s: Giving up\n", __func__);
+			goto __garnet_init_exit;
+		}
 	}
-	if (!rc)
-		printf("%s: Error %sabling FEC\n", __func__,
-		       enable_fec ? "en" : "dis");
-	else
-		debug("FEC is on\n");
 
-	if (!disable_self_heal) {
+	if (enable_avago_hw_self_heal) {
 		/* Change self-healing mode from TUNE_IF_LOCKED_SIGNAL to
 		 * TUNE_IF_SIGNAL.  The former waits for both frequency lock
 		 * and signal amplitude, the latter just checks signal
@@ -324,17 +390,17 @@ int uboot_garnet_init(int i2c_bus, int i
 				     0x26, 0x6206);
 
 		/* 0x4400 = ON, 0x4500 = OFF */
-		debug("stop supervisor\n");
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "stop supervisor\n");
 		avsp_supervisor_enable(ah, 0, FALSE);
 
-		/* set elec idle threshold to 11 */
-		debug("elec idle threshold = 11\n");
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+				"host-side serdes elec idle threshold = 11\n");
 		avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd), 0x25, 0x002a);
 		avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd), 0x25, 0x006c);
 		avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd), 0x25, 0x008b);
 
 		/* RX_TERM to GND */
-		 debug("RX_TERM to GND\n");
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "RX_TERM to GND\n");
 		avago_serdes_set_rx_term(ah,avago_make_addr3(chip, ring, 0x5),
 					 AVAGO_SERDES_RX_TERM_AGND);
 		avago_serdes_set_rx_term(ah,avago_make_addr3(chip, ring, 0x6),
@@ -346,22 +412,710 @@ int uboot_garnet_init(int i2c_bus, int i
 		avago_serdes_set_rx_term(ah,avago_make_addr3(chip, ring, 0x9),
 					 AVAGO_SERDES_RX_TERM_AGND);
 
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+				"Host tx attenuation is set to %d\n", host_tx_atten);
+		uboot_avago_tx_atten_set(ah, chip, ring, host_tx_atten);
+
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+                		"Setting module-side tx equalization\n");
+		rc = avago_serdes_set_tx_eq(ah, avago_make_addr3(chip, ring, 5),
+				    line_tx_eq);
+
 		/* start supervisor again */
-		debug("start supervisor\n");
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "start supervisor\n");
 		avsp_supervisor_enable(ah, 0, TRUE);
+		mdelay(500);
+
+	} else {
+		udelay(50000);
+		enabled = TRUE;
+		/* Make sure supervisor is not enabled */
+		for (i = 0; i < 10; i++) {
+			if (!avsp_supervisor_status(ah, chip, &enabled)) {
+				if (!enabled) {
+					break;
+				} else {
+					if (!avsp_supervisor_enable(ah, chip, FALSE)) {
+						enabled = FALSE;
+						break;
+					}
+				}
+			}
+		}
+		
+		if (enabled) {
+			printf("%s: Supervisor is still enabled\n", __func__);
+			rc = 1;
+			goto __garnet_init_exit;
+		}
+
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Supervisor disabled\n");
+
+        	/* squelch tx of serdeses */
+        	for (serdes = 5; serdes <= 9; serdes++) {
+                	if (avago_serdes_set_tx_rx_enable(ah, avago_make_addr3(chip, ring, serdes),true,true,false)) {
+				if (retries1++ < 5) {
+					avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+							"Failed to disable SERDES %d trasmitor. Resetting.\n", serdes);
+		
+					goto __garnet_init;
+				} else {
+					avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Giving up\n");
+					rc = 1;
+					goto __garnet_init_exit;
+				}
+			}
+        	}
+
+		if (!(rc = avsp_5410_init_ok(ah, chip_mode, chip, ring))) {
+			if (retries2++ < 5) {
+				avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+						"avsp_5410_init_ok failed. Retrying ....\n");	
+				goto __garnet_init;
+			} else {
+				avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Giving up\n");
+				rc = 1;
+				goto __garnet_init_exit;
+			}
+		}
+
+		if ((rc = avsp_5410_bootstrap(ah, chip_mode, chip, ring, host_tx_atten))) {
+			if (retries3++ < 5) {
+				avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+						"avsp_5410_bootstrap failed. Retrying ....\n");	
+				goto __garnet_init;
+			} else {
+				avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Giving up\n");
+				rc = 1;
+				goto __garnet_init_exit;
+			}
+		}
+
+		rc = uboot_garnet_host_tuning(i2c_bus, i2c_base_addr, chip, ring, enable_fec, host_tx_atten, enable_10g);
 	}
 
-	/*avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd), 0xa, 0x81);*/
+__garnet_init_exit:
+
+	i2c_set_bus_speed(old_i2c_speed);
+
+	i2c_set_bus_num(old_i2c_bus);
+
+	if (ah)
+		free(ah);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Exit status %d\n", rc);
+
+	return rc ? -1 : 0;
+}
+
+int uboot_garnet_reinit(int i2c_bus, int i2c_base_addr, uint32_t chip,
+		     uint32_t ring, bool enable_fec, uint32_t host_tx_atten,
+		     bool enable_10g, bool reset)
+{
+	struct avago_hdl *ah;
+	int count, retries1, retries2, retries3, rc, serdes;
+	int old_i2c_bus = i2c_get_bus_num();
+	int old_i2c_speed;
+	enum avsp_mode chip_mode = AVSP_5410_CHIP_MODE(enable_10g, enable_fec);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"i2c bus: 0x%x, i2c base addr: 0x%x, chip: 0x%x, fec: %s\n",
+			i2c_bus, i2c_base_addr, chip, enable_fec ? "enabled" : "disabled");
+
+	i2c_set_bus_num(i2c_bus);
+	old_i2c_speed = i2c_get_bus_speed();
+	i2c_set_bus_speed(400000);
+
+	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
+	if (!ah)
+		return -1;
+
+	count = 0;
+	retries1 = 0;
+	retries2 = 0;
+	retries3 = 0;
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Initializing IP\n");
+	avago_init_ip_info(ah, false);
+
+__garnet_reinit:
+
+	if (reset) {
+		rc =  uboot_garnet_set_speed(ah, chip, ring, enable_10g, enable_fec);
+
+		if (rc) {
+			if (count++ < 10) {
+				udelay(50000);
+				printf("%s: Reinitializing chip\n", __func__);
+				goto __garnet_reinit;
+			} else {
+				printf("%s: Giving up\n", __func__);
+				goto __garnet_reinit_exit;
+			}
+		}
+
+		udelay(50000);
+	}
+
+        /* squelch tx of serdeses */
+        for (serdes = 5; serdes <= 9; serdes++) {
+     		if (avago_serdes_set_tx_rx_enable(ah, avago_make_addr3(chip, ring, serdes),true,true,false)) {
+			if (retries1++ < 5) {
+				avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+						"Failed to disable SERDES %d transmitter. Resetting.\n", serdes);
+		
+				goto __garnet_reinit;
+			} else {
+				avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Giving up\n");
+				rc = 1;
+				goto __garnet_reinit_exit;
+			}
+		}
+       	}
+
+	if (!(rc = avsp_5410_init_ok(ah, chip_mode, chip, ring))) {
+		if (retries2++ < 5) {
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"avsp_5410_init_ok failed. Retrying ....\n");	
+			goto __garnet_reinit;
+		} else {
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Giving up\n");
+			rc = 1;
+			goto __garnet_reinit_exit;
+		}
+	}
+
+	if ((rc = avsp_5410_bootstrap(ah, chip_mode, chip, ring, host_tx_atten))) {
+		if (retries3++ < 5) {
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"avsp_5410_bootstrap failed. Retrying ....\n");	
+			goto __garnet_reinit;
+		} else {
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Giving up\n");
+			rc = 1;
+			goto __garnet_reinit_exit;
+		}
+	}
+
+	if (!(rc = uboot_garnet_host_tuning(i2c_bus, i2c_base_addr, chip, ring, enable_fec, host_tx_atten, enable_10g))) {
+
+		rc = avago_serdes_set_tx_output_enable(ah, avago_make_addr3(chip, ring, 5), TRUE);
+	}
+
+__garnet_reinit_exit:
 
-	mdelay(500);
-	debug("Host tx attenuation is set to %d\n", host_tx_atten);
-	uboot_avago_tx_atten_set(ah, chip, ring, host_tx_atten);
-	rc = avago_serdes_set_tx_eq(ah, avago_make_addr3(chip, ring, 5),
-				    line_tx_eq);
-	/* uboot_avago_line_tx_atten(ah, chip, ring, line_tx_atten);*/
 	i2c_set_bus_speed(old_i2c_speed);
+
+	i2c_set_bus_num(old_i2c_bus);
+
 	if (ah)
 		free(ah);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Exit status %d\n", rc);
+
+	return rc ? -1 : 0;
+}
+
+int uboot_garnet_supervisor_disable(int i2c_bus, int i2c_base_addr, uint32_t chip,
+		     uint32_t ring, bool enable_fec, uint32_t host_tx_atten,
+		     bool enable_10g)
+{
+	int rc = 0, i;
+	bool enabled = TRUE;
+	struct avago_hdl *ah;
+	int old_i2c_bus = i2c_get_bus_num();
+	int old_i2c_speed;
+	enum avsp_mode chip_mode = AVSP_5410_CHIP_MODE(enable_10g, enable_fec);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"i2c bus: 0x%x, i2c base addr: 0x%x, chip: 0x%x, fec: %s\n",
+			i2c_bus, i2c_base_addr, chip, enable_fec ? "enabled" : "disabled");
+
+	i2c_set_bus_num(i2c_bus);
+
+	old_i2c_speed = i2c_get_bus_speed();
+
+	i2c_set_bus_speed(400000);
+
+	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
+
+	if (ah) {
+		avago_init_ip_info(ah, false);
+
+		for (i = 0; i < 10; i++) {
+			if (!avsp_supervisor_status(ah, chip, &enabled)) {
+				if (enabled) {
+					if (!avsp_supervisor_enable(ah, chip, FALSE)) {
+						enabled = FALSE;
+					}
+				}
+			}
+
+			if (!enabled)
+				break;
+
+			if (i == 0) {
+        			/* configure self-healing not to run automatically as part of state-ing */
+        			avago_spico_int(ah, avago_make_addr3(chip, ring, 0xfd), 0x26, 0x6207);
+			}
+
+			uboot_garnet_reinit(i2c_bus, i2c_base_addr, chip, ring, enable_fec, host_tx_atten, enable_10g, TRUE);
+		}
+			
+		if (enabled) {
+			printf("%s: Supervisor is still enabled\n", __func__);
+			rc = 1;
+		} else
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Supervisor disabled\n");
+
+		free(ah);
+	}
+
+	i2c_set_bus_speed(old_i2c_speed);
+
+	i2c_set_bus_num(old_i2c_bus);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Exit status %d\n", rc);
+
+	return rc ? -1 : 0;
+}
+
+int uboot_garnet_host_tuning(int i2c_bus, int i2c_base_addr, uint32_t chip,
+		     uint32_t ring, bool enable_fec, uint32_t host_tx_atten,
+		     bool enable_10g)
+{
+	int rc = 1, i;
+	struct avago_hdl *ah;
+	int old_i2c_bus = i2c_get_bus_num();
+	int old_i2c_speed;
+	enum avsp_mode chip_mode = AVSP_5410_CHIP_MODE(enable_10g, enable_fec);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"i2c bus: 0x%x, i2c base addr: 0x%x, chip: 0x%x, fec: %s\n",
+			i2c_bus, i2c_base_addr, chip, enable_fec ? "enabled" : "disabled");
+
+	i2c_set_bus_num(i2c_bus);
+
+	old_i2c_speed = i2c_get_bus_speed();
+
+	i2c_set_bus_speed(400000);
+
+	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
+	if (ah) {
+		avago_init_ip_info(ah, false);
+
+		for (i = 0; i < 5; i++) {
+			if (i > 1) {
+				avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+						"Calling uboot_garnet_init\n");
+				uboot_garnet_reinit(i2c_bus, i2c_base_addr, chip, ring, enable_fec, host_tx_atten, enable_10g, (i>2));
+			}
+
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"Calling sw_self_healing_host_freq_lock_cal\n");
+			if (!(rc = sw_self_healing_host_freq_lock_cal(ah, chip_mode, chip, ring)))
+				break;
+		}
+
+		free(ah);
+	}
+
+	i2c_set_bus_speed(old_i2c_speed);
+
+	i2c_set_bus_num(old_i2c_bus);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Exit status %d\n", rc);
+
+	return rc ? -1 : 0;
+}
+
+int uboot_garnet_mod_config(int i2c_bus, int i2c_base_addr, uint32_t chip, uint32_t ring, bool is_active, bool is_10g)
+{
+	int rc = 1;
+	struct avago_hdl *ah;
+	int old_i2c_bus = i2c_get_bus_num();
+	int old_i2c_speed;
+	struct avago_serdes_tx_eq tx_eq;
+
+	debug("%s(%d, 0x%x, %d, %d, %d, %d)\n", __func__, i2c_bus, i2c_base_addr, chip, ring, is_active, is_10g);
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"i2c bus: 0x%x, i2c base addr: 0x%x, chip: 0x%x, is_active: %s, is_10g: %s\n",
+			i2c_bus, i2c_base_addr, chip, is_active ? "yes" : "no", is_10g ? "yes" : "no");
+
+	i2c_set_bus_num(i2c_bus);
+
+	old_i2c_speed = i2c_get_bus_speed();
+
+	i2c_set_bus_speed(400000);
+
+	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
+	if (ah) {
+		avago_init_ip_info(ah, false);
+
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+				"Calling avago_serdes_get_tx_eq\n");
+		if (!avago_serdes_get_tx_eq(ah, avago_make_addr3(chip, ring, 5), &tx_eq)){
+			tx_eq.pre = 0;
+			tx_eq.atten = (is_10g) ? 14 : ((is_active) ? 8 : 0);
+			tx_eq.post = 0;
+
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					 "Calling avago_serdes_set_tx_eq\n");
+			if (!avago_serdes_set_tx_eq(ah, avago_make_addr3(chip, ring, 5), &tx_eq))
+				rc = 0;
+		}
+
+		free(ah);
+	}
+
+	i2c_set_bus_speed(old_i2c_speed);
+
+	i2c_set_bus_num(old_i2c_bus);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Exit status %d\n", rc);
+
+	return rc ? -1 : 0;
+}
+
+int uboot_garnet_mod_tuning(int i2c_bus, int i2c_base_addr, uint32_t chip,
+		     uint32_t ring, bool enable_fec, uint32_t host_tx_atten,
+		     bool enable_10g)
+{
+	int rc = 1, reinit_required = TRUE;
+	struct avago_hdl *ah;
+	int iterations = 0;
+	int dfe_timeout_los_retries = 0;
+	int dfe_sig_chk_retries = 0;
+	int old_i2c_bus = i2c_get_bus_num();
+	int old_i2c_speed;
+	enum avsp_mode chip_mode = AVSP_5410_CHIP_MODE(enable_10g, enable_fec);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"i2c bus: 0x%x, i2c base addr: 0x%x, chip: 0x%x, ring: 0x%x\n",
+			i2c_bus, i2c_base_addr, chip, ring);
+
+	i2c_set_bus_num(i2c_bus);
+
+	old_i2c_speed = i2c_get_bus_speed();
+
+	i2c_set_bus_speed(400000);
+
+	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
+	if (ah) {
+		avago_init_ip_info(ah, false);
+
+		while (1) {
+			iterations++;
+
+			if (iterations > 2) {
+				if (!avsp_5410_init_ok(ah, chip_mode, chip, ring)) {
+					avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+						"avsp_5410_init_ok failed.\n");
+					break;
+				}
+			}
+	
+
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"Calling sw_self_healing_ei_debounce\n");
+			if (!sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, 5), 4, 5)) {
+				reinit_required = FALSE;
+				avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"sw_self_healing_ei_debounce failed.\n");
+				break;
+			}
+
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"sw_self_healing_ei_debounce success.\n");
+
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"Calling sw_self_healing_force_heal_mod\n");
+			rc = sw_self_healing_force_heal_mod(ah, chip_mode, chip, ring);
+
+			switch (rc) {
+				case 0:
+					avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+							"sw_self_healing_force_heal_mod success\n");
+					reinit_required = FALSE;
+					break;
+
+				case 1:
+					avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+							"sw_self_healing_force_heal_mod failed rc=1\n");
+					mdelay(250);
+					if (dfe_timeout_los_retries++ < 20)
+						continue;
+					break;
+					
+				case 2:
+					avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+							"sw_self_healing_force_heal_mod failed rc=2\n");
+					mdelay(250);
+					if (dfe_timeout_los_retries++ < 20)
+						continue;
+					break;
+				case 3:	
+					avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+							"sw_self_healing_force_heal_mod failed rc=3\n");
+					mdelay(250);
+					if (dfe_sig_chk_retries++ < 3)
+						continue;
+					break;
+
+				default:
+					break;
+			}
+
+
+			if (reinit_required) {
+				uboot_garnet_reinit(i2c_bus, i2c_base_addr, chip, ring, enable_fec, host_tx_atten, enable_10g, TRUE);
+			}
+
+			break;
+		}
+
+		free(ah);
+	}
+
+	i2c_set_bus_speed(old_i2c_speed);
+
+	i2c_set_bus_num(old_i2c_bus);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Exit status %d\n", rc);
+
+	return rc ? -1 : 0;
+}
+
+int uboot_garnet_init_ok(int i2c_bus, int i2c_base_addr, uint32_t chip, uint32_t ring, bool enable_fec, bool enable_10g)
+{
+	enum avsp_mode chip_mode = AVSP_5410_CHIP_MODE(enable_10g, enable_fec);
+	struct avago_hdl *ah;
+	int old_i2c_speed, old_i2c_bus;
+	int rc = 0;
+
+	old_i2c_bus = i2c_get_bus_num();
+	i2c_set_bus_num(i2c_bus);
+	old_i2c_speed = i2c_get_bus_speed();
+	i2c_set_bus_speed(400000);
+
+	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
+	if (ah) {
+		avago_init_ip_info(ah, false);
+		rc = avsp_5410_init_ok(ah, chip_mode, chip, ring);
+		free(ah);
+	}
+
+	i2c_set_bus_speed(old_i2c_speed);
+	i2c_set_bus_num(old_i2c_bus);
+	return rc;
+}
+
+int uboot_garnet_ei_debounce(int i2c_bus, int i2c_base_addr, uint32_t chip, uint32_t ring)
+{
+	struct avago_hdl *ah;
+	int old_i2c_speed, old_i2c_bus;
+	int rc = 0;
+
+	old_i2c_bus = i2c_get_bus_num();
+	i2c_set_bus_num(i2c_bus);
+	old_i2c_speed = i2c_get_bus_speed();
+	i2c_set_bus_speed(400000);
+
+	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
+	if (ah) {
+		avago_init_ip_info(ah, false);
+		rc = sw_self_healing_ei_debounce(ah, avago_make_addr3(chip, ring, 5), 4, 5);
+		free(ah);
+	}
+
+	i2c_set_bus_speed(old_i2c_speed);
+	i2c_set_bus_num(old_i2c_bus);
+	return rc;
+}
+
+int uboot_garnet_force_heal_mod(int i2c_bus, int i2c_base_addr, uint32_t chip, uint32_t ring, bool enable_fec, bool enable_10g)
+{
+	enum avsp_mode chip_mode = AVSP_5410_CHIP_MODE(enable_10g, enable_fec);
+	struct avago_hdl *ah;
+	int old_i2c_speed, old_i2c_bus;
+	int rc = 1;
+
+	old_i2c_bus = i2c_get_bus_num();
+	i2c_set_bus_num(i2c_bus);
+	old_i2c_speed = i2c_get_bus_speed();
+	i2c_set_bus_speed(400000);
+
+	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
+	if (ah) {
+		avago_init_ip_info(ah, false);
+		rc = sw_self_healing_force_heal_mod(ah, chip_mode, chip, ring);
+		free(ah);
+	}
+
+	i2c_set_bus_speed(old_i2c_speed);
+	i2c_set_bus_num(old_i2c_bus);
+	return rc;
+}
+
+int uboot_garnet_temparature_get(int i2c_bus, int i2c_base_addr, uint32_t chip, uint32_t ring)
+{
+	int cur_temp = 0;
+	struct avago_hdl *ah;
+	int old_i2c_bus = i2c_get_bus_num();
+	int old_i2c_speed;
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"i2c bus: 0x%x, i2c base addr: 0x%x, chip: 0x%x, ring: 0x%x\n",
+			i2c_bus, i2c_base_addr, chip, ring);
+
+	i2c_set_bus_num(i2c_bus);
+
+	old_i2c_speed = i2c_get_bus_speed();
+
+	i2c_set_bus_speed(400000);
+
+	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
+
+	if (ah) {
+
+		avago_init_ip_info(ah, false);
+
+		cur_temp = avago_sensor_get_temperature(ah, 1, 0, 0) / 1000;
+
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+				"avago_sensor_get_temperature %d\n", cur_temp);
+
+		if (cur_temp < -40) {
+			/* Re-initialize the temperature sensor */
+			avago_sensor_get_temperature(ah, 1, 0, 161132813);
+			cur_temp = avago_sensor_get_temperature(ah, 1, 0, 0) / 1000;
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"avago_sensor_get_temperature %d\n", cur_temp);
+		}
+
+		free(ah);
+	}
+
+	i2c_set_bus_speed(old_i2c_speed);
+
+	i2c_set_bus_num(old_i2c_bus);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Exit\n");
+
+	return cur_temp;
+}
+
+int uboot_garnet_temparature_check(int i2c_bus, int i2c_base_addr, uint32_t chip, uint32_t ring, int *last_tune_temp)
+{
+	int cur_temp = 0, rc = 0;
+	struct avago_hdl *ah;
+	int old_i2c_bus = i2c_get_bus_num();
+	int old_i2c_speed;
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"i2c bus: 0x%x, i2c base addr: 0x%x, chip: 0x%x, ring: 0x%x, last_tune_temp: %d\n",
+			i2c_bus, i2c_base_addr, chip, ring, *last_tune_temp);
+
+	i2c_set_bus_num(i2c_bus);
+
+	old_i2c_speed = i2c_get_bus_speed();
+
+	i2c_set_bus_speed(400000);
+
+	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
+
+	if (ah) {
+
+		avago_init_ip_info(ah, false);
+
+		cur_temp = avago_sensor_get_temperature(ah, 1, 0, 0) / 1000;
+
+		avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+				"avago_sensor_get_temperature %d\n", cur_temp);
+
+		if (cur_temp < -40) {
+			/* Re-initialize the temperature sensor */
+			avago_sensor_get_temperature(ah, 1, 0, 161132813);
+			cur_temp = avago_sensor_get_temperature(ah, 1, 0, 0) / 1000;
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"avago_sensor_get_temperature %d\n", cur_temp);
+		}
+
+		if (cur_temp > -40) {
+
+			if (abs(cur_temp - *last_tune_temp) > 10) {
+				avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+						"Calling avago_serdes_pcal_tune\n");
+				rc = avago_serdes_pcal_tune(ah, chip, ring, 5, 1000);
+				*last_tune_temp = cur_temp;
+			}
+
+		} else {
+			rc = 1;
+		}
+
+		free(ah);
+	}
+
+	i2c_set_bus_speed(old_i2c_speed);
+
+	i2c_set_bus_num(old_i2c_bus);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Exit status %d\n", rc);
+
+	return rc ? -1 : 0;
+}
+
+int uboot_garnet_tx_enable(int i2c_bus, int i2c_base_addr, uint32_t chip, uint32_t ring, bool enable)
+{
+	int rc = 1;
+	struct avago_hdl *ah;
+	int old_i2c_bus = i2c_get_bus_num();
+	int old_i2c_speed;
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"i2c bus: 0x%x, i2c base addr: 0x%x, chip: 0x%x, ring: 0x%x, enable: 0x%x\n",
+			i2c_bus, i2c_base_addr, chip, ring, enable);
+
+	i2c_set_bus_num(i2c_bus);
+
+	old_i2c_speed = i2c_get_bus_speed();
+
+	i2c_set_bus_speed(400000);
+
+	ah = avago_init_handle(i2c_bus, i2c_base_addr, chip, ring);
+
+	if (ah) {
+
+		avago_init_ip_info(ah, false);
+
+		if (enable) {
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"Calling avago_serdes_get_tx_output_enable\n");
+                	if (!avago_serdes_get_tx_output_enable(ah, avago_make_addr3(chip, ring, 5))) {
+				avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+						"Calling avago_serdes_set_tx_output_enable\n");
+                        	rc = avago_serdes_set_tx_output_enable(ah, avago_make_addr3(chip, ring, 5), enable);
+			}
+		} else {
+			avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+					"Calling avago_serdes_get_tx_output_enable\n");
+                	if (avago_serdes_get_tx_output_enable(ah, avago_make_addr3(chip, ring, 5))) {
+				avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+						"Calling avago_serdes_set_tx_output_enable\n");
+                        	rc = avago_serdes_set_tx_output_enable(ah, avago_make_addr3(chip, ring, 5), enable);
+			}
+		}
+
+		free(ah);
+	}
+
+	i2c_set_bus_speed(old_i2c_speed);
+
+	i2c_set_bus_num(old_i2c_bus);
+
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__, "Exit status %d\n", rc);
+
 	return rc ? -1 : 0;
 }
 
@@ -504,12 +1258,14 @@ static int do_serdes_int(cmd_tbl_t *cmdt
 	ah = avago_init_handle(0, 0x4e, chip, ring);
 	avago_init_ip_info(ah, false);
 	device_name = avago_get_chip_name(ah, avago_make_addr3(chip, ring, 0));
-	debug("Sending interrupt 0x%x with data 0x%x to %s at %x:%x:%x\n",
-	       interrupt, data, device_name, chip, ring, sbus_addr);
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"Sending interrupt 0x%x with data 0x%x to %s at %x:%x:%x\n",
+	       		interrupt, data, device_name, chip, ring, sbus_addr);
 
 	ret_data = avago_spico_int(ah, avago_make_addr3(chip, ring, sbus_addr),
 				   interrupt, data);
-	debug("Interrupt 0x%x returned 0x%x\n", interrupt, ret_data);
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"Interrupt 0x%x returned 0x%x\n", interrupt, ret_data);
 	if (ah)
 		free(ah);
 	return CMD_RET_SUCCESS;
@@ -532,8 +1288,9 @@ static int do_serdes_tx_invert(cmd_tbl_t
 	avago_init_ip_info(ah, false);
 	device_name = avago_get_chip_name(ah, avago_make_addr3(chip, ring,
 							       sbus_addr));
-	debug("%sabling tx inversion for SerDes on %s at %x:%x:%x\n",
-	       invert ? "Ena" : "Dis", device_name, chip, ring,  sbus_addr);
+	avago_log_printf(ah, AVAGO_DEBUG1, __func__, __LINE__,
+			"%sabling tx inversion for SerDes on %s at %x:%x:%x\n",
+	       		invert ? "Ena" : "Dis", device_name, chip, ring,  sbus_addr);
 
 	avago_serdes_set_tx_invert(ah, avago_make_addr3(chip, ring, sbus_addr),
 				   invert);
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/nic225e/nic225e_board.c OCTEON-SDK/bootloader/u-boot/board/octeon/nic225e/nic225e_board.c
--- OCTEON_SDK_CLEAN/bootloader/u-boot/board/octeon/nic225e/nic225e_board.c	2018-05-15 11:35:37.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/board/octeon/nic225e/nic225e_board.c	2018-06-28 15:08:31.079008792 -0700
@@ -23,6 +23,7 @@
 #include <asm/arch/cvmx-helper-board.h>
 #include <asm/arch/octeon_pci.h>
 #include <asm/arch/cvmx-rst-defs.h>
+#include <asm/arch/seapi_public.h>
 #include <malloc.h>
 #include "../common/phy/avago.h"
 #include "../common/phy/avago_avsp.h"
@@ -42,12 +43,48 @@ DECLARE_GLOBAL_DATA_PTR;
 static bool eth0_10g = false;
 static bool eth1_10g = false;
 static bool avago_initialized = false;
+static bool monitor_ethx_ports[2] = {false, false};
+static bool module_is_present[2] = {false, false};
+static bool module_status_changed[2] = {false, false};
+static bool rx_los_present[2] = {false, false};
+static bool tx_fault_present[2] = {false, false};
+static int  last_tune_temp[2] = {0, 0};
+static struct phy_sfp_info sfp_info[2] = {{0}, {0}};
+static bool sfp_info_valid[2] = {false, false};
+static unsigned long long last_temp_check[2] = {0, 0};
 
 extern int uboot_garnet_init(int i2c_bus, int i2c_base_addr, uint32_t chip,
 			     uint32_t ring, bool enable_fec,
 			     uint32_t host_tx_atten,
 			     struct avago_serdes_tx_eq *line_tx_eq,
 			     bool enable_10g);
+int uboot_garnet_reinit(int i2c_bus, int i2c_base_addr, uint32_t chip,
+                        uint32_t ring, bool enable_fec, uint32_t host_tx_atten,
+                        bool enable_10g, bool reset);
+extern int uboot_garnet_supervisor_disable(int i2c_bus, int i2c_base_addr,
+					   uint32_t chip, uint32_t ring,
+					   bool enable_fec, uint32_t host_tx_atten,
+					   bool enable_10g);
+extern int uboot_garnet_host_tuning(int i2c_bus, int i2c_base_addr, uint32_t chip,
+			            uint32_t ring, bool enable_fec,
+			            uint32_t host_tx_atten,
+			            bool enable_10g);
+extern int uboot_garnet_mod_config(int i2c_bus, int i2c_base_addr, uint32_t chip,
+				   uint32_t ring, bool is_active, bool is_10g);
+extern int uboot_garnet_mod_tuning(int i2c_bus, int i2c_base_addr, uint32_t chip,
+                     		   uint32_t ring, bool enable_fec, uint32_t host_tx_atten,
+                     		   bool enable_10g);
+extern int uboot_garnet_temparature_get(int i2c_bus, int i2c_base_addr,
+					uint32_t chip, uint32_t ring);
+extern int uboot_garnet_temparature_check(int i2c_bus, int i2c_base_addr, uint32_t chip,
+					  uint32_t ring, int *last_tune_temp);
+extern int uboot_garnet_tx_enable(int i2c_bus, int i2c_base_addr, uint32_t chip,
+				  uint32_t ring, bool enable);
+extern void cvm_oct_configure_rgmii_speed(struct eth_device *dev);
+static int nic225e_mod_tuning_required(struct eth_device *dev);
+static int nic225e_check_link_status(struct eth_device *dev);
+static int nic225e_mod_abs_changed(struct eth_device *dev, bool present, void *data);
+static bool get_enable_fec(int port);
 
 /**
  * Enables and disables forward error correction
@@ -85,14 +122,15 @@ extern int ssd_smbus_get_temps(int *warn
  */
 void board_configure_qlms(void)
 {
-	int tx_swing;
-	int tx_gain;
+	int tx_swing = 0x19;
+	int tx_gain = 0;
 	int preemp_tap = 0;
 	int clk_source = gd->arch.board_desc.rev_major >= 3 ? 1 : 0;
 	int eth0_speed, eth1_speed;
 	int eth0_baud, eth1_baud;
 	int eth0_mode, eth1_mode;
 	char *str;
+	int ctle_zero, agc_pre_ctle, agc_post_ctle;
 
 	eth0_speed = getenv_ulong("octeth0_speed", 10, 25);
 	if (eth0_speed != 10 && eth0_speed != 25) {
@@ -119,11 +157,35 @@ void board_configure_qlms(void)
 	      eth0_speed == 25 ? "XLAUI" : "XFI", eth0_baud);
 	octeon_configure_qlm(2, eth0_baud, eth0_mode, 0, 0, 3, clk_source);
 
+	/* Disable the DFE and use fixed AGC & CTLE zero settings for QLM2 -
+	 * This is a really low-loss channel */
+	if (eth0_baud == 6316) {
+		ctle_zero = 0;
+		agc_pre_ctle = 8;
+		agc_post_ctle = 10;
+	} else {
+		ctle_zero = 0;
+		agc_pre_ctle = 8;
+		agc_post_ctle = 10;
+	}
+	octeon_qlm_dfe_disable_ctle_agc(0, 2, -1, eth0_baud, eth0_mode, ctle_zero, agc_pre_ctle, agc_post_ctle);
 	if (gd->arch.board_desc.board_type == CVMX_BOARD_TYPE_NIC225E) {
 		debug("%s: configuring QLM %d for %s at %d baud.\n", __func__, 3,
 		      eth1_speed == 25 ? "XLAUI" : "XFI", eth1_baud);
 		octeon_configure_qlm(3, eth1_baud, eth1_mode, 0, 0, 3,
 				     clk_source);
+		/* Disable the DFE and use fixed AGC & CTLE zero settings for QLM3 -
+		 * This is a really low-loss channel */
+		if (eth1_baud == 6316) {
+			ctle_zero = 0;
+			agc_pre_ctle = 8;
+			agc_post_ctle = 10;
+		} else {
+			ctle_zero = 0;
+			agc_pre_ctle = 8;
+			agc_post_ctle = 10;
+		}
+		octeon_qlm_dfe_disable_ctle_agc(0, 3, -1, eth1_baud, eth1_mode, ctle_zero, agc_pre_ctle, agc_post_ctle);
 	}
 
 	if (gd->arch.board_desc.rev_major >= 3) {
@@ -151,11 +213,134 @@ void board_configure_qlms(void)
  */
 void octeon_board_poll(void)
 {
+	int ifidx, temp;
+	volatile int  present;
+	struct eth_device *dev;
+	bool enable_avago_hw_self_heal = getenv_yesno("enable_avago_hw_self_heal") > 0;
+
 	cvmx_update_rx_activity_led(0, 0, true);
+
 	if (gd->arch.board_desc.board_type == CVMX_BOARD_TYPE_NIC225E)
-	cvmx_update_rx_activity_led(1, 0, true);
+		cvmx_update_rx_activity_led(1, 0, true);
 
 	octeon_board_restore_pf();
+
+	if (enable_avago_hw_self_heal)
+		return;
+	
+	for (ifidx = 0; ifidx < 2; ifidx++) {
+
+		if (monitor_ethx_ports[ifidx] &&
+		   ((dev = octeon_find_eth_by_interface_index(ifidx, 0)) != NULL)) {
+
+			present = octeon_sfp_check_mod_abs(dev, NULL);
+
+			nic225e_mod_abs_changed(dev, present, NULL);
+
+			if (!module_is_present[ifidx] || !sfp_info_valid[ifidx])
+				continue;
+	
+			nic225e_check_link_status(dev);
+
+			temp = last_tune_temp[ifidx];
+			if ((get_ticks() - last_temp_check[ifidx]) > (300 * get_tbclk())) {
+				if (!uboot_garnet_temparature_check(0, ((ifidx == 0) ? 0x4e : 0x47), 0, 0, &temp))
+					last_tune_temp[ifidx] = temp;
+				last_temp_check[ifidx] = get_ticks();
+			}
+		}
+	}
+}
+
+int octeon_phy_sw_self_healing(uint64_t interface, uint64_t mode, uint64_t flags, uint64_t prev_temp)
+{
+	uint64_t temp_addr;
+	bool enable_fec;
+	ulong tx_atten;
+	int i2c_addr, is_10g, is_active, temp, ret = 0;
+
+	temp_addr = MAKE_XKPHYS(prev_temp);
+	if (!temp_addr)
+		return -1;
+	
+	if (interface == 0) {
+		i2c_addr = 0x4e;
+		enable_fec = get_enable_fec(0);
+		tx_atten = 30;
+	} else {
+		i2c_addr = 0x47;
+		enable_fec = get_enable_fec(1);
+		tx_atten = 30;
+	}
+
+	is_10g = (mode == CVMX_HELPER_INTERFACE_MODE_XFI);
+
+	if (flags & CVMX_SW_SELFHEAL_INIT) {
+		if (!uboot_garnet_supervisor_disable(0, i2c_addr, 0, 0, enable_fec, tx_atten, is_10g)) {
+			return -1;
+		}
+	}
+
+	if (flags & CVMX_SW_SELFHEAL_REINIT) {
+		if (!uboot_garnet_reinit(0, i2c_addr, 0, 0, enable_fec, tx_atten, is_10g, TRUE)) {
+			return -1;
+		}
+	}
+
+	if (flags & (CVMX_SW_SELFHEAL_INIT | CVMX_SW_SELFHEAL_HOST_TUNE)) {
+		if (!uboot_garnet_host_tuning(0, i2c_addr, 0, 0, enable_fec, tx_atten, is_10g)) {
+			return -1;
+		}
+	}
+
+	if (flags & CVMX_SW_SELFHEAL_MOD_ABSENT) {
+		uboot_garnet_tx_enable(0, i2c_addr, 0, 0, false);
+		return 0;
+	} else {
+		uboot_garnet_tx_enable(0, i2c_addr, 0, 0, true);
+	}
+
+	if (flags & CVMX_SW_SELFHEAL_MOD_TUNE) {
+		is_active = !!(flags & CVMX_SW_SELFHEAL_ACTIVE_CABLE);
+		if (!(ret = uboot_garnet_mod_config(0, i2c_addr, 0, 0, is_active, is_10g))) {
+			ret = uboot_garnet_mod_tuning(0, i2c_addr, 0, 0, enable_fec, tx_atten, is_10g);
+			if (ret) {
+				return -1;
+			}
+		}
+	}
+
+        temp = cvmx_read64_int64(temp_addr);
+
+	if ((temp == 0) || (flags & CVMX_SW_SELFHEAL_TEMP_CHECK)) {
+		temp = uboot_garnet_temparature_get(0, i2c_addr, 0, 0);
+		if (temp > -40)
+			cvmx_write64_int64(temp_addr, temp);
+	} else {
+		if (flags & CVMX_SW_SELFHEAL_TEMP_CHECK) {
+			if (!(ret = uboot_garnet_temparature_check(0, i2c_addr, 0, 0, &temp)))
+				cvmx_write64_int64(temp_addr, temp);
+		}
+	}
+
+	if (flags & CVMX_SW_SELFHEAL_INIT_OK) {
+		return uboot_garnet_init_ok(0, i2c_addr, 0, 0, enable_fec, is_10g);
+	}
+
+	if (flags & CVMX_SW_SELFHEAL_EI_DEBOUNCE) {
+		return uboot_garnet_ei_debounce(0, i2c_addr, 0, 0);
+	}
+
+	if (flags & CVMX_SW_SELFHEAL_FORCE_HEAL_MOD) {
+		return uboot_garnet_force_heal_mod(0, i2c_addr, 0, 0, enable_fec, is_10g);
+	}
+
+	if (flags & CVMX_SW_SELFHEAL_MOD_CONFIG) {
+		is_active = !!(flags & CVMX_SW_SELFHEAL_ACTIVE_CABLE);
+		return uboot_garnet_mod_config(0, i2c_addr, 0, 0, is_active, is_10g);
+	}
+
+	return 0;
 }
 
 /**
@@ -163,9 +348,17 @@ void octeon_board_poll(void)
  */
 void board_net_preinit(void)
 {
-	/* Turn on SFP+ transmitters */
-	gpio_set_value(16, 0);
-	gpio_set_value(21, 0);
+	bool enable_avago_hw_self_heal = getenv_yesno("enable_avago_hw_self_heal") > 0;
+
+        if (enable_avago_hw_self_heal) {        
+		/* Turn on SFP+ transmitters */
+		gpio_set_value(16, 0);
+		gpio_set_value(21, 0);
+	} else {
+		/* Turn OFF SFP+ transmitters */
+		gpio_set_value(16, 1);
+		gpio_set_value(21, 1);
+        }		
 
 	/* Take the Avago AVSP-5410-0P1 out of reset */
 	gpio_set_value(7, 1);
@@ -256,25 +449,318 @@ void bgx_set_test_pattern(int interface,
 
 static bool get_enable_fec(int port)
 {
-	char env_name[16];
-	const char *value;
+       char env_name[16];
+       const char *value;
 
-	snprintf(env_name, sizeof(env_name), "enable_fec%d", port);
-	value = getenv(env_name);
+       snprintf(env_name, sizeof(env_name), "enable_fec%d", port);
+       value = getenv(env_name);
 
-	if (!value)
-		return false;
+       if (!value)
+               return false;
 
-	switch (*value) {
-	case 'y':
-	case 'Y':
-	case '1':
-	case 't':
-	case 'T':
-		return true;
-	default:
-		return false;
+       switch (*value) {
+       case 'y':
+       case 'Y':
+       case '1':
+       case 't':
+       case 'T':
+               return true;
+       default:
+               return false;
+       }
+}
+
+static int nic225e_mod_tuning_required(struct eth_device *dev)
+{
+	struct octeon_eth_info *oct_eth_info = (struct octeon_eth_info *)dev->priv;
+	int xiface = cvmx_helper_get_interface_num(oct_eth_info->port);
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(oct_eth_info->port);
+	int index = cvmx_helper_get_interface_index_num(xp.port);
+	cvmx_bgxx_spux_status1_t spu_status1;
+	cvmx_bgxx_smux_tx_ctl_t smu_tx_ctl;
+	cvmx_bgxx_smux_rx_ctl_t smu_rx_ctl;
+	cvmx_helper_link_info_t link_state;
+
+	link_state = cvmx_helper_link_get(oct_eth_info->port);
+	if (link_state.s.link_up)
+		return 0;
+
+	if (!link_state.s.init_success)
+		return 1;
+
+	spu_status1.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SPUX_STATUS1(index, xi.interface));
+	smu_tx_ctl.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SMUX_TX_CTL(index, xi.interface));
+	smu_rx_ctl.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SMUX_RX_CTL(index, xi.interface));
+
+	if ((spu_status1.s.rcv_lnk == 0) ||
+	    (smu_rx_ctl.s.status == 1) ||
+	    (smu_tx_ctl.s.ls == 1))
+		return 1;
+
+	return 0;
+}
+
+static int nic225e_check_link_status(struct eth_device *dev)
+{
+	int i, ifidx, cur_ifidx, i2c_addr, rx_los = 0, tx_fault = 0;
+	struct eth_device *cur_dev = eth_get_dev();
+	struct octeon_eth_info *oct_eth_info = (struct octeon_eth_info *)dev->priv;
+	struct octeon_eth_info *cur_oct_eth_info = (struct octeon_eth_info *)cur_dev->priv;
+	cvmx_helper_interface_mode_t mode;
+	bool is_10g, is_active;
+	bool enable_fec;
+	ulong tx_atten;
+	struct octeon_sfp_info *sfp = &oct_eth_info->sfp;
+	uint64_t octeon_debounce;
+
+	if (oct_eth_info->interface == 0) {
+		ifidx = 0;
+		i2c_addr = 0x4e;
+		enable_fec = get_enable_fec(0);
+		tx_atten = 30;
+	} else {
+		ifidx = 1;
+		i2c_addr = 0x47;
+		enable_fec = get_enable_fec(1);
+		tx_atten = 30;
+	}
+
+	mode = cvmx_helper_interface_get_mode(ifidx);
+
+	is_10g = (mode == CVMX_HELPER_INTERFACE_MODE_XFI);
+
+	is_active = sfp_info[ifidx].active_cable;
+
+	if (sfp_info[ifidx].los_implemented) {
+		rx_los = gpio_get_value(sfp->rx_los.pin);
+		if (sfp->rx_los.inverted)
+			rx_los = !rx_los;
+
+		if (rx_los) {
+			if (!rx_los_present[ifidx]) {
+				printf("%s: Signal Not present\n", __func__);
+				rx_los_present[ifidx] = true;
+ 				monitor_ethx_ports[ifidx] = true;
+				return -1;
+			}
+		} else {
+			if (rx_los_present[ifidx]) {
+				mdelay(100);
+				rx_los = gpio_get_value(sfp->rx_los.pin);
+				if (sfp->rx_los.inverted)
+					rx_los = !rx_los;
+				if (rx_los) {
+					printf("%s: Signal Not present\n", __func__);
+					rx_los_present[ifidx] = true;
+ 					monitor_ethx_ports[ifidx] = true;
+					return -1;
+				}
+				rx_los_present[ifidx] = false;
+			}
+		}
+	}
+
+	if (sfp_info[ifidx].tx_fault_implemented) {
+		tx_fault = gpio_get_value(sfp->tx_error.pin);
+		if (sfp->tx_error.inverted)
+			tx_fault = !tx_fault;
+
+		if (tx_fault) {
+			if (!tx_fault_present[ifidx]) {
+				printf("%s: tx fault present\n", __func__);
+				debug("%s: Disabling SFP Transmitter.\n",  __func__);
+				if (sfp->tx_disable.inverted) {
+					gpio_set_value(sfp->tx_disable.pin, 0);
+				} else {
+					gpio_set_value(sfp->tx_disable.pin, 1);
+				}
+				uboot_garnet_tx_enable(0, i2c_addr, 0, 0, false);
+				module_status_changed[ifidx] = true;
+				return -1;
+			}
+		} else {
+			if (tx_fault_present[ifidx]) {
+				tx_fault = gpio_get_value(sfp->tx_error.pin);
+				if (sfp->tx_error.inverted)
+					tx_fault = !tx_fault;
+				if (tx_fault) {
+					printf("%s: tx fault present\n", __func__);
+					tx_fault_present[ifidx] = true;
+					return -1;
+				}
+				tx_fault_present[ifidx] = false;
+			}
+		}
+	}
+
+	cur_ifidx = (cur_oct_eth_info->interface == 0) ? 0 : 1;
+
+	if (ifidx != cur_ifidx)
+		return 0;
+
+	if (module_status_changed[ifidx]) {
+		uboot_garnet_tx_enable(0, i2c_addr, 0, 0, true);
+
+		debug("%s: Enabling SFP Transmitter.\n",  __func__);
+
+		if (sfp->tx_disable.inverted) {
+			gpio_set_value(sfp->tx_disable.pin, 1);
+		} else {
+			gpio_set_value(sfp->tx_disable.pin, 0);
+		}
+
+		for (i = 0; i < 5; i++) {
+			if (!uboot_garnet_mod_config(0, i2c_addr, 0, 0, is_active, is_10g))
+				break;
+		}
+
+		if (i == 5) {
+			return -1;
+		}
+	} else {
+		if (!nic225e_mod_tuning_required(dev))
+			return 0;
+	}
+
+	for (i = 0; i < 5; i++) {
+
+		if (uboot_garnet_mod_tuning(0, i2c_addr, 0, 0, enable_fec, tx_atten, is_10g)) {
+			debug("%s: Disabling SFP Transmitter.\n",  __func__);
+
+			if (sfp->tx_disable.inverted) {
+				gpio_set_value(sfp->tx_disable.pin, 0);
+			} else {
+				gpio_set_value(sfp->tx_disable.pin, 1);
+			}
+
+			module_status_changed[ifidx] = true;
+			return -1;
+		}
+		/* 150ms debounce for confirming Octeon link up */
+		octeon_debounce = cvmx_clock_get_count(CVMX_CLOCK_CORE) + 150000 *
+			cvmx_clock_get_rate(CVMX_CLOCK_CORE) / 1000000;
+		
+		while (cvmx_clock_get_count(CVMX_CLOCK_CORE) < octeon_debounce) {
+			if (!nic225e_mod_tuning_required(dev)) {
+				int temp = uboot_garnet_temparature_get(0, i2c_addr, 0, 0);
+				if (temp > -40) {
+					last_tune_temp[ifidx] = temp;
+					last_temp_check[ifidx] = get_ticks();
+				}
+				module_status_changed[ifidx] = false;
+				debug("%s: Successful octeon link check. Retries: %d\n",  __func__, i);
+
+				return 0;
+			}
+
+			cvmx_wait_usec(1000);
+		}
+	}
+
+	debug("%s: Failed octeon link check.\n",  __func__);
+	debug("%s: Disabling SFP Transmitter.\n",  __func__);
+	if (sfp->tx_disable.inverted) {
+		gpio_set_value(sfp->tx_disable.pin, 0);
+	} else {
+		gpio_set_value(sfp->tx_disable.pin, 1);
+	}
+
+	uboot_garnet_reinit(0, i2c_addr, 0, 0, enable_fec, tx_atten, is_10g, true);
+	module_status_changed[ifidx] = true;
+
+ 	return -1;
+}
+
+static int nic225e_mod_abs_changed(struct eth_device *dev, bool mod_abs, void *data)
+{
+	int ifidx, i2c_addr;
+	cvmx_helper_interface_mode_t mode;
+	bool is_10g, is_active;
+	uint8_t buffer[SFP_MAX_EEPROM_SIZE];
+	struct octeon_eth_info *oct_eth_info = (struct octeon_eth_info *)dev->priv;
+	struct octeon_sfp_info *sfp = &oct_eth_info->sfp;
+
+	if (oct_eth_info->interface == 0) {
+		ifidx = 0;
+		i2c_addr = 0x4e;
+	} else {
+		ifidx = 1;
+		i2c_addr = 0x47;
+	}
+
+	if (mod_abs) {
+		if (module_is_present[ifidx]) {
+			if (sfp->valid) {
+				if (sfp->tx_disable.inverted) {
+					gpio_set_value(sfp->tx_disable.pin, 0);
+				} else {
+					gpio_set_value(sfp->tx_disable.pin, 1);
+				}
+			}
+			uboot_garnet_tx_enable(0, i2c_addr, 0, 0, false);
+			module_is_present[ifidx] = false;
+			module_status_changed[ifidx] = true;
+		}
+		return 0;
+	}
+
+	if (module_is_present[ifidx])
+		return 0;
+
+	mdelay(100);
+
+	if (octeon_sfp_check_mod_abs(dev, NULL)) {
+		return 0;
 	}
+
+	module_is_present[ifidx] = true;
+
+	module_status_changed[ifidx] = true;
+
+	sfp_info_valid[ifidx] = false;
+
+	if (sfp->valid) {
+		if (phy_sfp_read_i2c_eeprom(buffer, sfp->i2c_bus, sfp->i2c_eeprom_addr)) {
+			printf("%s: Failed to read SFP Module EEPROM\n", __func__);
+ 			monitor_ethx_ports[ifidx] = true;
+			return 0;
+		}
+
+		if (phy_sfp_parse_eeprom(&sfp_info[ifidx], buffer)) {
+			printf("%s: SFP Module EEPROM is invalid\n", __func__);
+ 			monitor_ethx_ports[ifidx] = true;
+			return 0;
+		}
+
+		is_active = sfp_info[ifidx].active_cable;
+
+		mode = cvmx_helper_interface_get_mode(ifidx);
+
+		is_10g = (mode == CVMX_HELPER_INTERFACE_MODE_XFI);
+
+		if (is_10g) {
+			if ((sfp_info[ifidx].rate != SFP_RATE_10G) && is_active) {
+				printf("%s: Module inserted in SFP slot is not 10G compliant\n", __func__);
+ 				monitor_ethx_ports[ifidx] = true;
+				return 0;
+			}
+		} else {
+			if (sfp_info[ifidx].rate != SFP_RATE_25G) {
+				printf("%s: Module inserted in SFP slot is not 25G compliant\n", __func__);
+ 				monitor_ethx_ports[ifidx] = true;
+				return 0;
+			}
+		}
+
+		sfp_info_valid[ifidx] = true;
+
+	} else {
+		printf("%s: SFP Info is not valid\n", __func__);
+	}
+
+ 	monitor_ethx_ports[ifidx] = true;
+	return 0;
 }
 
 /**
@@ -286,47 +772,79 @@ void board_net_postinit(void)
 	bool enable_fec0 = get_enable_fec(0);
 	bool enable_fec1 = get_enable_fec(1);
 	struct avago_serdes_tx_eq line_tx_eq;
-	ulong tx_atten0 = getenv_ulong("avago_line_tx_atten0", 0, 0x18);
-	ulong tx_atten1 = getenv_ulong("avago_line_tx_atten1", 0, 0x18);
+	ulong tx_atten0 = 30;
+	ulong tx_atten1 = 30;
 	cvmx_helper_interface_mode_t mode;
 	bool is_10g;
+	struct eth_device *dev;
+	struct octeon_eth_info *oct_eth_info;
+	bool enable_avago_hw_self_heal = getenv_yesno("enable_avago_hw_self_heal") > 0;
+	struct octeon_sfp_info *sfp;
+
+	line_tx_eq.pre = 0;
+	line_tx_eq.atten = 0;
+	line_tx_eq.post = 0;
+	line_tx_eq.slew = 0;
+	line_tx_eq.pre2 = 0;
+	line_tx_eq.pre3 = 0;
+	line_tx_eq.vert = 0;
 
-	line_tx_eq.pre = getenv_ulong("avago_pre0", 0, 0);
-	line_tx_eq.atten = getenv_ulong("avago_atten0", 0, 0);
-	line_tx_eq.post = getenv_ulong("avago_post0", 0, 0);
-	line_tx_eq.slew = getenv_ulong("avago_slew0", 0, 0);
-	line_tx_eq.pre2 = getenv_ulong("avago_pre20", 0, 0);
-	line_tx_eq.pre3 = getenv_ulong("avago_pre30", 0, 0);
-	line_tx_eq.vert = getenv_ulong("avago_vert0", 0, 0);
+	eth_init(gd->bd);
 
-	/* Set attenuation to 24 */
+	debug("Initializing Avago port 0\n");
+	/* Set attenuation to 30 */
 	mode = cvmx_helper_interface_get_mode(0);
 	is_10g = (mode == CVMX_HELPER_INTERFACE_MODE_XFI);
 	if (is_10g)
 		enable_fec0 = false;
 	debug("Initializing Avago port 0, FEC: %sabled, speed: %dGbps\n",
 	      enable_fec0 ? "en" : "dis", is_10g ? 10 : 25);
-	uboot_garnet_init(0, 0x4e, 0, 0, enable_fec0, tx_atten0, &line_tx_eq,
-			  is_10g);
+
+	if(!uboot_garnet_init(0, 0x4e, 0, 0, enable_fec0, tx_atten0, &line_tx_eq, is_10g)) {
+
+		if (!enable_avago_hw_self_heal) {
+			if ((dev = octeon_find_eth_by_interface_index(0, 0)) != NULL) {
+				oct_eth_info = (struct octeon_eth_info *)dev->priv;
+				sfp = &oct_eth_info->sfp;
+				if (sfp->valid) {
+					if (sfp->tx_disable.inverted) {
+						gpio_set_value(sfp->tx_disable.pin, 0);
+					} else {
+						gpio_set_value(sfp->tx_disable.pin, 1);
+					}
+					octeon_sfp_register_mod_abs_changed(dev, nic225e_mod_abs_changed, NULL);
+				}
+			}
+		}
+	}
 
 	if (gd->arch.board_desc.board_type == CVMX_BOARD_TYPE_NIC225E) {
-		line_tx_eq.pre = getenv_ulong("avago_pre1", 0, 0);
-		line_tx_eq.atten = getenv_ulong("avago_atten1", 0, 0);
-		line_tx_eq.post = getenv_ulong("avago_post1", 0, 0);
-		line_tx_eq.slew = getenv_ulong("avago_slew1", 0, 0);
-		line_tx_eq.pre2 = getenv_ulong("avago_pre21", 0, 0);
-		line_tx_eq.pre3 = getenv_ulong("avago_pre31", 0, 0);
-		line_tx_eq.vert = getenv_ulong("avago_vert1", 0, 0);
 		mode = cvmx_helper_interface_get_mode(1);
+		debug("Initializing Avago port 1\n");
 		is_10g = (mode == CVMX_HELPER_INTERFACE_MODE_XFI);
 		if (is_10g)
 			enable_fec1 = false;
 		debug("Initializing Avago port 1, FEC: %sabled, speed: %dGbps\n",
 		      enable_fec1 ? "en" : "dis", is_10g ? 10 : 25);
-		/* Set attenuation to 24 */
-		uboot_garnet_init(0, 0x47, 0, 0, enable_fec1, tx_atten1,
-				  &line_tx_eq, is_10g);
+		/* Set attenuation to 30 */
+		if (!uboot_garnet_init(0, 0x47, 0, 0, enable_fec1, tx_atten1, &line_tx_eq, is_10g)) {
+			if (!enable_avago_hw_self_heal) {
+				if ((dev = octeon_find_eth_by_interface_index(1, 0)) != NULL) {
+					oct_eth_info = (struct octeon_eth_info *)dev->priv;
+					sfp = &oct_eth_info->sfp;
+					if (sfp->valid) {
+						if (sfp->tx_disable.inverted) {
+							gpio_set_value(sfp->tx_disable.pin, 0);
+						} else {
+							gpio_set_value(sfp->tx_disable.pin, 1);
+						}
+						octeon_sfp_register_mod_abs_changed(dev, nic225e_mod_abs_changed, NULL);
+					}
+				}
+			}
+		}
 	}
+
 	avago_initialized = true;
 }
 
@@ -447,6 +965,20 @@ static void program_temp(void)
 }
 
 /**
+ * Configures the GPIO glitch filter 
+ */
+void __cvmx_gpio_glitch_filter(uint8_t node, int bit, int fil_sel, int fil_cnt)
+{
+        cvmx_gpio_bit_cfgx_t gpio_bit;
+        gpio_bit.u64 = cvmx_read_csr_node(node,
+                                          CVMX_GPIO_BIT_CFGX(bit));
+        gpio_bit.s.fil_sel = fil_sel;
+        gpio_bit.s.fil_cnt = fil_cnt;
+        cvmx_write_csr_node(node, CVMX_GPIO_BIT_CFGX(bit),
+                            gpio_bit.u64);
+}
+
+/**
  * Early initialization callback reads the TLV EEPROM and configures GPIOs
  */
 int early_board_init(void)
@@ -488,6 +1020,27 @@ int early_board_init(void)
 
 	program_temp();
 
+        /* Configure glitch filters on the SFP GPIO inputs */
+        /* to reduce noise susceptability */
+
+        /* SFP0 MOD-ABS */
+        __cvmx_gpio_glitch_filter(0, 17, 15, 15);
+
+        /* SFP0 RX LOS */
+        __cvmx_gpio_glitch_filter(0, 18, 15, 15);
+
+        /* SFP0 TX-fault */
+        __cvmx_gpio_glitch_filter(0, 19, 15, 15);
+        
+        /* SFP1 MOD-ABS	*/
+        __cvmx_gpio_glitch_filter(0, 22, 15, 15);
+
+        /* SFP1 RX LOS */
+        __cvmx_gpio_glitch_filter(0, 23, 15, 15);
+
+        /* SFP1 TX-fault */
+        __cvmx_gpio_glitch_filter(0, 24, 15, 15);
+
 	return 0;
 }
 
@@ -627,8 +1180,9 @@ int on_enablefec(const char *name, const
 	int device;
 	int i2c_bus = 0;
 	int i2c_addr;
-	cvmx_helper_interface_mode_t mode;
 	bool is_10g = false;
+	cvmx_helper_interface_mode_t mode;
+
 	if (!avago_initialized)
 		return 0;
 
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/drivers/i2c/octeon_i2c.c OCTEON-SDK/bootloader/u-boot/drivers/i2c/octeon_i2c.c
--- OCTEON_SDK_CLEAN/bootloader/u-boot/drivers/i2c/octeon_i2c.c	2018-05-15 11:35:39.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/drivers/i2c/octeon_i2c.c	2018-06-28 15:08:31.080008792 -0700
@@ -134,6 +134,14 @@ static uint octeon_i2c_set_bus_speed(str
 				     unsigned int speed);
 
 /**
+ * send STOP to the bus.
+ * @param bus - bus number to send stop on
+ *
+ * @return 0 on success, -1 on failure
+ */
+static int octeon_i2c_bus_stop(int bus);
+
+/**
  * Gets the i2c bus number without the node number.
  *
  * @param bus_num	Bus number with optional node number encoded in bit 1.
@@ -301,6 +309,9 @@ static cvmx_mio_tws_sw_twsi_t octeon_i2c
 static void octeon_i2c_write_int(int i2c_bus, cvmx_mio_tws_int_t int_reg)
 {
 	int node = i2c_bus_to_node(i2c_bus);
+	ulong start;
+	union cvmx_mio_twsx_int sw_int;
+
 	if (!is_i2c_bus_valid(i2c_bus))
 		return;
 	i2c_bus = octeon_i2c_extract_bus_num(i2c_bus);
@@ -577,40 +588,64 @@ void octeon_i2c_hlc_enable(int bus, int
  */
 static int octeon_i2c_start(int bus)
 {
-	int result;
 	uint8_t stat;
+	static int8_t reset_method;     /* NOTE: can only be used after reloc */
+	int8_t loc_reset_method = 0;    /* local reset method */
 
 	if (!is_i2c_bus_valid(bus))
 		return -1;
+
 	debug("%s: Starting bus %d\n", __func__, bus);
-	octeon_i2c_write_ctl(bus, TWSI_CTL_ENAB | TWSI_CTL_STA);
 
-	result = octeon_i2c_wait(bus);
-	if (result) {
+	do {
+		octeon_i2c_write_ctl(bus, TWSI_CTL_ENAB | TWSI_CTL_STA);
+
+		octeon_i2c_wait(bus);
+
 		stat = octeon_i2c_read_status(bus);
-		if (stat == STAT_IDLE) {
-			/*
-			 * Controller refused to send start flag May
-			 * be a client is holding SDA low - let's try
-			 * to free it.
-			 */
-			debug("%s: Unblocking bus %d\n", __func__, bus);
-			octeon_i2c_unblock(bus);
 
-			octeon_i2c_write_ctl(bus, TWSI_CTL_ENAB | TWSI_CTL_STA);
-			result = octeon_i2c_wait(bus);
-		}
-		if (result) {
-			debug("%s: timeout waiting for IDLE state\n", __func__);
-			return result;
+		switch (stat) {
+			case STAT_START:
+			case STAT_RSTART:
+				if (gd->flags & GD_FLG_RELOC)
+					reset_method = 0;
+				return 0;
+
+			default:
+				octeon_i2c_bus_stop(bus);
+
+				/* We can't touch static variables until after reloc */
+				if (gd->flags & GD_FLG_RELOC)
+					loc_reset_method = reset_method;
+
+				switch (loc_reset_method++ % 4) {
+					case 0:
+						break;
+					case 1:
+						/*
+			 			 * Controller refused to send start flag May
+			 			 * be a client is holding SDA low - let's try
+			 			 * to free it.
+			 			 */
+						debug("%s: Unblocking bus %d\n", __func__, bus);
+						octeon_i2c_unblock(bus);
+						break;
+					case 2:
+						octeon_i2c_reset(bus);
+						break;
+					default :
+						if (gd->flags & GD_FLG_RELOC)
+							reset_method = 0;
+						return -1;
+				}
+
+				if (gd->flags & GD_FLG_RELOC)
+					reset_method = loc_reset_method;
+				break;
 		}
-	}
 
-	stat = octeon_i2c_read_status(bus);
-	if ((stat != STAT_START) && (stat != STAT_RSTART)) {
-		debug("%s: Bad status on bus %d (0x%x)\n", __func__, bus, stat);
-		return -1;
-	}
+	} while (true);
+
 	return 0;
 }
 
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/drivers/net/octeon_eth.c OCTEON-SDK/bootloader/u-boot/drivers/net/octeon_eth.c
--- OCTEON_SDK_CLEAN/bootloader/u-boot/drivers/net/octeon_eth.c	2018-05-15 11:35:39.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/drivers/net/octeon_eth.c	2018-06-28 15:08:31.081008794 -0700
@@ -568,15 +568,20 @@ void __octeon_phy_port_check(struct eth_
  *
  * @param dev    Linux device for the RGMII port
  */
-static void cvm_oct_configure_rgmii_speed(struct eth_device *dev)
+void cvm_oct_configure_rgmii_speed(struct eth_device *dev)
+	__attribute__((weak, alias("__cvm_oct_configure_rgmii_speed")));
+
+void __cvm_oct_configure_rgmii_speed(struct eth_device *dev)
 {
 	struct octeon_eth_info *priv = (struct octeon_eth_info *)(dev->priv);
 	int port = priv->port;
 	cvmx_helper_link_info_t link_state = cvmx_helper_link_get(port);
 
 	/* If the port is down some PHYs we need to check modules, etc. */
-	if (!link_state.s.link_up)
+	if (!link_state.s.link_up) {
 		octeon_phy_port_check(dev);
+		link_state = cvmx_helper_link_get(port);
+	}
 
 	if (link_state.u64 != priv->link_state) {
 		cvmx_helper_interface_mode_t mode;
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/drivers/net/phy/sfp.c OCTEON-SDK/bootloader/u-boot/drivers/net/phy/sfp.c
--- OCTEON_SDK_CLEAN/bootloader/u-boot/drivers/net/phy/sfp.c	2018-05-15 11:35:39.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/drivers/net/phy/sfp.c	2018-06-28 15:08:31.082008795 -0700
@@ -94,28 +94,85 @@ static int phy_sfp_parse_sfp(struct phy_
 	sfp_info->eth_comp = buffer[3] & 0xf0;
 	sfp_info->cable_comp = buffer[0x24];
 
+	/* There are several ways a cable can be marked as active or
+	 * passive.  8.[2-3] specify the SFP+ cable technology.  Some
+	 * modules also use 3.[0-1] for Infiniband, though it's
+	 * redundant.
+	 */
+	if ((buffer[8] & 0x0C) == 0x08) {
+		sfp_info->limiting = true;
+		sfp_info->active_cable = true;
+	} else if ((buffer[8] & 0xC) == 0x4) {
+		sfp_info->limiting = false;
+		sfp_info->active_cable = false;
+	}
+	if ((buffer[3] & 3) == 2) {
+		sfp_info->active_cable = true;
+		sfp_info->limiting = true;
+	}
+
 	switch (sfp_info->mod_type) {
+        case SFP_MOD_OPTICAL_LC:
+        case SFP_MOD_OPTICAL_PIGTAIL:
+		sfp_info->copper_cable = false;
+		break;
 	case SFP_MOD_COPPER_PIGTAIL:
-	case SFP_MOD_NO_SEP_CONN:
-		debug("%s: copper pigtail or no separable cable\n", __func__);
-		/* There are several ways a cable can be marked as active or
-		 * passive.  8.[2-3] specify the SFP+ cable technology.  Some
-		 * modules also use 3.[0-1] for Infiniband, though it's
-		 * redundant.
-		 */
 		sfp_info->copper_cable = true;
-		if ((buffer[8] & 0x0C) == 0x08) {
-			sfp_info->limiting = true;
-			sfp_info->active_cable = true;
-		} else if ((buffer[8] & 0xC) == 0x4) {
-			sfp_info->limiting = false;
-			sfp_info->active_cable = false;
-		}
-		if ((buffer[3] & 3) == 2) {
-			sfp_info->active_cable = true;
-			sfp_info->limiting = true;
+		break;
+	case SFP_MOD_NO_SEP_CONN:
+		switch (sfp_info->cable_comp) {
+        		case SFP_CABLE_100G_25GAUI_C2M_AOC_HIGH_BER:
+        		case SFP_CABLE_100G_25GAUI_C2M_AOC_LOW_BER:
+        		case SFP_CABLE_100G_25GAUI_C2M_ACC_LOW_BER:
+				sfp_info->copper_cable = false;
+				sfp_info->limiting = true;
+				sfp_info->active_cable = true;
+				break;
+
+        		case SFP_CABLE_100G_SR4_25G_SR:
+        		case SFP_CABLE_100G_LR4_25G_LR:
+        		case SFP_CABLE_100G_ER4_25G_ER:
+        		case SFP_CABLE_100G_SR10:
+        		case SFP_CABLE_100G_CWDM4_MSA:
+        		case SFP_CABLE_100G_PSM4:
+        		case SFP_CABLE_100G_CWDM4:
+        		case SFP_CABLE_40G_ER4:
+        		case SFP_CABLE_4X10G_SR:
+        		case SFP_CABLE_G959_1_P1I1_2D1:
+        		case SFP_CABLE_G959_1_P1S1_2D2:
+        		case SFP_CABLE_G959_1_P1L1_2D2:
+        		case SFP_CABLE_100G_CLR4:
+        		case SFP_CABLE_100G_2_LAMBDA_DWDM:
+				sfp_info->copper_cable = false;
+				break;
+
+        		case SFP_CABLE_100G_25GAUI_C2M_ACC_HIGH_BER:
+				sfp_info->copper_cable = true;
+				sfp_info->limiting = true;
+				sfp_info->active_cable = true;
+				break;
+
+        		case SFP_CABLE_100G_CR4_25G_CR_CA_L:
+        		case SFP_CABLE_25G_CR_CA_S:
+        		case SFP_CABLE_25G_CR_CA_N:
+        		case SFP_CABLE_40G_PSM4:
+        		case SFP_CABLE_10GBASE_T:
+				sfp_info->copper_cable = true;
+				break;
+
+			default:
+				switch(sfp_info->eth_comp) {
+        				case SFP_CABLE_10GBASE_ER:
+        				case SFP_CABLE_10GBASE_LRM:
+        				case SFP_CABLE_10GBASE_LR:
+        				case SFP_CABLE_10GBASE_SR:
+						sfp_info->copper_cable = false;
+						break;
+				}
+				break;
 		}
 		break;
+
 	case SFP_MOD_RJ45:
 		debug("%s: RJ45 adapter\n", __func__);
 		sfp_info->copper_cable = true;
@@ -139,11 +196,13 @@ static int phy_sfp_parse_sfp(struct phy_
 			debug("Unknown module type 0x%x\n", sfp_info->mod_type);
 		}
 
-		/* fall through */
-		default:
-			sfp_info->limiting = true;
-			break;
+	/* fall through */
+	default:
+		sfp_info->limiting = true;
+		break;
 	}
+
+
 	if (sfp_info->copper_cable)
 		sfp_info->max_copper_cable_len = buffer[0x12];
 	else
@@ -158,13 +217,71 @@ static int phy_sfp_parse_sfp(struct phy_
 	sfp_info->max_62_5um_om1_cable_length = buffer[0x11] * 10;
 	sfp_info->max_50um_om3_cable_length = buffer[0x13] * 10;
 
-	if (buffer[0xc] == 12) {
-		sfp_info->rate = SFP_RATE_1G;
-	} else if (buffer[0xc] == 103) {
-		sfp_info->rate = SFP_RATE_10G;
-	} else if (buffer[0xc] == 0xff) {
-		if (buffer[0x42] == 103)
+	if (buffer[0xc] == 0xff) {
+		if (buffer[0x42] >= 400)
+			sfp_info->rate = SFP_RATE_100G;
+		else if (buffer[0x42] >= 160)
+			sfp_info->rate = SFP_RATE_40G;
+		else if (buffer[0x42] >= 100)
 			sfp_info->rate = SFP_RATE_25G;
+		else  {
+			sfp_info->rate = SFP_RATE_UNKNOWN;
+		}
+	} else if (buffer[0xc] >= 100) {
+		sfp_info->rate = SFP_RATE_10G;
+	} else if (buffer[0xc] >= 10) {
+		sfp_info->rate = SFP_RATE_1G;
+	} else {
+		sfp_info->rate = SFP_RATE_UNKNOWN;
+	}
+
+	if (sfp_info->rate == SFP_RATE_UNKNOWN) {
+		switch (sfp_info->cable_comp) {
+        		case SFP_CABLE_100G_SR10:
+        		case SFP_CABLE_100G_CWDM4_MSA:
+        		case SFP_CABLE_100G_PSM4:
+        		case SFP_CABLE_100G_CWDM4:
+        		case SFP_CABLE_100G_CLR4:
+        		case SFP_CABLE_100G_2_LAMBDA_DWDM:
+				sfp_info->rate = SFP_RATE_100G;
+				break;
+        		case SFP_CABLE_100G_25GAUI_C2M_AOC_HIGH_BER:
+        		case SFP_CABLE_100G_SR4_25G_SR:
+        		case SFP_CABLE_100G_LR4_25G_LR:
+        		case SFP_CABLE_100G_ER4_25G_ER:
+        		case SFP_CABLE_100G_25GAUI_C2M_ACC_HIGH_BER:
+        		case SFP_CABLE_100G_CR4_25G_CR_CA_L:
+        		case SFP_CABLE_25G_CR_CA_S:
+        		case SFP_CABLE_25G_CR_CA_N:
+        		case SFP_CABLE_100G_25GAUI_C2M_AOC_LOW_BER:
+        		case SFP_CABLE_100G_25GAUI_C2M_ACC_LOW_BER:
+				sfp_info->rate = SFP_RATE_25G;
+				break;
+        		case SFP_CABLE_40G_ER4:
+        		case SFP_CABLE_4X10G_SR:
+        		case SFP_CABLE_40G_PSM4:
+				sfp_info->rate = SFP_RATE_40G;
+				break;
+        		case SFP_CABLE_G959_1_P1I1_2D1:
+        		case SFP_CABLE_G959_1_P1S1_2D2:
+        		case SFP_CABLE_G959_1_P1L1_2D2:
+        		case SFP_CABLE_10GBASE_T:
+				sfp_info->rate = SFP_RATE_10G;
+				break;
+			default:
+				switch(sfp_info->eth_comp) {
+        				case SFP_CABLE_10GBASE_ER:
+        				case SFP_CABLE_10GBASE_LRM:
+        				case SFP_CABLE_10GBASE_LR:
+        				case SFP_CABLE_10GBASE_SR:
+						sfp_info->rate = SFP_RATE_10G;
+						break;
+					default:
+						sfp_info->rate = SFP_RATE_UNKNOWN;
+						break;
+				}
+				break;
+		}
 	}
 
 	if (buffer[0xc] < 0xff)
@@ -500,14 +617,101 @@ void phy_sfp_print_info(const struct phy
 	case SFP_CABLE_UNSPEC:
 		cable_comp = "";
 		break;
-	case SFP_CABLE_25G_CR_CA_S:
+        case SFP_CABLE_100G_25GAUI_C2M_AOC_HIGH_BER:
+		if (sfp_info->rate == SFP_RATE_25G)
+			cable_comp = " 25GAUI-C2M AOC HIGH BER";
+		else
+			cable_comp = " 100G AOC HIGH BER";
+		break;
+        case SFP_CABLE_100G_SR4_25G_SR:
+		if (sfp_info->rate == SFP_RATE_25G)
+			cable_comp = " 25GBASE-SR";
+		else
+			cable_comp = " 100GBASE-SR4";
+		break;
+        case SFP_CABLE_100G_LR4_25G_LR:
+		if (sfp_info->rate == SFP_RATE_25G)
+			cable_comp = " 25GBASE-LR";
+		else
+			cable_comp = " 100GBASE-LR4";
+		break;
+        case SFP_CABLE_100G_ER4_25G_ER:
+		if (sfp_info->rate == SFP_RATE_25G)
+			cable_comp = " 25GBASE-ER";
+		else
+			cable_comp = " 100GBASE-ER4";
+		break;
+        case SFP_CABLE_100G_SR10:
+		cable_comp = " 100GBASE-SR10";
+		break;
+        case SFP_CABLE_100G_CWDM4_MSA:
+		cable_comp = " 100G CWDM4";
+		break;
+        case SFP_CABLE_100G_PSM4:
+		cable_comp = " 100G PSM4 Parallel SMF";
+		break;
+        case SFP_CABLE_100G_25GAUI_C2M_ACC_HIGH_BER:
+		if (sfp_info->rate == SFP_RATE_25G)
+			cable_comp = " 25GAUI C2M ACC";
+		else
+			cable_comp = " 100G ACC";
+		break;
+        case SFP_CABLE_100G_CWDM4:
+		cable_comp = " 100G CWDM4 MSA";
+		break;
+        case SFP_CABLE_100G_CR4_25G_CR_CA_L:
+		if (sfp_info->rate == SFP_RATE_25G)
+			cable_comp = " 25GBASE-CR CA-L";
+		else
+			cable_comp = " 100GBASE-CR4";
+		break;
+        case SFP_CABLE_25G_CR_CA_S:
 		cable_comp = " 25GBase-CR CA-S";
 		break;
-	case SFP_CABLE_25G_CR_CA_N:
+        case SFP_CABLE_25G_CR_CA_N:
 		cable_comp = " 25GBase-CR CA-N";
 		break;
+        case SFP_CABLE_40G_ER4:
+		cable_comp = " 40GBASE-ER4";
+		break;
+        case SFP_CABLE_4X10G_SR:
+		cable_comp = " 4 X 10GBASE-SR";
+		break;
+        case SFP_CABLE_40G_PSM4:
+		cable_comp = " 40G PSM4 Parallel SMF";
+		break;
+        case SFP_CABLE_G959_1_P1I1_2D1:
+		cable_comp = " G959.1 profile P1I1-2D1";
+		break;
+        case SFP_CABLE_G959_1_P1S1_2D2:
+		cable_comp = " G959.1 profile P1S1-2D2";
+		break;
+        case SFP_CABLE_G959_1_P1L1_2D2:
+		cable_comp = " G959.1 profile P1L1-2D2";
+		break;
+        case SFP_CABLE_10GBASE_T:
+		cable_comp = " 40GBASE-ER4";
+		break;
+        case SFP_CABLE_100G_CLR4:
+		cable_comp = " 10G CLR4";
+		break;
+        case SFP_CABLE_100G_25GAUI_C2M_AOC_LOW_BER:
+		if (sfp_info->rate == SFP_RATE_25G)
+			cable_comp = " 25GAUI C2M AOC LOW BER";
+		else
+			cable_comp = " 100G AOC LOW BER";
+		break;
+        case SFP_CABLE_100G_25GAUI_C2M_ACC_LOW_BER:
+		if (sfp_info->rate == SFP_RATE_25G)
+			cable_comp = " 25GAUI C2M ACC LOW BER";
+		else
+			cable_comp = " 100G ACC LOW BER";
+		break;
+        case SFP_CABLE_100G_2_LAMBDA_DWDM:
+		cable_comp = " 100GE-DWDM2";
+		break;
 	default:
-		cable_comp = "Unknown or Unsupported";
+		cable_comp = " Unknown or Unsupported";
 		break;
 	}
 
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/fs/sandbox/sandboxfs.c OCTEON-SDK/bootloader/u-boot/fs/sandbox/sandboxfs.c
--- OCTEON_SDK_CLEAN/bootloader/u-boot/fs/sandbox/sandboxfs.c	2015-11-20 17:47:28.000000000 -0800
+++ OCTEON-SDK/bootloader/u-boot/fs/sandbox/sandboxfs.c	2018-06-28 15:08:31.082008795 -0700
@@ -72,6 +72,14 @@ int sandbox_fs_ls(const char *dirname)
 	return 0;
 }
 
+int sandbox_fs_exists(const char *filename)
+{
+	ssize_t sz;
+
+	sz = os_get_filesize(filename);
+	return sz >= 0;
+}
+
 void sandbox_fs_close(void)
 {
 }
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/include/configs/octeon_copperhead.h OCTEON-SDK/bootloader/u-boot/include/configs/octeon_copperhead.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/include/configs/octeon_copperhead.h	2018-05-15 11:35:39.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/include/configs/octeon_copperhead.h	2018-06-28 15:08:31.082008795 -0700
@@ -289,4 +289,10 @@
 #define CONFIG_SYS_SSD_VPD_SENSOR_TYPE	0x44
 #define CONFIG_SYS_SSD_VPD_SENSOR_ADDR	CONFIG_SYS_I2C_DTT_ADDR
 
+/** enable the Hush shell */
+#define CONFIG_SYS_HUSH_PARSER
+
+/** enable Cavium enhancements to Hush shell */
+#define CONFIG_SYS_HUSH_PARSER_CAVIUM_EXTRA
+
 #endif	/* __OCTEON_COPPERHEAD_H__ */
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/include/configs/octeon_nic225e.h OCTEON-SDK/bootloader/u-boot/include/configs/octeon_nic225e.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/include/configs/octeon_nic225e.h	2018-05-15 11:35:39.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/include/configs/octeon_nic225e.h	2018-06-28 15:08:31.083008796 -0700
@@ -264,4 +264,10 @@
  */
 #define CONFIG_OCTEON_REMOTE_HOTPLUG
 
+/** enable the Hush shell */
+#define CONFIG_SYS_HUSH_PARSER
+
+/** enable Cavium enhancements to Hush shell */
+#define CONFIG_SYS_HUSH_PARSER_CAVIUM_EXTRA
+
 #endif	/* __OCTEON_NIC225E_H__ */
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/include/configs/octeon_nic73.h OCTEON-SDK/bootloader/u-boot/include/configs/octeon_nic73.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/include/configs/octeon_nic73.h	2018-05-15 11:35:39.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/include/configs/octeon_nic73.h	2018-06-28 15:08:31.083008796 -0700
@@ -281,5 +281,10 @@
  */
 #define CONFIG_OCTEON_REMOTE_HOTPLUG
 
+/** enable the Hush shell */
+#define CONFIG_SYS_HUSH_PARSER
+
+/** enable Cavium enhancements to Hush shell */
+#define CONFIG_SYS_HUSH_PARSER_CAVIUM_EXTRA
 
 #endif	/* __OCTEON_NIC73_H__ */
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/include/sfp.h OCTEON-SDK/bootloader/u-boot/include/sfp.h
--- OCTEON_SDK_CLEAN/bootloader/u-boot/include/sfp.h	2018-05-15 11:35:39.000000000 -0700
+++ OCTEON-SDK/bootloader/u-boot/include/sfp.h	2018-06-28 15:08:31.083008796 -0700
@@ -69,16 +69,16 @@ enum phy_sfp_rate {
  */
 enum phy_sfp_cable_ext_compliance {
 	SFP_CABLE_UNSPEC = 0,
-	SFP_CABLE_100G_AOC_HIGH_BER = 0x01,	/** Active optical cable */
-	SFP_CABLE_100G_SR4 = 0x2,
-	SFP_CABLE_100G_LR4 = 0x3,
-	SFP_CABLE_100G_ER4 = 0x4,
+	SFP_CABLE_100G_25GAUI_C2M_AOC_HIGH_BER = 0x01,	/** Active optical cable */
+	SFP_CABLE_100G_SR4_25G_SR = 0x2,
+	SFP_CABLE_100G_LR4_25G_LR = 0x3,
+	SFP_CABLE_100G_ER4_25G_ER = 0x4,
 	SFP_CABLE_100G_SR10 = 0x5,
 	SFP_CABLE_100G_CWDM4_MSA = 0x6,
 	SFP_CABLE_100G_PSM4 = 0x7,
-	SFP_CABLE_100G_ACC_HIGH_BER = 0x8,
+	SFP_CABLE_100G_25GAUI_C2M_ACC_HIGH_BER = 0x8,
 	SFP_CABLE_100G_CWDM4 = 0x9,
-	SFP_CABLE_100G_CR4 = 0xA,
+	SFP_CABLE_100G_CR4_25G_CR_CA_L = 0xB,
 	SFP_CABLE_25G_CR_CA_S = 0xC,
 	SFP_CABLE_25G_CR_CA_N = 0xD,
 	SFP_CABLE_40G_ER4 = 0x10,
@@ -89,8 +89,8 @@ enum phy_sfp_cable_ext_compliance {
 	SFP_CABLE_G959_1_P1L1_2D2 = 0x15,
 	SFP_CABLE_10GBASE_T = 0x16,
 	SFP_CABLE_100G_CLR4 = 0x17,
-	SFP_CABLE_100G_AOC_LOW_BER = 0x18,
-	SFP_CABLE_100G_ACC_LOW_BER = 0x19,
+	SFP_CABLE_100G_25GAUI_C2M_AOC_LOW_BER = 0x18,
+	SFP_CABLE_100G_25GAUI_C2M_ACC_LOW_BER = 0x19,
 	SFP_CABLE_100G_2_LAMBDA_DWDM = 0x1a
 };
 
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/bootloader/u-boot/tools/setlocalversion OCTEON-SDK/bootloader/u-boot/tools/setlocalversion
--- OCTEON_SDK_CLEAN/bootloader/u-boot/tools/setlocalversion	2015-11-20 17:47:44.000000000 -0800
+++ OCTEON-SDK/bootloader/u-boot/tools/setlocalversion	2018-06-28 15:08:31.084008797 -0700
@@ -151,10 +151,11 @@ CONFIG_LOCALVERSION=
 CONFIG_LOCALVERSION_AUTO=y
 
 # Check for svn and a svn repo.
-if rev=`svnversion 2>/dev/null` ; then
+svn info 2>/dev/null
+if test $? -eq 0 && rev=`svnversion 2>/dev/null` ; then
 	rev=`echo "${rev}" | awk '{print $NF}'`
         sdk_rev=`svnversion $OCTEON_ROOT/executive | awk '{print $NF}'`
-	printf -- ' (Development build, svnversion: u-boot:%s, exec:%s)' $rev $sdk
+	printf -- ' (Development build, svnversion: u-boot:%s, exec:%s)' $rev $sdk_rev
 fi
 
 # localversion* files in the build and source directory
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-app-hotplug.c OCTEON-SDK/executive/cvmx-app-hotplug.c
--- OCTEON_SDK_CLEAN/executive/cvmx-app-hotplug.c	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-app-hotplug.c	2018-06-28 15:08:31.084008797 -0700
@@ -375,7 +375,6 @@ void cvmx_app_hotplug_core_shutdown(void
 static void __cvmx_app_hotplug_shutdown(
 	struct cvmx_mbox *self, uint64_t *registers)
 {
-	cvmx_sysinfo_t *sys_info_ptr = cvmx_sysinfo_get();
 	cvmx_app_hotplug_info_t *ai = cvmx_app_hotplug_info_ptr;
 	int core = cvmx_get_core_num();
 
@@ -384,15 +383,10 @@ static void __cvmx_app_hotplug_shutdown(
 		return;
 	}
 
-	if (cvmx_coremask_cmp(&ai->hotplug_activated_coremask,
-			       &sys_info_ptr->core_mask)) {
-		cvmx_dprintf("WARNING: Hotplug requested on core %d "
-			"when not all app cores have activated hotplug\n"
-		       "Application coremask:\n", core);
-		cvmx_coremask_print(&sys_info_ptr->core_mask);
-		puts("Hotplug coremask:");
-		cvmx_coremask_print(&ai->hotplug_activated_coremask);
-		// return;
+	if (!cvmx_coremask_is_core_set(&ai->hotplug_activated_coremask, core)) {
+		cvmx_dprintf("ERROR: Hotplug [shutdown] requested but core %d "
+		             "has not activated hotplug.\n", core);
+		return;
 	}
 
 #ifdef DEBUG
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-app-init.c OCTEON-SDK/executive/cvmx-app-init.c
--- OCTEON_SDK_CLEAN/executive/cvmx-app-init.c	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-app-init.c	2018-06-28 15:08:31.085008798 -0700
@@ -304,6 +304,7 @@ char octeon_rev_signature[] =
 #define OCTEON_BL_FLAG_HPLUG_CORES (1 << 6)
 void __cvmx_app_init(uint64_t app_desc_addr)
 {
+	unsigned int i;
 	uint64_t tmp;
 	/* App descriptor used by bootloader */
 	octeon_boot_descriptor_t *app_desc_ptr = CASTPTR(octeon_boot_descriptor_t, app_desc_addr);
@@ -407,13 +408,19 @@ void __cvmx_app_init(uint64_t app_desc_a
 		octeon_model_version_check(chip_id);
 	}
 
+	/* Check for param indicating live application upgrade is in-progress */
+	for (i = 0; i < app_desc_ptr->argc; i++) {
+		const char *argv = CASTPTR(const char, CVMX_ADD_SEG32(CVMX_MIPS32_SPACE_KSEG0, app_desc_ptr->argv[i]));
+		if (strncmp(argv, "lio-live-upg", 12) == 0)
+			sys_info_ptr->bootloader_config_flags |= CVMX_BOOTINFO_CFG_FLAG_LIVE_UPGRADE;
+	}
+
 	cvmx_interrupt_initialize();
 	if (debug)
 		cvmx_dprintf("%s: interrupts initialized\n", __FUNCTION__);
 
 	if ( sys_info_ptr->init_core == core ) {
 		int break_uart = 0;
-		unsigned int i;
 
 		if (breakflag && cvmx_debug_booted()) {
 			cvmx_dprintf("ERROR: Using debug and break together in not supported.\n");
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-app-init.h OCTEON-SDK/executive/cvmx-app-init.h
--- OCTEON_SDK_CLEAN/executive/cvmx-app-init.h	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-app-init.h	2018-06-28 15:08:31.085008798 -0700
@@ -211,6 +211,7 @@ typedef struct cvmx_bootinfo cvmx_bootin
 ** 0x10000000 - 0x20000000 boot bus region. */
 #define CVMX_BOOTINFO_CFG_FLAG_OVERSIZE_TLB_MAPPING     (1ull << 4)
 #define CVMX_BOOTINFO_CFG_FLAG_BREAK			(1ull << 5)
+#define CVMX_BOOTINFO_CFG_FLAG_LIVE_UPGRADE		(1ull << 31)
 
 #endif /*   (CVMX_BOOTINFO_MAJ_VER == 1) */
 
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-error3.c OCTEON-SDK/executive/cvmx-error3.c
--- OCTEON_SDK_CLEAN/executive/cvmx-error3.c	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-error3.c	2018-06-28 15:08:31.086008799 -0700
@@ -102,6 +102,7 @@ struct lmc_sec_error {
 
 static CVMX_SHARED struct cvmx_error_78xx *octeon_error_array_current = NULL;
 static CVMX_SHARED int octeon_error_array_current_size = 0;
+CVMX_SHARED void (*printf_hook)(const char *fmt, ...);
 
 /** Log of single-bit ECC errors */
 static CVMX_SHARED struct lmc_sec_error sec_errors[MAX_SEC_ERRORS];
@@ -558,11 +559,9 @@ int cvmx_error_intsn_display_v3(int node
 		return cvmx_error3_handler_override(idx, entry);
 
 	if (!handled) {
-#if DEBUG_ERROR
-		if (entry->flags == CVMX_ERROR_TYPE_SBE)
-	cvmx_safe_printf("%s\n", msg);
+		if (printf_hook)
+			(*printf_hook)("%s\n", msg);
 		else
-#endif
 			cvmx_safe_printf("%s\n", msg);
 	}
 
@@ -587,6 +586,7 @@ int cvmx_error_initialize_cn78xx(int nod
 	int arrsize;
 	int procid = cvmx_get_proc_id();
 	struct cvmx_error_array *array = octeon_error_arrays;
+	bool live_upgrade;
 
 	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM)
 		return 0;
@@ -609,13 +609,29 @@ int cvmx_error_initialize_cn78xx(int nod
 	octeon_error_array_current = array->array;
 	octeon_error_array_current_size = arrsize;
 
+	live_upgrade = cvmx_sysinfo_get()->bootloader_config_flags &
+		       CVMX_BOOTINFO_CFG_FLAG_LIVE_UPGRADE;
+
 	/* Enable all interrupts described in the array */
 	for (i = 0; octeon_error_array_current[i].block_csr != 0; i++)
 		if (octeon_error_array_current[i].error_group != CVMX_ERROR_GROUP_ETHERNET
 		    && octeon_error_array_current[i].error_group != CVMX_ERROR_GROUP_ILA
-		    && octeon_error_array_current[i].error_group != CVMX_ERROR_GROUP_ILK)
+		    && octeon_error_array_current[i].error_group != CVMX_ERROR_GROUP_ILK
+		       /* during LiveUpgrade, don't enable PCI interrupts here (see below) */
+		    && (octeon_error_array_current[i].error_group != CVMX_ERROR_GROUP_PCI || !live_upgrade))
 			cvmx_error_intsn_enable_v3(node, octeon_error_array_current[i].intsn);
 
+	/* During LiveUpgrade, enable all PCI interrupts EXCEPT M0V0_FLR & M0V1_FLR 
+	 * (see bug 31311)
+	 */
+	for (i = 0; live_upgrade &&
+		    (octeon_error_array_current[i].block_csr != 0) &&
+		    (octeon_error_array_current[i].error_group == CVMX_ERROR_GROUP_PCI);
+		    i++) {
+		if ( (octeon_error_array_current[i].intsn != 0x1f002) &&
+		     (octeon_error_array_current[i].intsn != 0x1f004))
+			cvmx_error_intsn_enable_v3(node, octeon_error_array_current[i].intsn);
+	}
 	return 0;
 }
 
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-fpa.c OCTEON-SDK/executive/cvmx-fpa.c
--- OCTEON_SDK_CLEAN/executive/cvmx-fpa.c	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-fpa.c	2018-06-28 15:08:31.087008800 -0700
@@ -1729,4 +1729,14 @@ int cvmx_fpa_validate_pool(int pool)
 
 #endif /* !CVMX_BUILD_FOR_LINUX_KERNEL */
 
+void cvmx_save_fpa3_pool_and_aura_info(void **pool_info, void **aura_info)
+{
+	*pool_info = cvmx_fpa3_pool_info[0];
+	*aura_info = cvmx_fpa3_aura_info[0];
+}
 
+void cvmx_restore_fpa3_pool_and_aura_info(void *pool_info, void *aura_info)
+{
+	cvmx_fpa3_pool_info[0] = pool_info;
+	cvmx_fpa3_aura_info[0] = aura_info;
+}
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-helper-bgx.c OCTEON-SDK/executive/cvmx-helper-bgx.c
--- OCTEON_SDK_CLEAN/executive/cvmx-helper-bgx.c	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-helper-bgx.c	2018-06-28 15:08:31.089008802 -0700
@@ -1658,6 +1658,9 @@ static int __cvmx_helper_bgx_xaui_link_i
 	int rgmii_first = 0;
 	int qlm = cvmx_qlm_lmac(xiface, index);
 	int use_ber = 0;
+	uint64_t err_blks;
+	uint64_t ber_cnt;
+	uint64_t error_debounce;
 
 	if (debug)
 		cvmx_dprintf("%s: interface %u:%d/%d\n",
@@ -1958,32 +1961,75 @@ static int __cvmx_helper_bgx_xaui_link_i
 	}
 
 	if (use_ber) {
-		/* Clear out the BGX error counters/bits. These errors are expected
-		   as part of the BGX link up procedure */
-		/* BIP_ERR counters clear as part of this read */
-		cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(index, xi.interface));
-		/* BER_CNT and ERR_BLKs clear as part of this read */
+		/* Clearing BER_CNT and ERR_BLKs */
 		br_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_STATUS2(index, xi.interface));
-		/* Checking that latched BLOCK_LOCK is still set (Block Lock never lost) */
-		if (!br_status2.s.latched_lock) {
-			cvmx_dprintf("ERROR: %d:BGX%d:%d: BASE-R PCS block lock lost, need to retry\n", node, xi.interface, index);
-			return -1;
-		}
 
 		/* If set, clear the LATCHED_BER by writing it to a one.  */
 		if (br_status2.s.latched_ber)
 			cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_STATUS2(index, xi.interface), br_status2.u64);
 
-		/* Complete a BER test. If latched_ber = 1, then BER >= 10e^4 */
-		/* The BER detection time window is 125us for 10GBASE-R (1250us for 40G). */
-		cvmx_wait_usec(1500);
-		br_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_STATUS2(index, xi.interface));
-		if (br_status2.s.latched_ber) {
+		error_debounce = cvmx_clock_get_count(CVMX_CLOCK_CORE) + 100000 *
+			cvmx_clock_get_rate(CVMX_CLOCK_CORE) / 1000000;
+
+		/* Clear error counts */
+		err_blks = 0;
+		ber_cnt = 0;
+
+		/* Verify that the link is up and  error free for 100ms */
+		while (cvmx_clock_get_count(CVMX_CLOCK_CORE) < error_debounce) {
+			spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, xi.interface));
+			/* Checking that Receive link is still up (rcv_lnk = 1 (up)) */
+			if (!spu_status1.s.rcv_lnk) {
 #ifdef DEBUG_BGX
-			cvmx_dprintf("ERROR: %d:BGX%d:%d: BER test failed, BER >= 10e^4, need to retry\n", node, xi.interface, index);
+				cvmx_dprintf("ERROR: %d:BGX%d:%d: Receive link down\n", node, xi.interface, index);
 #endif
-			return -1;
-		}
+				return -1;
+			}
+
+			/* Checking if latched_ber = 1 (BER >= 10e^4) */
+			br_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_STATUS2(index, xi.interface));
+			err_blks += br_status2.s.err_blks;
+			ber_cnt += br_status2.s.ber_cnt;  
+                        
+			if (br_status2.s.latched_ber) {
+#ifdef DEBUG_BGX
+				cvmx_dprintf("ERROR: %d:BGX%d:%d: BER test failed, BER >= 10e^4, need to retry\n", node, xi.interface, index);
+#endif
+				return -1;
+
+			}
+			/* Checking that latched BLOCK_LOCK is still set (Block Lock never lost) */
+			if (!br_status2.s.latched_lock) {
+#ifdef DEBUG_BGX
+				cvmx_dprintf("ERROR: %d:BGX%d:%d: BASE-R PCS block lock lost, need to retry\n", node, xi.interface, index);
+#endif
+				return -1;
+			}
+
+			/* Check error counters. Must be 0 (this error rate is much higher than 1E-12) */
+			if (err_blks > 0) {
+#ifdef DEBUG_BGX
+				cvmx_dprintf("ERROR: %d:BGX%d:%d: BASE-R errored-blocks (%llu) detected, need to retry\n", node, xi.interface, index, (unsigned long long)err_blks);
+#endif
+				return -1;
+			}
+
+			if (ber_cnt > 0) {
+#ifdef DEBUG_BGX
+				cvmx_dprintf("ERROR: %d:BGX%d:%d: BASE-R bit-errors (%llu) detected, need to retry\n", node, xi.interface, index, (unsigned long long)ber_cnt);
+#endif
+				return -1;
+			}
+
+			cvmx_wait_usec(1000);
+		}	
+		                
+		/* Clear out the BGX error counters/bits. These errors are expected
+		   as part of the BGX link up procedure */
+		/* BIP_ERR counters clear as part of this read */
+		cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(index, xi.interface));
+		/* BER_CNT and ERR_BLKs clear as part of this read */
+		br_status2.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_STATUS2(index, xi.interface));
 	}
 
 	/* (7) Enable packet transmit and receive */
@@ -2061,6 +2107,8 @@ cvmx_helper_link_info_t __cvmx_helper_bg
 	cvmx_bgxx_cmrx_config_t cmr_config;
 	cvmx_helper_link_info_t result;
 	cvmx_helper_interface_mode_t mode;
+	cvmx_bgxx_spux_misc_control_t spu_misc_control;
+	cvmx_bgxx_spux_br_status2_t br_status2;
 
 	result.u64 = 0;
 
@@ -2072,12 +2120,19 @@ cvmx_helper_link_info_t __cvmx_helper_bg
 	if (mode == CVMX_HELPER_INTERFACE_MODE_RGMII)
 		return __cvmx_helper_bgx_sgmii_link_get(xipd_port);
 
+	/* Reading current rx/tx link status */
 	spu_status1.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SPUX_STATUS1(index, xi.interface));
 	smu_tx_ctl.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SMUX_TX_CTL(index, xi.interface));
 	smu_rx_ctl.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SMUX_RX_CTL(index, xi.interface));
+	/* Reading tx/rx packet enables */
+	cmr_config.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface));   
+	spu_misc_control.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SPUX_MISC_CONTROL(index, xi.interface));   
 
 	if ((smu_tx_ctl.s.ls == 0)     &&
 	    (smu_rx_ctl.s.status == 0) &&
+	    (cmr_config.s.data_pkt_tx_en == 1) &&
+	    (cmr_config.s.data_pkt_rx_en == 1) &&
+	    (spu_misc_control.s.rx_packet_dis == 0) &&
 	    (spu_status1.s.rcv_lnk)) {
 		int lanes;
 		int qlm = cvmx_qlm_lmac(xiface, index);
@@ -2120,14 +2175,48 @@ cvmx_helper_link_info_t __cvmx_helper_bg
 		result.s.speed = speed;
 	} else {
 		int res;
-		res = __cvmx_helper_bgx_xaui_link_init(index, xiface);
-		if (res == -1) {
+		uint64_t err_blks = 0;
+		uint64_t ber_cnt = 0;
+
+		/* Check for err_blk and ber errors if 10G or 40G */
+		if ((mode == CVMX_HELPER_INTERFACE_MODE_XFI
+		     || mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
+		     || mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
+		     || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4)
+		     && (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM)) {
+			br_status2.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SPUX_BR_STATUS2(index, xi.interface));
+			err_blks = br_status2.s.err_blks;
+			ber_cnt = br_status2.s.ber_cnt;  
+		}
+
+		/* Checking if the link is up and error-free but we are receiving remote-faults */
+		if ((smu_tx_ctl.s.ls != 1)     && 
+	    	    (smu_rx_ctl.s.status != 1) &&
+		    (cmr_config.s.data_pkt_tx_en == 1) &&
+		    (cmr_config.s.data_pkt_rx_en == 1) &&
+		    (spu_misc_control.s.rx_packet_dis == 0) &&
+		    (err_blks == 0) &&
+		    (ber_cnt == 0) &&
+		    (spu_status1.s.rcv_lnk)) {		
+			result.s.init_success = 1;
+#ifdef DEBUG_BGX
+			cvmx_dprintf("Receiving remote-fault ordered sets %d:BGX(%d,%d)\n", xi.node, xi.interface, index);
+#endif
+
+		} else {
+			res = __cvmx_helper_bgx_xaui_link_init(index, xiface);
+			if (res == -1) {
 #ifdef DEBUG_BGX
 				cvmx_dprintf("Failed to get %d:BGX(%d,%d) link\n", xi.node, xi.interface, index);
 #endif
-			return result;
-		}
-	}
+			} else {
+#ifdef DEBUG_BGX
+			cvmx_dprintf("Link initialization successful %d:BGX(%d,%d)\n", xi.node, xi.interface, index);
+#endif
+				result.s.init_success = 1;	
+			}
+		}	
+	}                                                    
 
 	return result;
 }
@@ -2143,6 +2232,8 @@ int __cvmx_helper_bgx_xaui_link_set(int
 	cvmx_bgxx_smux_rx_ctl_t smu_rx_ctl;
 	cvmx_bgxx_spux_status1_t spu_status1;
 	cvmx_helper_interface_mode_t mode;
+	cvmx_bgxx_cmrx_config_t cmr_config;
+	cvmx_bgxx_spux_misc_control_t spu_misc_control;
 
 	if (debug)
 		cvmx_dprintf("%s: interface %u:%d/%d\n",
@@ -2152,16 +2243,25 @@ int __cvmx_helper_bgx_xaui_link_set(int
 	if (mode == CVMX_HELPER_INTERFACE_MODE_RGMII)
 		return __cvmx_helper_bgx_sgmii_link_set(xipd_port, link_info);
 
+	/* Reading current rx/tx link status */
 	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, xi.interface));
 	smu_rx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(index, xi.interface));
 	spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, xi.interface));
+	/* Reading tx/rx packet enables */
+	cmr_config.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface));
+	spu_misc_control.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SPUX_MISC_CONTROL(index, xi.interface));
 
 	/* If the link shouldn't be up, then just return */
 	if (!link_info.s.link_up)
 		return 0;
 
-	/* Do nothing if both RX and TX are happy */
-	if ((smu_tx_ctl.s.ls == 0) && (smu_rx_ctl.s.status == 0) && spu_status1.s.rcv_lnk)
+	/* Do nothing if both RX and TX are happy and packet transmission/reception is enabled */
+	if ((smu_tx_ctl.s.ls == 0)     &&
+	    (smu_rx_ctl.s.status == 0) &&
+	    (cmr_config.s.data_pkt_tx_en == 1) &&
+	    (cmr_config.s.data_pkt_rx_en == 1) &&
+	    (spu_misc_control.s.rx_packet_dis == 0) &&
+	    (spu_status1.s.rcv_lnk))
 		return 0;
 
 	/* Bring the link up */
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-helper-board.c OCTEON-SDK/executive/cvmx-helper-board.c
--- OCTEON_SDK_CLEAN/executive/cvmx-helper-board.c	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-helper-board.c	2018-06-28 15:08:31.091008804 -0700
@@ -705,7 +705,7 @@ int cvmx_sfp_vsc7224_mod_abs_changed(str
 		return 0;
 
 	/* We're here if we detect that the module is now present */
-	err = cvmx_sfp_read_i2c_eeprom(sfp);
+	err = cvmx_sfp_parse_i2c_eeprom(sfp);
 	if (err) {
 		cvmx_dprintf("%s: Error reading the SFP module eeprom for %s\n",
 			     __func__, sfp->name);
@@ -794,6 +794,47 @@ int cvmx_sfp_vsc7224_mod_abs_changed(str
 
 	return err;
 }
+
+/**
+ * Function called whenever mod_abs/mod_prs has changed for Avago AVSP5410
+ *
+ * @param	sfp	pointer to SFP data structure
+ * @param	val	1 if absent, 0 if present, otherwise not set
+ * @param	data	user-defined data
+ *
+ * @return	0 for success, -1 on error
+	 */
+int cvmx_sfp_avsp5410_mod_abs_changed(struct cvmx_fdt_sfp_info *sfp, int val,
+				     void *data)
+{
+	int err;
+	struct cvmx_sfp_mod_info *mod_info;
+	const int dbg = device_tree_dbg;
+
+	if (dbg)
+		cvmx_dprintf("%s(%s, %d, %p): Module %s\n", __func__,
+			     sfp->name, val, data, val ? "absent" : "present");
+	if (val)
+		return 0;
+
+	/* We're here if we detect that the module is now present */
+	err = cvmx_sfp_parse_i2c_eeprom(sfp);
+	if (err) {
+		cvmx_dprintf("%s: Error reading the SFP module eeprom for %s\n",
+			     __func__, sfp->name);
+		return err;
+	}
+	mod_info = &sfp->sfp_info;
+
+	if (!mod_info->valid || !sfp->valid) {
+		if (dbg)
+			cvmx_dprintf("%s: Module data is invalid\n", __func__);
+			return -1;
+		}
+
+	return err;
+}
+
 #define CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA	0x108F
 #define CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB	0x1090
 #define CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB		0x12AC
@@ -976,7 +1017,7 @@ int cvmx_sfp_cs4343_mod_abs_changed(stru
 		return 0;
 
 	/* We're here if we detect that the module is now present */
-	err = cvmx_sfp_read_i2c_eeprom(sfp);
+	err = cvmx_sfp_parse_i2c_eeprom(sfp);
 	if (err) {
 		cvmx_dprintf("%s: Error reading the SFP module eeprom for %s\n",
 			     __func__, sfp->name);
@@ -1067,6 +1108,7 @@ static int cvmx_is_cortina(const struct
 int cvmx_helper_phy_register_mod_abs_changed(int xiface, int index)
 {
 	struct cvmx_vsc7224_chan *vsc7224_chan;
+	struct cvmx_avsp5410 *avsp5410;
 	struct cvmx_phy_info *phy_info;
 	struct cvmx_fdt_sfp_info *sfp_info;
 	int cortina_type;
@@ -1094,6 +1136,18 @@ int cvmx_helper_phy_register_mod_abs_cha
 		return 0;
 	}
 
+	/* See if the Avago AVSP5410 phy has been used */
+	avsp5410 = cvmx_helper_cfg_get_avsp5410_info(xiface, index);
+	if (avsp5410) {
+		if (device_tree_dbg)
+			cvmx_dprintf("%s: Registering AVSP5410 handler\n",
+				     __func__);
+		cvmx_sfp_register_mod_abs_changed(sfp_info,
+						  &cvmx_sfp_avsp5410_mod_abs_changed,
+						  NULL);
+		return 0;
+	}
+
 	/* Check which phy is used, i.e. Inphi CS4343 */
 	phy_info = cvmx_helper_get_port_phy_info(xiface, index);
 	if (!phy_info) {
@@ -1163,6 +1217,10 @@ int __cvmx_helper_78xx_parse_phy(struct
 			cvmx_dprintf("Error: could not parse Microsemi VSC7224 in DT\n");
 			return -1;
 		}
+		if (__cvmx_fdt_parse_avsp5410(fdt_addr)) {
+			cvmx_dprintf("Error: could not parse Avago AVSP5410 in DT\n");
+			return -1;
+		}
 		if (octeon_has_feature(OCTEON_FEATURE_BGX_XCV) &&
 		    __cvmx_helper_parse_bgx_rgmii_dt(fdt_addr)) {
 			cvmx_printf("Error: could not parse BGX XCV device tree\n");
@@ -1733,7 +1791,6 @@ int __cvmx_helper_parse_bgx_dt(void *fdt
 					     fdt_phy_node);
 			cvmx_helper_set_port_phy_present(xiface, port_index,
 							 false);
-
 		}
 		gpio_leds = __cvmx_helper_parse_gpio_leds(fdt_addr,
 							  fdt_port_node, false);
@@ -1815,7 +1872,7 @@ int __cvmx_helper_parse_bgx_dt(void *fdt
 				cvmx_dprintf("%s: No SFP slots found\n",
 					     __func__);
 			}
-	}
+		}
 	}
 	parsed = true;
 	return 0;
@@ -1959,6 +2016,7 @@ int __cvmx_helper_board_get_port_from_dt
 	int phy_node_offset;
 	int parse_bgx_dt_err;
 	int parse_vsc7224_err;
+	int parse_avsp5410_err;
 
 	if (dbg)
 		cvmx_dprintf("%s(%p, %d)\n", __func__, fdt_addr, ipd_port);
@@ -1975,8 +2033,10 @@ int __cvmx_helper_board_get_port_from_dt
 					__cvmx_helper_parse_bgx_dt(fdt_addr);
 				parse_vsc7224_err =
 					__cvmx_fdt_parse_vsc7224(fdt_addr);
-				if (!parse_bgx_dt_err && !parse_vsc7224_err)
-				fdt_ports_initialized = 1;
+				parse_avsp5410_err =
+					__cvmx_fdt_parse_avsp5410(fdt_addr);
+				if (!parse_bgx_dt_err && !parse_vsc7224_err && !parse_avsp5410_err)
+					fdt_ports_initialized = 1;
 			} else {
 				cvmx_dprintf("%s: Error parsing FDT\n",
 					     __func__);
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-helper-board.h OCTEON-SDK/executive/cvmx-helper-board.h
--- OCTEON_SDK_CLEAN/executive/cvmx-helper-board.h	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-helper-board.h	2018-06-28 15:08:31.091008804 -0700
@@ -199,6 +199,23 @@ struct cvmx_vsc7224 {
 	int	of_offset;	/** Offset in device tree */
 };
 
+/** Data structure for Avago AVSP5410 gearbox phy */
+struct cvmx_avsp5410 {
+	const char *name;			/** Name */
+	/** I2C bus device is connected to */
+	struct cvmx_fdt_i2c_bus_info	*i2c_bus;
+	/** Address of AVSP5410 on i2c bus */
+	int	i2c_addr;
+	int	of_offset;	/** Offset in device tree */
+	int	ipd_port;	/** IPD port this phy belongs to */
+	int	xiface;		/** xinterface of SFP */
+	int	index;		/** Port index of SFP */
+	uint64_t prev_temp;     /** Previous temparature recorded on Phy Core */
+	uint64_t prev_temp_mins; /** Mininutes when the prev temp check is done */
+	/** (Q)SFP attached to this phy */
+	struct cvmx_fdt_sfp_info *sfp_info;
+};
+
 struct cvmx_cs4343_info;
 
 /**
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-helper-cfg.c OCTEON-SDK/executive/cvmx-helper-cfg.c
--- OCTEON_SDK_CLEAN/executive/cvmx-helper-cfg.c	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-helper-cfg.c	2018-06-28 15:08:31.092008805 -0700
@@ -1011,6 +1011,8 @@ int __cvmx_helper_init_port_valid(void)
 		rc = __cvmx_helper_parse_bgx_dt(fdt_addr);
 		if (!rc)
 			rc = __cvmx_fdt_parse_vsc7224(fdt_addr);
+		if (!rc)
+			rc = __cvmx_fdt_parse_avsp5410(fdt_addr);
 		if (!rc && octeon_has_feature(OCTEON_FEATURE_BGX_XCV))
 			rc = __cvmx_helper_parse_bgx_rgmii_dt(fdt_addr);
 
@@ -1674,6 +1676,39 @@ void cvmx_helper_cfg_set_vsc7224_chan_in
 }
 
 /**
+ * Get data structure defining the Avago AVSP5410 phy info
+ * or NULL if not present
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ *
+ * @return pointer to avsp5410 data structure or NULL if not present
+ */
+struct cvmx_avsp5410 *cvmx_helper_cfg_get_avsp5410_info(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	return cvmx_cfg_port[xi.node][xi.interface][index].avsp5410;
+}
+
+/**
+ * Sets the Avago AVSP5410 phy info data structure
+ *
+ * @param	xiface	node and interface
+ * @param	index	port index
+ * @param[in]	avsp5410_info	Avago AVSP5410 data structure
+ */
+void cvmx_helper_cfg_set_avsp5410_info(int xiface, int index,
+				struct cvmx_avsp5410 *avsp5410_info)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].avsp5410 = avsp5410_info;
+}
+
+/**
  * Gets the SFP data associated with a port
  *
  * @param	xiface	node and interface
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-helper-cfg.h OCTEON-SDK/executive/cvmx-helper-cfg.h
--- OCTEON_SDK_CLEAN/executive/cvmx-helper-cfg.h	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-helper-cfg.h	2018-06-28 15:08:31.092008805 -0700
@@ -157,6 +157,8 @@ struct cvmx_cfg_port_param {
 	int sfp_of_offset;
 	/** Microsemi VSC7224 channel info data structure */
 	struct cvmx_vsc7224_chan *vsc7224_chan;
+	/** Avago AVSP-5410 Phy */
+	struct cvmx_avsp5410 *avsp5410;
 };
 
 /*
@@ -767,6 +769,27 @@ void cvmx_helper_cfg_set_vsc7224_chan_in
 				struct cvmx_vsc7224_chan *vsc7224_chan_info);
 
 /**
+ * Get data structure defining the Avago AVSP5410 phy info
+ * or NULL if not present
+ *
+ * @param xiface        node and interface
+ * @param index         port index
+ *
+ * @return pointer to avsp5410 data structure or NULL if not present
+ */
+struct cvmx_avsp5410 *cvmx_helper_cfg_get_avsp5410_info(int xiface, int index);
+
+/**
+ * Sets the Avago AVSP5410 phy info data structure
+ *
+ * @param       xiface  node and interface
+ * @param       index   port index
+ * @param[in]   avsp5410_info   Avago AVSP5410 data structure
+ */
+void cvmx_helper_cfg_set_avsp5410_info(int xiface, int index,
+                                struct cvmx_avsp5410 *avsp5410_info);
+
+/**
  * Gets the SFP data associated with a port
  *
  * @param	xiface	node and interface
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-helper-sfp.c OCTEON-SDK/executive/cvmx-helper-sfp.c
--- OCTEON_SDK_CLEAN/executive/cvmx-helper-sfp.c	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-helper-sfp.c	2018-06-28 15:08:31.093008807 -0700
@@ -180,28 +180,85 @@ static int cvmx_sfp_parse_sfp_buffer(str
 	sfp_info->eth_comp = buffer[3] & 0xf0;
 	sfp_info->cable_comp = buffer[0x24];
 
+	/* There are several ways a cable can be marked as active or
+ 	 * passive.  8.[2-3] specify the SFP+ cable technology.  Some
+ 	 * modules also use 3.[0-1] for Infiniband, though it's
+ 	 * redundant.
+ 	 */
+	if ((buffer[8] & 0x0C) == 0x08) {
+		sfp_info->limiting = true;
+		sfp_info->active_cable = true;
+	} else if ((buffer[8] & 0xC) == 0x4) {
+		sfp_info->limiting = false;
+		sfp_info->active_cable = false;
+	}
+	if ((buffer[3] & 3) == 2) {
+		sfp_info->active_cable = true;
+		sfp_info->limiting = true;
+	}
+
 	switch (sfp_info->mod_type) {
+	case CVMX_SFP_MOD_OPTICAL_LC:
+	case CVMX_SFP_MOD_OPTICAL_PIGTAIL:
+		sfp_info->copper_cable = false;
+		break;
 	case CVMX_SFP_MOD_COPPER_PIGTAIL:
-	case CVMX_SFP_MOD_NO_SEP_CONN:
-		debug("%s: copper pigtail or no separable cable\n", __func__);
-		/* There are several ways a cable can be marked as active or
-		 * passive.  8.[2-3] specify the SFP+ cable technology.  Some
-		 * modules also use 3.[0-1] for Infiniband, though it's
-		 * redundant.
-		 */
 		sfp_info->copper_cable = true;
-		if ((buffer[8] & 0x0C) == 0x08) {
-			sfp_info->limiting = true;
-			sfp_info->active_cable = true;
-		} else if ((buffer[8] & 0xC) == 0x4) {
-			sfp_info->limiting = false;
-			sfp_info->active_cable = false;
-		}
-		if ((buffer[3] & 3) == 2) {
-			sfp_info->active_cable = true;
-			sfp_info->limiting = true;
+		break;
+	case CVMX_SFP_MOD_NO_SEP_CONN:
+		switch (sfp_info->cable_comp) {
+        		case CVMX_SFP_CABLE_100G_25GAUI_C2M_AOC_HIGH_BER:
+        		case CVMX_SFP_CABLE_100G_25GAUI_C2M_AOC_LOW_BER:
+        		case CVMX_SFP_CABLE_100G_25GAUI_C2M_ACC_LOW_BER:
+				sfp_info->copper_cable = false;
+				sfp_info->limiting = true;
+				sfp_info->active_cable = true;
+				break;
+
+        		case CVMX_SFP_CABLE_100G_SR4_25G_SR:
+        		case CVMX_SFP_CABLE_100G_LR4_25G_LR:
+        		case CVMX_SFP_CABLE_100G_ER4_25G_ER:
+        		case CVMX_SFP_CABLE_100G_SR10:
+        		case CVMX_SFP_CABLE_100G_CWDM4_MSA:
+        		case CVMX_SFP_CABLE_100G_PSM4:
+        		case CVMX_SFP_CABLE_100G_CWDM4:
+        		case CVMX_SFP_CABLE_40G_ER4:
+        		case CVMX_SFP_CABLE_4X10G_SR:
+        		case CVMX_SFP_CABLE_G959_1_P1I1_2D1:
+        		case CVMX_SFP_CABLE_G959_1_P1S1_2D2:
+        		case CVMX_SFP_CABLE_G959_1_P1L1_2D2:
+        		case CVMX_SFP_CABLE_100G_CLR4:
+        		case CVMX_SFP_CABLE_100G_2_LAMBDA_DWDM:
+				sfp_info->copper_cable = false;
+				break;
+
+        		case CVMX_SFP_CABLE_100G_25GAUI_C2M_ACC_HIGH_BER:
+				sfp_info->copper_cable = true;
+				sfp_info->limiting = true;
+				sfp_info->active_cable = true;
+				break;
+
+        		case CVMX_SFP_CABLE_100G_CR4_25G_CR_CA_L:
+        		case CVMX_SFP_CABLE_25G_CR_CA_S:
+        		case CVMX_SFP_CABLE_25G_CR_CA_N:
+        		case CVMX_SFP_CABLE_40G_PSM4:
+        		case CVMX_SFP_CABLE_10GBASE_T:
+				sfp_info->copper_cable = true;
+				break;
+
+			default:
+				switch(sfp_info->eth_comp) {
+        				case CVMX_SFP_CABLE_10GBASE_ER:
+        				case CVMX_SFP_CABLE_10GBASE_LRM:
+        				case CVMX_SFP_CABLE_10GBASE_LR:
+        				case CVMX_SFP_CABLE_10GBASE_SR:
+						sfp_info->copper_cable = false;
+						break;
+				}
+				break;
 		}
 		break;
+
 	case CVMX_SFP_MOD_RJ45:
 		debug("%s: RJ45 adapter\n", __func__);
 		sfp_info->copper_cable = true;
@@ -224,11 +281,12 @@ static int cvmx_sfp_parse_sfp_buffer(str
 		} else {
 			debug("Unknown module type 0x%x\n", sfp_info->mod_type);
 		}
-			/* fall through */
-		default:
-			sfp_info->limiting = true;
-			break;
+	/* fall through */
+	default:
+		sfp_info->limiting = true;
+		break;
 	}
+
 	if (sfp_info->copper_cable)
 		sfp_info->max_copper_cable_len = buffer[0x12];
 	else
@@ -243,13 +301,71 @@ static int cvmx_sfp_parse_sfp_buffer(str
 	sfp_info->max_62_5um_om1_cable_length = buffer[0x11] * 10;
 	sfp_info->max_50um_om3_cable_length = buffer[0x13] * 10;
 
-	if (buffer[0xc] == 12) {
-		sfp_info->rate = CVMX_SFP_RATE_1G;
-	} else if (buffer[0xc] == 103) {
-		sfp_info->rate = CVMX_SFP_RATE_10G;
-	} else if (buffer[0xc] == 0xff) {
-		if (buffer[0x42] == 103)
+	if (buffer[0xc] == 0xff) {
+		if (buffer[0x42] >= 255)
+			sfp_info->rate = CVMX_SFP_RATE_100G;
+		else if (buffer[0x42] >= 160)
+			sfp_info->rate = CVMX_SFP_RATE_40G;
+		else if (buffer[0x42] >= 100)
 			sfp_info->rate = CVMX_SFP_RATE_25G;
+		else  {
+			sfp_info->rate = CVMX_SFP_RATE_UNKNOWN;
+		}
+	} else if (buffer[0xc] >= 100) {
+		sfp_info->rate = CVMX_SFP_RATE_10G;
+	} else if (buffer[0xc] >= 10) {
+		sfp_info->rate = CVMX_SFP_RATE_1G;
+	} else {
+		sfp_info->rate = CVMX_SFP_RATE_UNKNOWN;
+	}
+
+	if (sfp_info->rate == CVMX_SFP_RATE_UNKNOWN) {
+		switch (sfp_info->cable_comp) {
+        		case CVMX_SFP_CABLE_100G_SR10:
+        		case CVMX_SFP_CABLE_100G_CWDM4_MSA:
+        		case CVMX_SFP_CABLE_100G_PSM4:
+        		case CVMX_SFP_CABLE_100G_CWDM4:
+        		case CVMX_SFP_CABLE_100G_CLR4:
+        		case CVMX_SFP_CABLE_100G_2_LAMBDA_DWDM:
+				sfp_info->rate = CVMX_SFP_RATE_100G;
+				break;
+        		case CVMX_SFP_CABLE_100G_25GAUI_C2M_AOC_HIGH_BER:
+        		case CVMX_SFP_CABLE_100G_SR4_25G_SR:
+        		case CVMX_SFP_CABLE_100G_LR4_25G_LR:
+        		case CVMX_SFP_CABLE_100G_ER4_25G_ER:
+        		case CVMX_SFP_CABLE_100G_25GAUI_C2M_ACC_HIGH_BER:
+        		case CVMX_SFP_CABLE_100G_CR4_25G_CR_CA_L:
+        		case CVMX_SFP_CABLE_25G_CR_CA_S:
+        		case CVMX_SFP_CABLE_25G_CR_CA_N:
+        		case CVMX_SFP_CABLE_100G_25GAUI_C2M_AOC_LOW_BER:
+        		case CVMX_SFP_CABLE_100G_25GAUI_C2M_ACC_LOW_BER:
+				sfp_info->rate = CVMX_SFP_RATE_25G;
+				break;
+        		case CVMX_SFP_CABLE_40G_ER4:
+        		case CVMX_SFP_CABLE_4X10G_SR:
+        		case CVMX_SFP_CABLE_40G_PSM4:
+				sfp_info->rate = CVMX_SFP_RATE_40G;
+				break;
+        		case CVMX_SFP_CABLE_G959_1_P1I1_2D1:
+        		case CVMX_SFP_CABLE_G959_1_P1S1_2D2:
+        		case CVMX_SFP_CABLE_G959_1_P1L1_2D2:
+        		case CVMX_SFP_CABLE_10GBASE_T:
+				sfp_info->rate = CVMX_SFP_RATE_10G;
+				break;
+			default:
+				switch(sfp_info->eth_comp) {
+        				case CVMX_SFP_CABLE_10GBASE_ER:
+        				case CVMX_SFP_CABLE_10GBASE_LRM:
+        				case CVMX_SFP_CABLE_10GBASE_LR:
+        				case CVMX_SFP_CABLE_10GBASE_SR:
+						sfp_info->rate = CVMX_SFP_RATE_10G;
+						break;
+					default:
+						sfp_info->rate = CVMX_SFP_RATE_UNKNOWN;
+						break;
+				}
+				break;
+		}
 	}
 
 	if (buffer[0xc] < 0xff)
@@ -482,15 +598,15 @@ static int cvmx_sfp_parse_qsfp_buffer(st
 }
 
 /**
- * Reads and parses SFP/QSFP EEPROM
+ * Reads SFP/QSFP EEPROM
  *
  * @param	sfp	sfp handle to read
+ * @param       buffer  Buffer to retrun data from SFP EEPROM
  *
  * @return	0 for success, -1 on error.
  */
-int cvmx_sfp_read_i2c_eeprom(struct cvmx_fdt_sfp_info *sfp)
+int cvmx_sfp_read_i2c_eeprom(struct cvmx_fdt_sfp_info *sfp, uint8_t *buffer)
 {
-	uint8_t buffer[256];
 	const struct cvmx_fdt_i2c_bus_info *bus = sfp->i2c_bus;
 	int err;
 	bool is_qsfp;
@@ -545,6 +661,37 @@ int cvmx_sfp_read_i2c_eeprom(struct cvmx
 	cvmx_print_buffer_u8(0, buffer, 256);
 #endif
 #endif
+
+error:
+	err = cvmx_fdt_enable_i2c_bus(bus, false);
+	if (err) {
+		debug("%s: Error disabling i2c bus\n", __func__);
+		goto error;
+	}
+
+	if (is_qsfp)
+		err |= cvmx_qsfp_select(sfp, false);
+
+	return err;
+}
+
+/**
+ * Reads and parses SFP/QSFP EEPROM
+ *
+ * @param	sfp	sfp handle to read
+ *
+ * @return	0 for success, -1 on error.
+ */
+int cvmx_sfp_parse_i2c_eeprom(struct cvmx_fdt_sfp_info *sfp)
+{
+	uint8_t buffer[256];
+	int err;
+
+	err = cvmx_sfp_read_i2c_eeprom(sfp, buffer);
+	if (err) {
+		return -1;
+	}
+
 	memset(&sfp->sfp_info, 0, sizeof(struct cvmx_sfp_mod_info));
 
 	switch (buffer[0]) {
@@ -562,15 +709,6 @@ int cvmx_sfp_read_i2c_eeprom(struct cvmx
 		err = -1;
 		break;
 	}
-error:
-	err = cvmx_fdt_enable_i2c_bus(bus, false);
-	if (err) {
-		debug("%s: Error disabling i2c bus\n", __func__);
-		goto error;
-	}
-
-	if (is_qsfp)
-		err |= cvmx_qsfp_select(sfp, false);
 
 	if (!err) {
 		sfp->valid = true;
@@ -584,13 +722,26 @@ error:
 }
 
 /**
+ * Returns the information about a SFP/QSFP device
+ *
+ * @param       sfp             sfp handle
+ *
+ * @return      sfp_info        Pointer sfp mod info data structure
+ */
+const struct cvmx_sfp_mod_info *cvmx_phy_get_sfp_mod_info(const struct cvmx_fdt_sfp_info *sfp)
+{
+	return (sfp) ? &sfp->sfp_info : NULL;
+}
+
+
+/**
  * Function called to check and return the status of the mod_abs pin or
  * mod_pres pin for QSFPs.
  *
  * @param	sfp	Handle to SFP information.
  * @param	data	User-defined data passed to the function
  *
- * @return	0 if absent, 1 if present, -1 on error
+ * @return	0 if module present, 1 if module absent, -1 on error
  */
 int cvmx_sfp_check_mod_abs(struct cvmx_fdt_sfp_info *sfp, void *data)
 {
@@ -612,7 +763,7 @@ int cvmx_sfp_check_mod_abs(struct cvmx_f
 	      __func__, sfp->last_mod_abs, val, sfp->mod_abs_changed, err);
 	sfp->last_mod_abs = val;
 
-	return err;
+	return val;
 }
 
 /**
@@ -668,6 +819,62 @@ int cvmx_sfp_register_mod_abs_changed(st
 }
 
 /**
+ * Function called to check and return the status of the tx_fault pin
+ *
+ * @param	sfp	Handle to SFP information.
+ * @param	data	User-defined data passed to the function
+ *
+ * @return	0 if signal present, 1 if signal absent, -1 on error
+ */
+int cvmx_sfp_check_tx_fault(struct cvmx_fdt_sfp_info *sfp, void *data)
+{
+	struct cvmx_fdt_gpio_info *tx_fault = sfp->tx_error;
+	int val;
+
+	debug("%s(%s, %p) tx_fault: %p\n", __func__, sfp->name, data, tx_fault);
+	if (!tx_fault) {
+		printf("%s: Error: tx_fault not set for %s\n",
+		       __func__, sfp->name);
+		return -1;
+	}
+	val = cvmx_fdt_gpio_get(tx_fault);
+	debug("%s: tx_fault: %d\n", __func__, val);
+
+	return val;
+}
+
+/**
+ * Function called to check and return the status of the rx_los pin
+ *
+ * @param	sfp	Handle to SFP information.
+ * @param	data	User-defined data passed to the function
+ *
+ * @return	0 if signal present, 1 if signal absent, -1 on error
+ */
+int cvmx_sfp_check_rx_los(struct cvmx_fdt_sfp_info *sfp, void *data)
+{
+	struct cvmx_fdt_gpio_info *rx_los = sfp->rx_los;
+	int val;
+	int err = 0;
+
+	debug("%s(%s, %p) rx_los: %p\n", __func__, sfp->name, data, rx_los);
+	if (!rx_los) {
+		printf("%s: Error: rx_los not set for %s\n",
+		       __func__, sfp->name);
+		return -1;
+	}
+	val = cvmx_fdt_gpio_get(rx_los);
+	if (val >= 0 && val != sfp->last_rx_los && sfp->rx_los_changed)
+		err = sfp->rx_los_changed(sfp, val,
+					   sfp->rx_los_changed_data);
+	debug("%s: Last rx_los: %d, current: %d, changed: %p, rc: %d\n",
+	      __func__, sfp->last_rx_los, val, sfp->rx_los_changed, err);
+	sfp->last_rx_los = val;
+
+	return val;
+}
+
+/**
  * Registers a function to be called whenever rx_los changes
  *
  * @param	sfp		Handle to SFP data structure
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-helper-sfp.h OCTEON-SDK/executive/cvmx-helper-sfp.h
--- OCTEON_SDK_CLEAN/executive/cvmx-helper-sfp.h	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-helper-sfp.h	2018-06-28 15:08:31.093008807 -0700
@@ -114,16 +114,16 @@ enum cvmx_phy_sfp_rate {
  */
 enum cvmx_phy_sfp_cable_ext_compliance {
 	CVMX_SFP_CABLE_UNSPEC = 0,
-	CVMX_SFP_CABLE_100G_AOC_HIGH_BER = 0x01,	/** Active optical cable */
-	CVMX_SFP_CABLE_100G_SR4 = 0x2,
-	CVMX_SFP_CABLE_100G_LR4 = 0x3,
-	CVMX_SFP_CABLE_100G_ER4 = 0x4,
+	CVMX_SFP_CABLE_100G_25GAUI_C2M_AOC_HIGH_BER = 0x01,	/** Active optical cable */
+	CVMX_SFP_CABLE_100G_SR4_25G_SR = 0x2,
+	CVMX_SFP_CABLE_100G_LR4_25G_LR = 0x3,
+	CVMX_SFP_CABLE_100G_ER4_25G_ER = 0x4,
 	CVMX_SFP_CABLE_100G_SR10 = 0x5,
 	CVMX_SFP_CABLE_100G_CWDM4_MSA = 0x6,
 	CVMX_SFP_CABLE_100G_PSM4 = 0x7,
-	CVMX_SFP_CABLE_100G_ACC_HIGH_BER = 0x8,
+	CVMX_SFP_CABLE_100G_25GAUI_C2M_ACC_HIGH_BER = 0x8,
 	CVMX_SFP_CABLE_100G_CWDM4 = 0x9,
-	CVMX_SFP_CABLE_100G_CR4 = 0xA,
+	CVMX_SFP_CABLE_100G_CR4_25G_CR_CA_L = 0xB,
 	CVMX_SFP_CABLE_25G_CR_CA_S = 0xC,
 	CVMX_SFP_CABLE_25G_CR_CA_N = 0xD,
 	CVMX_SFP_CABLE_40G_ER4 = 0x10,
@@ -134,8 +134,8 @@ enum cvmx_phy_sfp_cable_ext_compliance {
 	CVMX_SFP_CABLE_G959_1_P1L1_2D2 = 0x15,
 	CVMX_SFP_CABLE_10GBASE_T = 0x16,
 	CVMX_SFP_CABLE_100G_CLR4 = 0x17,
-	CVMX_SFP_CABLE_100G_AOC_LOW_BER = 0x18,
-	CVMX_SFP_CABLE_100G_ACC_LOW_BER = 0x19,
+	CVMX_SFP_CABLE_100G_25GAUI_C2M_AOC_LOW_BER = 0x18,
+	CVMX_SFP_CABLE_100G_25GAUI_C2M_ACC_LOW_BER = 0x19,
 	CVMX_SFP_CABLE_100G_2_LAMBDA_DWDM = 0x1a
 };
 
@@ -291,13 +291,32 @@ int cvmx_phy_sfp_parse_eeprom(struct cvm
 void cvmx_phy_sfp_print_info(const struct cvmx_sfp_mod_info *sfp_info);
 
 /**
+ * Returns the information about a SFP/QSFP device
+ *
+ * @param	sfp		sfp handle
+ *
+ * @return	sfp_info	Pointer sfp mod info data structure
+ */
+const struct cvmx_sfp_mod_info *cvmx_phy_get_sfp_mod_info(const struct cvmx_fdt_sfp_info *sfp);
+
+/**
+ * Reads SFP/QSFP EEPROM
+ *
+ * @param	sfp	sfp handle to read
+ * @param	buffer	Buffer to retrun data from SFP EEPROM
+ *
+ * @return	0 for success, -1 on error.
+ */
+int cvmx_sfp_read_i2c_eeprom(struct cvmx_fdt_sfp_info *sfp, uint8_t *buffer);
+
+/**
  * Reads and parses SFP/QSFP EEPROM
  *
  * @param	sfp	sfp handle to read
  *
  * @return	0 for success, -1 on error.
  */
-int cvmx_sfp_read_i2c_eeprom(struct cvmx_fdt_sfp_info *sfp);
+int cvmx_sfp_parse_i2c_eeprom(struct cvmx_fdt_sfp_info *sfp);
 
 /**
  * Function called to check and return the status of the mod_abs pin or
@@ -342,6 +361,26 @@ int cvmx_sfp_register_mod_abs_changed(st
 	void *mod_abs_changed_data);
 
 /**
+ * Function called to check and return the status of the tx_fault pin
+ *
+ * @param	sfp	Handle to SFP information.
+ * @param	data	User-defined data passed to the function
+ *
+ * @return	0 if signal present, 1 if signal absent, -1 on error
+ */
+int cvmx_sfp_check_tx_fault(struct cvmx_fdt_sfp_info *sfp, void *data);
+
+/**
+ * Function called to check and return the status of the rx_los pin
+ *
+ * @param	sfp	Handle to SFP information.
+ * @param	data	User-defined data passed to the function
+ *
+ * @return	0 if signal present, 1 if signal absent, -1 on error
+ */
+int cvmx_sfp_check_rx_los(struct cvmx_fdt_sfp_info *sfp, void *data);
+
+/**
  * Registers a function to be called whenever rx_los changes
  *
  * @param	sfp		Handle to SFP data structure
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-helper.h OCTEON-SDK/executive/cvmx-helper.h
--- OCTEON_SDK_CLEAN/executive/cvmx-helper.h	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-helper.h	2018-06-28 15:08:31.094008807 -0700
@@ -141,7 +141,8 @@ typedef enum {
 typedef union cvmx_helper_link_info {
 	uint64_t u64;
 	struct {
-		uint64_t reserved_20_63:44;
+		uint64_t reserved_21_63:43;
+		uint64_t init_success:1;    /**< if link is not up, is link_init success? */	
 		uint64_t link_up:1;	    /**< Is the physical link up? */
 		uint64_t full_duplex:1;
 					    /**< 1 if the link is full duplex */
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-pki-cluster.h OCTEON-SDK/executive/cvmx-pki-cluster.h
--- OCTEON_SDK_CLEAN/executive/cvmx-pki-cluster.h	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-pki-cluster.h	2018-06-28 15:08:31.094008807 -0700
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2013-2017  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2013-2015  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -40,12 +40,11 @@
 /**
  * @file
  *
- * <hr>$Revision:  $<hr>
+ * <hr>$Revision: 120981 $<hr>
  */
 
-/* GRE_ENCAP_SUPPORT tag */
 /* This file is autogenerated from ipemainc.elf */
-const int cvmx_pki_cluster_code_length = 1001;
+const int cvmx_pki_cluster_code_length = 741;
 const uint64_t cvmx_pki_cluster_code_default[] = {
     0x000000000a000000ull,
     0x0000413a68024070ull,
@@ -121,28 +120,7 @@ const uint64_t cvmx_pki_cluster_code_def
     0x0006552a4e09312dull,
     0x00065cb968082868ull,
     0x0006410246090000ull,
-    0x9060813901000000ull,
-    0x0004c639ff000800ull,
-    0x0004400072010000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x00045cb942080000ull,
-    0x9084552a4e09312dull,
-    0x90a4c639ff000900ull,
-    0x00045f80680100f0ull,
-    0x0004403f72010001ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x00045cb942080000ull,
-    0x9004552a4e09312dull,
+    0x9000813901000000ull,
     0x0004c639ff000a00ull,
     0x0004400072010000ull,
     0x00048181ff00ff00ull,
@@ -385,146 +363,27 @@ const uint64_t cvmx_pki_cluster_code_def
     0xa429418068010038ull,
     0x00095a3468010870ull,
     0x0009028386000005ull,
-    0x000a068186000014ull,
-    0xacca15ab74000343ull,
-    0xacebc639ff002200ull,
-    0x000b5f80680100f0ull,
-    0xac8b403f72010000ull,
-    0x000b8203000f0005ull,
+    0xac8a068186000014ull,
+    0x000a15ab74000343ull,
     0x000b5a3468010070ull,
+    0xac6b8203000f0005ull,
     0x0009d4a907c00240ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x000b5cb942080000ull,
-    0xad0b552a4e09312dull,
-    0xad2bc639ff002700ull,
-    0x000b5f80680100f0ull,
-    0xac6b403f72010001ull,
-    0x0001c00000000000ull,
     0x000b82013fff0000ull,
     0x0009d52a00010001ull,
     0x0009d4a9f8006800ull,
     0x0009593268020870ull,
     0x0006418068030230ull,
-    0x000b5cb942080000ull,
-    0x000b552a4e09312dull,
     0x0006410240030000ull,
     0x9c01c00000000000ull,
     0x0001c00000000000ull,
     0x00078201f0006000ull,
     0x0008593268020070ull,
-    0x0008d4a907c00280ull,
-    0xa069d4a907c00000ull,
+    0xa068d4a907c00280ull,
     0x00085a3468010874ull,
     0x0008818100ff0000ull,
     0x000615ab74000345ull,
     0x00075a3468010078ull,
-    0x9c8741b9680040f0ull,
-    0x9ca7c603ff001f00ull,
-    0x00075f80680100f0ull,
-    0x0007403f72010001ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0007418342080000ull,
-    0x9cc7552a4e09312dull,
-    0x9ce7c603ff002000ull,
-    0x00075f80680100f0ull,
-    0x0007403f72010000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0007418342080000ull,
-    0x9d07552a4e09312dull,
-    0x9d27c603ff002100ull,
-    0x00075f80680100f0ull,
-    0x0007403f72010001ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0007418342080000ull,
-    0x0007552a4e09312dull,
-    0x9d475c80680300f0ull,
-    0x9d67c639ff002200ull,
-    0x00075f80680100f0ull,
-    0x0007403f72010000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x00075cb942080000ull,
-    0x0007552a4e09312dull,
-    0x9d8741b9680040f0ull,
-    0x9da7c603ff002400ull,
-    0x00075f80680100f0ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0007403f72010000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0007418342080000ull,
-    0x9dc7552a4e09312dull,
-    0x9de7c603ff002500ull,
-    0x00075f80680100f0ull,
-    0x0007403f72010001ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0007418342080000ull,
-    0x0007552a4e09312dull,
-    0x0007010240000020ull,
-    0x9c01c00000000000ull,
-    0x9c27c603ff002600ull,
-    0x00075f80680100f0ull,
-    0x0007403f72010000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0007418342080000ull,
-    0x0007552a4e09312dull,
-    0x9c475c80680300f0ull,
-    0x9c67c639ff002700ull,
-    0x00075f80680100f0ull,
-    0x0007403f72010001ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x00075cb942080000ull,
-    0x0007552a4e09312dull,
-    0x0007010240000008ull,
+    0x0007010240000028ull,
     0xa80782b400ff0000ull,
     0x000ad4a907c002c0ull,
     0x000a5a3468010078ull,
@@ -562,31 +421,6 @@ const uint64_t cvmx_pki_cluster_code_def
     0x0006410246090000ull,
     0x000042a486020000ull,
     0x000a15ab74000343ull,
-    0x000081b940004000ull,
-    0x000685a907c00000ull,
-    0x000782b807000100ull,
-    0x000a41b268004070ull,
-    0x000a410040030000ull,
-    0x000a41ba68004078ull,
-    0x000a410240030000ull,
-    0xa801c00000000000ull,
-    0xa821c00000000000ull,
-    0x000a4180680100f0ull,
-    0x000ac639ff003900ull,
-    0x000a400372010001ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x000a83891f000000ull,
-    0x000f542868090a48ull,
-    0x000f583068020070ull,
-    0x000a5cb942080000ull,
-    0x000a552a4e09312dull,
-    0x000a5cb968082868ull,
-    0x000a410246090000ull,
     0x982881b400ff0011ull,
     0x9881c00000000000ull,
     0x00064180680100f0ull,
@@ -607,22 +441,12 @@ const uint64_t cvmx_pki_cluster_code_def
     0x000a593268020870ull,
     0x000a010240000008ull,
     0x9c21c00000000000ull,
-    0x0007813400ff002full,
-    0x90048201ffff6558ull,
-    0x00098381ffff0800ull,
-    0x00088281b0002000ull,
+    0x9007813400ff002full,
+    0x00048901ffff6558ull,
+    0x00048281b0002000ull,
     0x000a593268020870ull,
     0x000ad4a9f800a800ull,
     0x000adebd02000200ull,
-    0x000e593268020870ull,
-    0x000ed4a9f800a000ull,
-    0x000e010240000004ull,
-    0x000e828180008000ull,
-    0x000a010240000004ull,
-    0x000e828120002000ull,
-    0x000a010240000004ull,
-    0x000e828110001000ull,
-    0x000a010240000004ull,
     0x000082bd02000200ull,
     0xa80ac639ff002800ull,
     0xa861c00000000000ull,
@@ -650,31 +474,6 @@ const uint64_t cvmx_pki_cluster_code_def
     0x000a410246090000ull,
     0x0000422486020000ull,
     0x000815ab74000461ull,
-    0x000081b940004000ull,
-    0x000685a9f8000000ull,
-    0x000782b807000200ull,
-    0x000a41b268004078ull,
-    0x000a410040030000ull,
-    0x000a41ba68004078ull,
-    0x000a410240030000ull,
-    0xa801c00000000000ull,
-    0xa821c00000000000ull,
-    0x000a4180680100f0ull,
-    0x000ac639ff003900ull,
-    0x000a400372010001ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x000a83891f000000ull,
-    0x000f542868090a48ull,
-    0x000f583068020070ull,
-    0x000a5cb942080000ull,
-    0x000a552a4e09312dull,
-    0x000a5cb968082868ull,
-    0x000a410246090000ull,
     0x000081a9f800b800ull,
     0x000689b701000100ull,
     0x000685a9f8009800ull,
@@ -683,7 +482,6 @@ const uint64_t cvmx_pki_cluster_code_def
     0x000601024000000cull,
     0x9801c00000000000ull,
     0x00088a3702000200ull,
-    0x00088629f800a000ull,
     0x00068101ffff8100ull,
     0x0004010240000004ull,
     0x9801c00000000000ull,
@@ -747,72 +545,30 @@ const uint64_t cvmx_pki_cluster_code_def
     0x000481bd04000400ull,
     0x0006c639ff002b00ull,
     0x0006832803e001a0ull,
-    0x000cc18300010001ull,
-    0x000dc18300010000ull,
+    0x000dc18300010001ull,
+    0x000cc18300010000ull,
     0x000641a868034840ull,
     0x0006403472030001ull,
     0x00048228001c0008ull,
     0x000915ab74000541ull,
     0x000082ab00ff0045ull,
     0x000adcb960006000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
+    0x00008329ff000200ull,
+    0x000c8728001c0008ull,
     0x00065cb942080000ull,
     0x0006552a4e09312dull,
     0x00065cb968082868ull,
     0x0006410246090000ull,
     0x000042a486020000ull,
     0x000a15ab74000543ull,
-    0x000081b940004000ull,
-    0x000685a8001f0000ull,
-    0x000782b807000300ull,
-    0x000a41b168004070ull,
-    0x000a410040030000ull,
-    0x000a41ba68004078ull,
-    0x000a410240030000ull,
-    0xa801c00000000000ull,
-    0xa821c00000000000ull,
-    0x000a4180680100f0ull,
-    0x000ac639ff003900ull,
-    0x000a400372010001ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x000a83891f000000ull,
-    0x000f542868090a48ull,
-    0x000f583068020070ull,
-    0x000a5cb942080000ull,
-    0x000a552a4e09312dull,
-    0x000a5cb968082868ull,
-    0x000a410246090000ull,
-    0x00008329ff000200ull,
-    0x000c8728001c0008ull,
     0x000c813920000000ull,
     0x000481b400ff006cull,
     0x0006d42803e001c0ull,
     0x000658b168020870ull,
-    0xa047823400ff0033ull,
+    0x0007823400ff0032ull,
+    0x0008863400ff0033ull,
     0x0008d42803e00180ull,
-    0xa0685f80680100f0ull,
-    0xa007823400ff0032ull,
-    0x0008d42803e00180ull,
-    0xa0285f80680100f0ull,
-    0x0007822803e00180ull,
-    0x0008c639ff002e00ull,
-    0x0008403f72010000ull,
     0x000858b168020870ull,
-    0x00085abf680040f0ull,
-    0x00085d80680100f0ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x00085cb942080000ull,
-    0x0008552a4e09312dull,
-    0x00085cb968082868ull,
-    0x0008410246090000ull,
     0x986981b400ff002full,
     0x0006d42803e00280ull,
     0x00065a80680100f0ull,
@@ -833,21 +589,9 @@ const uint64_t cvmx_pki_cluster_code_def
     0x0008418240030000ull,
     0x000842a486030000ull,
     0x000a15ab74000661ull,
-    0x9008863400ff0084ull,
-    0x0004c639ff002f00ull,
-    0x0004400072010001ull,
-    0x000858b168020870ull,
-    0x00088281ffff0000ull,
-    0x000a15ab74000664ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x00085cb942080000ull,
-    0x9028552a4e09312dull,
+    0x9028863400ff0084ull,
     0x0004c639ff003000ull,
     0x0004403472010000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
     0xa00858b168020870ull,
     0x00088181ffff0000ull,
     0x00068581ffff0000ull,
@@ -863,7 +607,7 @@ const uint64_t cvmx_pki_cluster_code_def
     0x000f583068020070ull,
     0x000042a486020000ull,
     0x000a15ab74000661ull,
-    0x000782b807000400ull,
+    0x000782b800100010ull,
     0x000a41b168004078ull,
     0x000a410040030000ull,
     0x000a41ba68004078ull,
@@ -919,8 +663,6 @@ const uint64_t cvmx_pki_cluster_code_def
     0x000050a168030c20ull,
     0x000082aa00800080ull,
     0x000850a168080c2bull,
-    0x0000820800010001ull,
-    0x000850a168000c20ull,
     0x000752a56808001eull,
     0x000a822a00400040ull,
     0x00088a0900010001ull,
@@ -1025,9 +767,6 @@ const uint64_t cvmx_pki_cluster_code_def
     0x0004893d40000000ull,
     0x00005700680800f0ull,
     0x00005780680900f0ull,
-    0x00008229f800a000ull,
-    0x0008c180ffff0018ull,
-    0x000857af680320f0ull,
     0x0007d72ef1ff0000ull,
     0x0007d7aff0000000ull,
     0x0004d72e00fc0000ull,
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/cvmx-twsi.c OCTEON-SDK/executive/cvmx-twsi.c
--- OCTEON_SDK_CLEAN/executive/cvmx-twsi.c	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/cvmx-twsi.c	2018-06-28 15:08:31.095008809 -0700
@@ -69,6 +69,10 @@
 #define cvmx_csr_db_decode(...)
 #endif /*PRINT_TWSI_CONFIG */
 
+static int cvmx_twsix_unblock(int twsi_id);
+static int cvmx_twsix_reset(int twsi_id);
+static int cvmx_twsix_stop(int twsi_id);
+
 #if 0
 static int node_bus_to_i2c_bus(int node, int bus)
 {
@@ -113,55 +117,6 @@ struct i2c_adapter *__cvmx_twsix_get_ada
 EXPORT_SYMBOL(__cvmx_twsix_get_adapter);
 #endif
 
-#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
-/**
- * Unblock the I2C bus.  This should be done during initialization and if the
- * I2C bus gets stuck due to a device resetting unexpectedly.
- */
-int cvmx_twsix_unblock(int twsi_id)
-{
-	cvmx_mio_tws_sw_twsi_t sw_twsi;
-	cvmx_mio_tws_int_t tws_int;
-	uint64_t old_sw_twsi;
-	int i;
-	int twsi_bus = __i2c_twsi_bus(twsi_id);
-
-	/* Put the bus in low-level mode */
-	old_sw_twsi = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-					 CVMX_MIO_TWSX_SW_TWSI(twsi_bus));
-	sw_twsi.u64 = 0;
-	sw_twsi.s.v = 1;
-	sw_twsi.s.op = 6;
-	sw_twsi.s.eop_ia = TWSI_CTL;
-	sw_twsi.s.d = 0x40;	/* ENAB !CE !AAK */
-	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi.u64);
-	cvmx_wait_usec(10);
-	tws_int.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-					 CVMX_MIO_TWSX_INT(twsi_bus));
-	cvmx_wait_usec(10);
-	tws_int.s.scl_ovr = 0;
-	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_INT(twsi_bus), tws_int.u64);
-	cvmx_wait_usec(10);
-	for (i = 0; i < 9; i++) {
-		tws_int.s.scl_ovr = 1;
-		cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-				    CVMX_MIO_TWSX_INT(twsi_bus), tws_int.u64);
-		cvmx_wait_usec(10);
-		tws_int.s.scl_ovr = 0;
-		cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-				    CVMX_MIO_TWSX_INT(twsi_bus), tws_int.u64);
-		cvmx_wait_usec(10);
-	}
-	/* Restore back to high level mode */
-	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), old_sw_twsi);
-	cvmx_wait_usec(10);
-	return 0;
-}
-#endif
-
 /**
  * Do a twsi read from a 7 bit device address using an (optional) internal address.
  * Up to 8 bytes can be read at a time.
@@ -794,37 +749,49 @@ static int cvmx_twsix_wait(int twsi_id)
 
 static int cvmx_twsix_start(int twsi_id)
 {
-	int ret_val;
-	uint8_t tmp;
+	uint8_t stat;
+	static int8_t reset_method = 0;
 
-	cvmx_twsix_write_llc_reg(twsi_id, SW_TWSI_EOP_TWSI_CTL,
-				 TWSI_CTL_ENAB | TWSI_CTL_STA);
+	do {
+		cvmx_twsix_write_llc_reg(twsi_id, SW_TWSI_EOP_TWSI_CTL,
+				 	TWSI_CTL_ENAB | TWSI_CTL_STA);
 
-	ret_val = cvmx_twsix_wait(twsi_id);
-	if (ret_val) {
-		tmp = cvmx_twsix_read_llc_reg(twsi_id, SW_TWSI_EOP_TWSI_STAT);
-		if (tmp == STAT_IDLE) {
-			/*
-			 * Controller refused to send start flag May
-			 * be a client is holding SDA low - let's try
-			 * to free it.
-			 */
-			cvmx_twsix_unblock(twsi_id);
-			cvmx_twsix_write_llc_reg(twsi_id, SW_TWSI_EOP_TWSI_CTL,
-						 TWSI_CTL_ENAB | TWSI_CTL_STA);
+		cvmx_twsix_wait(twsi_id);
 
-			ret_val = cvmx_twsix_wait(twsi_id);
+		stat = cvmx_twsix_read_llc_reg(twsi_id, SW_TWSI_EOP_TWSI_STAT);
+
+		switch (stat) {
+			case STAT_START:
+			case STAT_RSTART:
+				reset_method = 0;
+				return 0;
+
+			default:
+				cvmx_twsix_stop(twsi_id);		
+
+				switch (reset_method++ %4) {
+					case 0:
+						break;
+					case 1:
+						/*
+						 * Controller refused to send start flag May
+						 * be a client is holding SDA low - let's try
+						 * to free it.
+						 */
+						cvmx_twsix_unblock(twsi_id);
+						break;
+					case 2:
+						cvmx_twsix_reset(twsi_id);
+						break;
+					default:
+						reset_method = 0;
+						return -1;
+				}
+
+				break;
 		}
-		if (ret_val)
-			return ret_val;
-	}
 
-	tmp = cvmx_twsix_read_llc_reg(twsi_id, SW_TWSI_EOP_TWSI_STAT);
-	if ((tmp != STAT_START) && (tmp != STAT_RSTART)) {
-		twsi_printf("%s %d: bad status (0x%x)\n", __func__, __LINE__,
-			    tmp);
-		return -1;
-	}
+	} while (true);
 
 	return 0;
 }
@@ -953,6 +920,92 @@ restart:
 
 	return 0;
 }
+
+/**
+ * Unblock the I2C bus.  This should be done during initialization and if the
+ * I2C bus gets stuck due to a device resetting unexpectedly.
+ */
+int cvmx_twsix_unblock(int twsi_id)
+{
+	cvmx_mio_tws_sw_twsi_t sw_twsi;
+	cvmx_mio_tws_int_t tws_int;
+	uint64_t old_sw_twsi;
+	int i;
+	int twsi_bus = __i2c_twsi_bus(twsi_id);
+
+	/* Put the bus in low-level mode */
+	old_sw_twsi = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
+					 CVMX_MIO_TWSX_SW_TWSI(twsi_bus));
+	sw_twsi.u64 = 0;
+	sw_twsi.s.v = 1;
+	sw_twsi.s.op = 6;
+	sw_twsi.s.eop_ia = TWSI_CTL;
+	sw_twsi.s.d = 0x40;	/* ENAB !CE !AAK */
+	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
+			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi.u64);
+	cvmx_wait_usec(10);
+	tws_int.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
+					 CVMX_MIO_TWSX_INT(twsi_bus));
+	cvmx_wait_usec(10);
+	tws_int.s.scl_ovr = 0;
+	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
+			    CVMX_MIO_TWSX_INT(twsi_bus), tws_int.u64);
+	cvmx_wait_usec(10);
+	for (i = 0; i < 9; i++) {
+		tws_int.s.scl_ovr = 1;
+		cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
+				    CVMX_MIO_TWSX_INT(twsi_bus), tws_int.u64);
+		cvmx_wait_usec(10);
+		tws_int.s.scl_ovr = 0;
+		cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
+				    CVMX_MIO_TWSX_INT(twsi_bus), tws_int.u64);
+		cvmx_wait_usec(10);
+	}
+	/* Restore back to high level mode */
+	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
+			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), old_sw_twsi);
+	cvmx_wait_usec(10);
+	return 0;
+}
+
+/**
+ * Reset the I2C bus.  This should be done during initialization and if the
+ * I2C bus gets stuck due to a device resetting unexpectedly.
+ */
+int cvmx_twsix_reset(int twsi_id)
+{
+	cvmx_mio_tws_sw_twsi_t sw_twsi;
+	cvmx_mio_twsx_sw_twsi_t tmp;
+	int i;
+	uint8_t status = 0;
+	int twsi_bus = __i2c_twsi_bus(twsi_id);
+
+	sw_twsi.u64 = 0;
+	sw_twsi.s.v = 1;
+	sw_twsi.s.r = 0;
+	sw_twsi.s.op = 6;
+	sw_twsi.s.eop_ia = TWSI_RST;
+
+	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
+			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi.u64);
+
+	do {
+		tmp.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
+					     CVMX_MIO_TWSX_SW_TWSI(twsi_bus));
+	} while (tmp.s.v != 0);
+
+	cvmx_wait_io(315);
+
+	for (i = 10; i && status != STAT_IDLE; i--) {
+		status = cvmx_twsix_read_llc_reg(twsi_id, SW_TWSI_EOP_TWSI_STAT);
+		cvmx_wait_usec(1);
+	}
+
+	if (status != STAT_IDLE)
+		return 1;
+
+	return 0;
+}
 
 static int cvmx_twsix_stop(int twsi_id)
 {
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/libfdt/cvmx-helper-fdt.c OCTEON-SDK/executive/libfdt/cvmx-helper-fdt.c
--- OCTEON_SDK_CLEAN/executive/libfdt/cvmx-helper-fdt.c	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/libfdt/cvmx-helper-fdt.c	2018-06-28 15:08:31.096008809 -0700
@@ -200,6 +200,8 @@ static const struct mux_compat mux_compa
 extern int cvmx_sfp_vsc7224_mod_abs_changed(struct cvmx_fdt_sfp_info *sfp_info,
 					    int val, void *data);
 
+extern int cvmx_sfp_avsp5410_mod_abs_changed(struct cvmx_fdt_sfp_info *sfp_info,
+					    int val, void *data);
 /**
  * Local allocator to handle both SE and U-Boot that also zeroes out memory
  *
@@ -1858,6 +1860,149 @@ int __cvmx_fdt_parse_vsc7224(const void
 }
 
 /**
+ * @INTERNAL
+ * Parses all instances of the Avago AVSP5410 gearbox phy
+ *
+ * @param[in]	fdt_addr	Address of flat device tree
+ *
+ * @return	0 for success, error otherwise
+ */
+int __cvmx_fdt_parse_avsp5410(const void *fdt_addr)
+{
+	int of_offset = -1;
+	struct cvmx_avsp5410 *avsp5410 = NULL;
+	struct cvmx_fdt_sfp_info *sfp_info;
+	int err = 0;
+	int of_parent;
+	static bool parsed = false;
+	int of_mac;
+	int xiface, index;
+	bool is_qsfp __attribute__((unused));
+	const char *mac_str;
+
+	debug("%s(%p)\n", __func__, fdt_addr);
+
+	if (parsed) {
+		debug("%s: Already parsed\n", __func__);
+		return 0;
+	}
+	do {
+		of_offset = fdt_node_offset_by_compatible(fdt_addr, of_offset,
+							  "avago,avsp-5410");
+		debug("%s: of_offset: %d\n", __func__, of_offset);
+		if (of_offset == -FDT_ERR_NOTFOUND)
+			break;
+		else if (of_offset < 0) {
+			err = -1;
+			cvmx_dprintf("%s: Error %d parsing FDT\n",
+				     __func__, of_offset);
+			break;
+		}
+
+
+		avsp5410 = cvm_fdt_alloc(sizeof(*avsp5410));
+
+		if (!avsp5410) {
+			cvmx_dprintf("%s: Out of memory!\n", __func__);
+			return -1;
+		}
+		avsp5410->of_offset = of_offset;
+		avsp5410->i2c_addr = cvmx_fdt_get_int(fdt_addr,of_offset,
+						     "reg", -1);
+		of_parent = fdt_parent_offset(fdt_addr, of_offset);
+		avsp5410->i2c_bus = cvmx_fdt_get_i2c_bus(fdt_addr, of_parent);
+		if (avsp5410->i2c_addr < 0) {
+			cvmx_dprintf("%s: Error: reg field missing\n",
+				     __func__);
+			err = -1;
+			break;
+		}
+		if (!avsp5410->i2c_bus) {
+			cvmx_dprintf("%s: Error getting i2c bus\n", __func__);
+			err = -1;
+			break;
+		}
+		avsp5410->name = fdt_get_name(fdt_addr, of_offset, NULL);
+		debug("%s: Adding %s\n", __func__, avsp5410->name);
+
+		/* Now find out which interface it's mapped to */
+		avsp5410->ipd_port = -1;
+
+		mac_str = "sfp-mac";
+		if (fdt_getprop(fdt_addr, of_offset, mac_str, NULL)) {
+			is_qsfp = false;
+		} else if (fdt_getprop(fdt_addr, of_offset, "qsfp-mac", NULL)) {
+			is_qsfp = true;
+			mac_str = "qsfp-mac";
+		} else {
+			cvmx_dprintf("%s: Error: MAC not found for %s\n",
+				     __func__, avsp5410->name);
+			return -1;
+		}
+		of_mac = cvmx_fdt_lookup_phandle(fdt_addr, of_offset, mac_str);
+		if (of_mac < 0) {
+			cvmx_dprintf("%s: Error %d with MAC %s phandle for %s\n",
+				     __func__, of_mac, mac_str, avsp5410->name);
+			return -1;
+		}
+
+		debug("%s: Found mac at offset %d\n", __func__, of_mac);
+		err = cvmx_helper_cfg_get_xiface_index_by_fdt_node_offset(of_mac,
+									  &xiface,
+									  &index);
+		if (!err) {
+			avsp5410->xiface = xiface;
+			avsp5410->index = index;
+			avsp5410->ipd_port = cvmx_helper_get_ipd_port(xiface,
+								     index);
+
+			debug("%s: Found MAC, xiface: 0x%x, index: %d, ipd port: %d\n",
+			      __func__, xiface, index, avsp5410->ipd_port);
+			if (avsp5410->ipd_port >= 0) {
+				cvmx_helper_cfg_set_avsp5410_info(xiface,
+								      index,
+								      avsp5410);
+				debug("%s: Storing config phy for xiface 0x%x, index %d\n",
+				      __func__, xiface, index);
+			}
+			sfp_info = cvmx_helper_cfg_get_sfp_info(xiface, index);
+			if (!sfp_info) {
+				cvmx_dprintf("%s: Warning: no (Q)SFP+ slot found for xinterface 0x%x, index %d\n",
+					     __func__, xiface, index);
+				continue;
+			}
+
+			sfp_info->is_avsp5410 = true;
+			sfp_info->avsp5410 = avsp5410;
+			debug("%s: Registering AVSP5410 %s with SFP %s\n",
+			      __func__, avsp5410->name, sfp_info->name);
+			if (!sfp_info->mod_abs_changed) {
+				debug("%s: Registering cvmx_sfp_avsp5410_mod_abs_changed at %p for xinterface 0x%x, index %d\n",
+				      __func__,
+				      &cvmx_sfp_avsp5410_mod_abs_changed,
+				      xiface, index);
+				cvmx_sfp_register_mod_abs_changed(sfp_info,
+					&cvmx_sfp_avsp5410_mod_abs_changed,
+					NULL);
+			}
+		}
+	} while (of_offset > 0);
+
+	if (err) {
+		debug("%s(): Error\n", __func__);
+		if (avsp5410) {
+			if (avsp5410->i2c_bus)
+				cvmx_fdt_free_i2c_bus(avsp5410->i2c_bus);
+			cvm_fdt_free(avsp5410, sizeof(*avsp5410));
+		}
+	}
+	if (!err)
+		parsed = true;
+
+	return err;
+}
+
+/**
  * Parse QSFP GPIOs for SFP
  *
  * @param[in]	fdt_addr	Pointer to flat device tree
@@ -1935,6 +2080,9 @@ static int cvmx_parse_sfp_eeprom(const v
 								   of_eeprom));
 	sfp_info->i2c_eeprom_addr = cvmx_fdt_get_int(fdt_addr, of_eeprom,
 						     "reg", 0x50);
+
+	debug("%s(%p, %d, %s, %d)\n", __func__, fdt_addr, of_offset, sfp_info->name, sfp_info->i2c_eeprom_addr);
+
 	if (!sfp_info->i2c_bus) {
 		cvmx_dprintf("%s: Error: could not determine i2c bus for eeprom for %s\n",
 			     __func__, sfp_info->name);
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/executive/libfdt/cvmx-helper-fdt.h OCTEON-SDK/executive/libfdt/cvmx-helper-fdt.h
--- OCTEON_SDK_CLEAN/executive/libfdt/cvmx-helper-fdt.h	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/executive/libfdt/cvmx-helper-fdt.h	2018-06-28 15:08:31.096008809 -0700
@@ -215,6 +215,10 @@ struct cvmx_fdt_sfp_info {
 	bool is_vsc7224;
 	/** Data structure for first vsc7224 channel we're attached to */
 	struct cvmx_vsc7224_chan *vsc7224_chan;
+	/** True if we're connected to a Avago AVSP5410 phy */
+	bool is_avsp5410;
+	/** Data structure for avsp5410 phy we're attached to */
+	struct cvmx_avsp5410 *avsp5410;
 	/** xinterface we're on */
 	int xiface;
 	/** port index */
@@ -663,6 +667,16 @@ cvmx_sfp_get_phy_info(const struct cvmx_
 int __cvmx_fdt_parse_vsc7224(const void *fdt_addr);
 
 /**
+ * @INTERNAL
+ * Parses all instances of the Avago AVSP5410 gearbox phy
+ *
+ * @param[in]   fdt_addr        Address of flat device tree
+ *
+ * @return      0 for success, error otherwise
+ */
+int __cvmx_fdt_parse_avsp5410(const void *fdt_addr);
+
+/**
  * Parse SFP information from device tree
  *
  * @param[in]	fdt_addr	Address of flat device tree
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/host/bin/oct-version OCTEON-SDK/host/bin/oct-version
--- OCTEON_SDK_CLEAN/host/bin/oct-version	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/host/bin/oct-version	2018-06-28 15:08:31.096008809 -0700
@@ -1 +1 @@
-echo Cavium Inc. OCTEON SDK version 3.1.2-p13, build 610
+echo Cavium Inc. OCTEON SDK version 3.1.2-p13-L4, build 610
diff -rpu3 --new-file --no-dereference OCTEON_SDK_CLEAN/host/remote-lib/octeon-remote-hotplug.c OCTEON-SDK/host/remote-lib/octeon-remote-hotplug.c
--- OCTEON_SDK_CLEAN/host/remote-lib/octeon-remote-hotplug.c	2018-05-15 11:35:40.000000000 -0700
+++ OCTEON-SDK/host/remote-lib/octeon-remote-hotplug.c	2018-06-29 11:58:49.329555118 -0700
@@ -67,7 +67,7 @@ void octeon_remote_read_mem2(void *buffe
 {
 	uint64_t *p = buffer;
 	int i = len / sizeof(uint64_t);
-	for (; i >= 0; i--)
+	for (i--; i >= 0; i--)
 		p[i] = octeon_remote_read_mem64(pa + i * sizeof(uint64_t));
 }
 
@@ -76,7 +76,7 @@ void octeon_remote_write_mem2(uint64_t p
 {
 	uint64_t *p = buffer;
 	int i = len / sizeof(uint64_t);
-	for (; i >= 0; i--)
+	for (i--; i >= 0; i--)
 		octeon_remote_write_mem64(pa + i * sizeof(uint64_t), p[i]);
 }

